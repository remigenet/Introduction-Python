[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction à Python: ",
    "section": "",
    "text": "Star this website on Github"
  },
  {
    "objectID": "index.html#rémi-genet",
    "href": "index.html#rémi-genet",
    "title": "Introduction à Python: ",
    "section": "",
    "text": "Star this website on Github"
  },
  {
    "objectID": "content/Cours_1/6-IDEs.html",
    "href": "content/Cours_1/6-IDEs.html",
    "title": "Les IDEs",
    "section": "",
    "text": "A. Définition et Objectif des IDE\n\nQu’est-ce qu’un IDE ?\n\nUn Environnement de Développement Intégré (IDE) est une application logicielle qui fournit des outils complets et intégrés pour le développement de logiciels.\nIl combine un éditeur de code, un compilateur ou interpréteur, un débogueur, et souvent des outils supplémentaires dans une interface unifiée.\n\nObjectif d’un IDE\n\nL’objectif principal d’un IDE est de maximiser la productivité du développeur en simplifiant le processus de développement avec des outils intégrés et une interface utilisateur conviviale.\nIl vise à réduire la complexité de configuration des différents outils nécessaires au développement.\n\n\n\n\nB. Fonctionnalités Clés des IDE pour Python\n\nÉditeur de Code\n\nPropose la coloration syntaxique, l’auto-complétion, et la refactorisation du code pour faciliter la lecture et l’écriture du code Python.\n\nDébogueur\n\nIntègre des fonctionnalités pour exécuter le code pas à pas, inspecter les variables, et identifier les erreurs, rendant le débogage plus intuitif.\n\nGestion des Projets\n\nOffre des outils pour organiser et gérer les fichiers de code, ressources, et dépendances, améliorant la structure et la maintenabilité des projets.\n\nIntégration de Contrôle de Version\n\nIntègre des systèmes de contrôle de version comme Git, facilitant la gestion des versions et la collaboration entre développeurs.\n\nConsole et Terminal Intégrés\n\nPermet l’exécution de scripts Python et l’interaction avec l’interpréteur directement dans l’IDE, offrant une expérience de développement fluide.\n\nSupport des Frameworks et Bibliothèques\n\nFournit une intégration avec des frameworks de développement web, de science des données, et d’autres bibliothèques Python, facilitant le développement dans des domaines spécifiques.\n\n\n\n\nC. Rôle des IDE dans le Développement Python\n\nProductivité et Efficacité\n\nLes IDE accélèrent le processus de développement en automatisant les tâches répétitives et en fournissant des raccourcis pratiques.\n\nQualité et Cohérence du Code\n\nLes fonctionnalités comme la vérification de syntaxe, la refactorisation et le formatage du code contribuent à maintenir une haute qualité et une cohérence du code.\n\nApprentissage et Accessibilité\n\nPour les débutants, les IDE peuvent simplifier l’apprentissage du langage Python en offrant une interface plus accessible et des outils d’aide à la programmation.\n\nCollaboration et Travail d’Équipe\n\nLes outils intégrés de gestion de versions et de collaboration facilitent le travail en équipe, en particulier sur de grands projets avec de nombreux contributeurs.\n\n\n\n\nD. Choisir un IDE pour Python\nLe choix d’un IDE dépend de plusieurs facteurs : - Niveau d’Expérience : Certains IDE sont mieux adaptés aux débutants avec des interfaces plus simples, tandis que d’autres offrent des fonctionnalités avancées pour les développeurs expérimentés. - Type de Projet : Selon le projet (développement web, data science, scripts), certains IDE offrent des outils et intégrations spécifiques plus adaptés. - Préférences Personnelles : L’interface utilisateur, la configuration et les extensions disponibles peuvent influencer le choix d’un IDE.\nLes IDEs jouent un rôle essentiel dans le développement moderne en fournissant un environnement riche et intégré pour le codage, le test, le débogage et le déploiement de logiciels. Pour les développeurs Python, le choix d’un IDE adapté peut grandement affecter l’efficacité et la qualité du processus de développement.\nPycharm Spyder VsCode\n\n\n\n\n Back to top",
    "crumbs": [
      "Les IDEs"
    ]
  },
  {
    "objectID": "content/Cours_1/TP-Version-SimplePyenv.html",
    "href": "content/Cours_1/TP-Version-SimplePyenv.html",
    "title": "TP Guidé - Installer plusieurs versions de python avec pyenv",
    "section": "",
    "text": "L’objectif de ce TP est de maîtriser la configuration d’une installation Python simple, permettant l’utilisation de différentes versions de Python sur une même machine et de passer facilement d’une version à l’autre. Pour cela, nous utiliserons Pyenv, un gestionnaire de versions Python reconnu pour sa facilité d’utilisation. Pyenv est disponible pour les systèmes Mac et Linux, et une alternative pour Windows est également proposée.\nLe second objectif est de vous apprendre comment chercher des librairies, des outils qui peuvent vous être utile, et surtout à simplement penser à lire ce qui est écrit devant vous.\n\n\n\nPour utiliser Pyenv, une recherche sur Google avec les mots-clés “Pyenv” ou “gestionnaire de versions Python” conduit généralement à un dépôt GitHub. Bien que GitHub puisse sembler complexe au premier abord, il suffit de suivre les instructions d’installation spécifiques à votre système d’exploitation.\n\nPour linux et Mac, il suffit de taper les commandes suivantes dans un terminal :\ncurl https://pyenv.run | bash\nCependant pour certains sur Mac des installations d’autres dépendances peuvent être demandé à l’installation, surveuillé simplement ce qu’indique votre terminal.\nUn petit rappel utile des commandes linux est disponible ici. Ici la commande utilisé est curl qui permet de télécharger un fichier depuis un lien, qui est ensuite redirigé vers la commande bash qui permet d’exécuter un script bash, à l’aide d’un pipe |.\n\n\n\n\nSur mon exemple ci-dessous en regardant les logs d’informations on peut ainsi voir un warning, car je possède déjà pyenv d’installer, et l’installation a donc échoué. Afin de pouvoir montrer un exemple pour ce cours, regardons comment j’ai pu faire, simplement sans détruire mon installation existante. Tout d’abord à l’aide de la commande ls on peut voir ce qui se trouve dans les dossiers depuis l’invite de commande. ls, comme la plupart des commandes linux, possède des options, ici -a qui permet de voir les fichiers cachés, et explique celle-ci en tapant simplement command –help (donc ici ls --help).\n\nAinsi en utilisant l’option -a je peux afficher les dossiers même caché et voir que pyenv est bien installé ici dans le dossier .pyenv (dossier par défaut pour son installation).\n\nRegardons rapidement ce que vous pouvez trouver dans ce dossiers, et bien il y a les versions que j’ai installé de python dans versions, man qui contient les manuels d’utilisation, plugins qui contient les plugins, et shims qui contient les commandes pyenv, ou le dossier completion qui permet de terminer vos commandes simplement en utilisant tab. Pour conserver ma version je vais simplement pouvoir faire mv .pyenv SomeFolderWhereIWantToStoreIt, pour le remettre ensuite.\n\n\n\n\nMaintenant, je peux simplement réinstaller pyenv, et suivre les instructions pour installer les dépendances manquantes, et ainsi avoir une installation propre! Mais malheur, j’ai aussi déjà toute ma configuration du shell de mise en place, et je n’ai aucun warning à montrer. Je peux supprimer la version telecharger avec rm -rf et simplement recommencer l’installation. en utilisant env -i bash, qui permet de lancer un bash sans aucune variable d’environnement, et donc sans aucune configuration. Là le resultat que vous pouvez observer est probablement celui que vous aurez.\n\nIl faut alors simplement lire ce qui est écrit dans le Warning! En l’occurence pyenv nous indique qu’il faut l’ajouter au PATH et dans la configuration du Shell (votre terminal, ce qui vous permet de lancer vos commandes). Pour cela il suffit de suivre les instructions, et de les ajouter dans votre fichier de configuration du shell. Pour cela utiliser ls à nouveau pour voir quel shell vous utiliser, si vous voyez un .zprofile (fréquent sur mac) copier dans celui-ci, mais ce peut etre .profile, .bashrc, .bash_profile … selon la configuration de la machine sur laquelle vous vous trouvez. Pour ce faire deux choix s’offre à vous:\necho 'export PYENV_ROOT=\"$HOME/.pyenv\"' &gt;&gt; ~/.profile\necho 'command -v pyenv &gt;/dev/null || export PATH=\"$PYENV_ROOT/bin:$PATH\"' &gt;&gt; ~/.profile\necho 'eval \"$(pyenv init -)\"' &gt;&gt; ~/.profile\nLancer les commandes ci-dessus (en adaptant bien sur le .profile à votre installation), ou bien ouvrir le fichier avec un éditeur de texte, en faisant vim .profile par exemple, et copier les lignes indiquées dans le fichier. Ensuite il suffit de relancer votre terminal, et de vérifier que pyenv est bien installé avec la commande pyenv –version.\n\nL’installation de pyenv est faite, désormais vous pouvez comme pour ls utiliser –help pour obtenir de l’aide sur les commandes ou man pyenv.\n\n\n\n\nVous pourrez ainsi réaliser que vous pouvez updater votre version de pyenv simplemement en faisant pyenv update, et que vous pouvez lister les versions de python disponible avec pyenv install –list, et installer une version avec pyenv install 3.12.1 par exemple. Une fois plusieurs versions installé vous pouvez switcher entre elle en utilisant simplement pyenv global xxx ou pyenv local xxx, ou bien en utilisant pyenv shell xxx pour une version spécifique dans un dossier.\npyenv global xxx permet de changer la version par défaut, pyenv local xxx permet de changer la version dans un dossier, et pyenv shell xxx permet de changer la version dans un dossier pour une commande.\n\nEnfin, selon les installations que vous avez il se peut que certains soucis apparaissent, comme par exemple le fait que vous n’ayez pas les dépendances pour installer une version de python. Dans ce cas une FAQ est disponible sur le github de pyenv, et vous pouvez aussi utiliser la commande pyenv doctor pour vérifier que tout est bien installé. Un exemple classique est l’absence de librairie SSL, qui vous permet de compiler un python d’apparence normal mais qui coincera dès que vous voudrez utiliser pip. Pour cela il suffit d’installer la librairie manquante (sudo apt install la_librairie_manquante), et de relancer l’installation de python.",
    "crumbs": [
      "Travaux Pratiques",
      "TP Guidé - Installer plusieurs versions de python avec pyenv"
    ]
  },
  {
    "objectID": "content/Cours_1/TP-Version-SimplePyenv.html#tp---version-facile-pour-assurer-les-bases",
    "href": "content/Cours_1/TP-Version-SimplePyenv.html#tp---version-facile-pour-assurer-les-bases",
    "title": "TP Guidé - Installer plusieurs versions de python avec pyenv",
    "section": "",
    "text": "L’objectif de ce TP est de maîtriser la configuration d’une installation Python simple, permettant l’utilisation de différentes versions de Python sur une même machine et de passer facilement d’une version à l’autre. Pour cela, nous utiliserons Pyenv, un gestionnaire de versions Python reconnu pour sa facilité d’utilisation. Pyenv est disponible pour les systèmes Mac et Linux, et une alternative pour Windows est également proposée.\nLe second objectif est de vous apprendre comment chercher des librairies, des outils qui peuvent vous être utile, et surtout à simplement penser à lire ce qui est écrit devant vous.\n\n\n\nPour utiliser Pyenv, une recherche sur Google avec les mots-clés “Pyenv” ou “gestionnaire de versions Python” conduit généralement à un dépôt GitHub. Bien que GitHub puisse sembler complexe au premier abord, il suffit de suivre les instructions d’installation spécifiques à votre système d’exploitation.\n\nPour linux et Mac, il suffit de taper les commandes suivantes dans un terminal :\ncurl https://pyenv.run | bash\nCependant pour certains sur Mac des installations d’autres dépendances peuvent être demandé à l’installation, surveuillé simplement ce qu’indique votre terminal.\nUn petit rappel utile des commandes linux est disponible ici. Ici la commande utilisé est curl qui permet de télécharger un fichier depuis un lien, qui est ensuite redirigé vers la commande bash qui permet d’exécuter un script bash, à l’aide d’un pipe |.\n\n\n\n\nSur mon exemple ci-dessous en regardant les logs d’informations on peut ainsi voir un warning, car je possède déjà pyenv d’installer, et l’installation a donc échoué. Afin de pouvoir montrer un exemple pour ce cours, regardons comment j’ai pu faire, simplement sans détruire mon installation existante. Tout d’abord à l’aide de la commande ls on peut voir ce qui se trouve dans les dossiers depuis l’invite de commande. ls, comme la plupart des commandes linux, possède des options, ici -a qui permet de voir les fichiers cachés, et explique celle-ci en tapant simplement command –help (donc ici ls --help).\n\nAinsi en utilisant l’option -a je peux afficher les dossiers même caché et voir que pyenv est bien installé ici dans le dossier .pyenv (dossier par défaut pour son installation).\n\nRegardons rapidement ce que vous pouvez trouver dans ce dossiers, et bien il y a les versions que j’ai installé de python dans versions, man qui contient les manuels d’utilisation, plugins qui contient les plugins, et shims qui contient les commandes pyenv, ou le dossier completion qui permet de terminer vos commandes simplement en utilisant tab. Pour conserver ma version je vais simplement pouvoir faire mv .pyenv SomeFolderWhereIWantToStoreIt, pour le remettre ensuite.\n\n\n\n\nMaintenant, je peux simplement réinstaller pyenv, et suivre les instructions pour installer les dépendances manquantes, et ainsi avoir une installation propre! Mais malheur, j’ai aussi déjà toute ma configuration du shell de mise en place, et je n’ai aucun warning à montrer. Je peux supprimer la version telecharger avec rm -rf et simplement recommencer l’installation. en utilisant env -i bash, qui permet de lancer un bash sans aucune variable d’environnement, et donc sans aucune configuration. Là le resultat que vous pouvez observer est probablement celui que vous aurez.\n\nIl faut alors simplement lire ce qui est écrit dans le Warning! En l’occurence pyenv nous indique qu’il faut l’ajouter au PATH et dans la configuration du Shell (votre terminal, ce qui vous permet de lancer vos commandes). Pour cela il suffit de suivre les instructions, et de les ajouter dans votre fichier de configuration du shell. Pour cela utiliser ls à nouveau pour voir quel shell vous utiliser, si vous voyez un .zprofile (fréquent sur mac) copier dans celui-ci, mais ce peut etre .profile, .bashrc, .bash_profile … selon la configuration de la machine sur laquelle vous vous trouvez. Pour ce faire deux choix s’offre à vous:\necho 'export PYENV_ROOT=\"$HOME/.pyenv\"' &gt;&gt; ~/.profile\necho 'command -v pyenv &gt;/dev/null || export PATH=\"$PYENV_ROOT/bin:$PATH\"' &gt;&gt; ~/.profile\necho 'eval \"$(pyenv init -)\"' &gt;&gt; ~/.profile\nLancer les commandes ci-dessus (en adaptant bien sur le .profile à votre installation), ou bien ouvrir le fichier avec un éditeur de texte, en faisant vim .profile par exemple, et copier les lignes indiquées dans le fichier. Ensuite il suffit de relancer votre terminal, et de vérifier que pyenv est bien installé avec la commande pyenv –version.\n\nL’installation de pyenv est faite, désormais vous pouvez comme pour ls utiliser –help pour obtenir de l’aide sur les commandes ou man pyenv.\n\n\n\n\nVous pourrez ainsi réaliser que vous pouvez updater votre version de pyenv simplemement en faisant pyenv update, et que vous pouvez lister les versions de python disponible avec pyenv install –list, et installer une version avec pyenv install 3.12.1 par exemple. Une fois plusieurs versions installé vous pouvez switcher entre elle en utilisant simplement pyenv global xxx ou pyenv local xxx, ou bien en utilisant pyenv shell xxx pour une version spécifique dans un dossier.\npyenv global xxx permet de changer la version par défaut, pyenv local xxx permet de changer la version dans un dossier, et pyenv shell xxx permet de changer la version dans un dossier pour une commande.\n\nEnfin, selon les installations que vous avez il se peut que certains soucis apparaissent, comme par exemple le fait que vous n’ayez pas les dépendances pour installer une version de python. Dans ce cas une FAQ est disponible sur le github de pyenv, et vous pouvez aussi utiliser la commande pyenv doctor pour vérifier que tout est bien installé. Un exemple classique est l’absence de librairie SSL, qui vous permet de compiler un python d’apparence normal mais qui coincera dès que vous voudrez utiliser pip. Pour cela il suffit d’installer la librairie manquante (sudo apt install la_librairie_manquante), et de relancer l’installation de python.",
    "crumbs": [
      "Travaux Pratiques",
      "TP Guidé - Installer plusieurs versions de python avec pyenv"
    ]
  },
  {
    "objectID": "content/Cours_1/TP-Version-SimplePyenv.html#pour-ceux-sous-windows",
    "href": "content/Cours_1/TP-Version-SimplePyenv.html#pour-ceux-sous-windows",
    "title": "TP Guidé - Installer plusieurs versions de python avec pyenv",
    "section": "Pour ceux sous Windows",
    "text": "Pour ceux sous Windows\nL’installation est presque totalement similaire, l’une des principales différences étant qu’il faudra lancer les commandes d’installation de pyenv depuis PowerShell lancé en administrateur et non depuis un terminal classique. Dans la plupart des cas si vous n’avez jamais rien installer par ce bien un message d’erreur - copier le dans google et le tour est joué !",
    "crumbs": [
      "Travaux Pratiques",
      "TP Guidé - Installer plusieurs versions de python avec pyenv"
    ]
  },
  {
    "objectID": "content/Cours_1/TP-ConstruireSonPython.html",
    "href": "content/Cours_1/TP-ConstruireSonPython.html",
    "title": "TP - Construire son python depuis la source",
    "section": "",
    "text": "TP - Construire Python depuis la Source\nAfin de vous aider pour réaliser ce TP, vous trouverez une fiche sur l’utilisation de git ici, ainsi qu’une fiche sur les commandes de base du terminal Linux pour ceux qui n’en ont pas l’habitude ici. Pour ceux ayant déjà fait du C ce TP devrait être assez simple, pour les autres, il vous faudra un peu plus de temps pour comprendre les différentes étapes.\n\nPartie 1 : Préparation et Clonage du Répertoire Git de CPython\nLe but de cette première partie est de préparer votre environnement pour la compilation de Python et de cloner le répertoire Git de CPython.\n\nPréparation de l’Environnement :\n\nAvant de cloner le répertoire, assurez-vous que Git est installé sur votre système. Sous Linux et MacOS, Git est souvent préinstallé. Sous Windows, vous devrez peut-être l’installer manuellement.\nVérifiez également que vous disposez des outils de compilation nécessaires. Sous Linux, il s’agit généralement du package build-essential. Sous MacOS, vous aurez besoin de Xcode ou des outils de ligne de commande pour Xcode.\n\nClonage du Répertoire Git de CPython :\n\nOuvrez un terminal ou une invite de commande.\nExécutez la commande suivante pour cloner le répertoire Git de CPython :\ngit clone https://github.com/python/cpython.git\nCette commande télécharge le code source de Python dans un dossier cpython sur votre machine.\nVous pouvez choisir une branche spécifique si vous le souhaitez, mais la branche par défaut vous donnera accès à la dernière version de développement.\n\n\n\n\nPartie 2 : Configuration du Build\nCette partie implique de configurer le code source pour la compilation.\n\nNavigation dans le Dossier :\n\nAccédez au dossier cloné en utilisant la commande cd cpython.\n\nConfiguration du Build :\n\nDans le dossier cpython, exécutez la commande ./configure.\nCette étape vérifie les outils et bibliothèques disponibles sur votre système. Elle configure le processus de build pour qu’il soit adapté à votre environnement spécifique.\nLa commande ./configure peut être personnalisée avec diverses options, telles que l’activation ou la désactivation de certaines fonctionnalités de Python.\n\n\n\n\nPartie 3 : Compilation de Python\nLa compilation est le processus de transformation du code source en un exécutable.\nLancement de la Compilation : - Dans le même dossier, exécutez la commande make. - Cette commande compile le code source de Python. Selon la puissance de votre machine, cela peut prendre un certain temps.\n\n\nPartie 4 : Installation de Python\nAprès avoir compilé le code source, l’étape suivante est d’installer Python sur votre système.\n\nInstallation :\n\nExécutez make install dans le terminal. Cette commande copiera les fichiers exécutables et les bibliothèques dans les répertoires appropriés sur votre système.\nSi vous ne souhaitez pas écraser la version Python existante, vous pouvez utiliser make altinstall à la place.\n\nVérification de l’Installation :\n\nUne fois l’installation terminée, vérifiez que Python est correctement installé en exécutant python --version ou python3 --version dans votre terminal. Vous devriez voir la version que vous venez de compiler.\n\n\n\n\nPartie 5 : Personnalisation et Observations pendant la Compilation\nLors de la compilation de Python, plusieurs aspects peuvent être personnalisés pour répondre à des besoins spécifiques ou optimiser le build.\n\nVariables d’Environnement et Options de Compilation :\n\nCC : Vous pouvez définir la variable d’environnement CC pour spécifier le compilateur à utiliser. Par exemple, export CC=gcc utilise GCC.\nFlags d’Optimisation : Les flags comme -O2 ou -O3 peuvent être ajoutés pour optimiser le build. Ces flags peuvent être définis en modifiant la variable CFLAGS.\nExemple : export CFLAGS=\"-O3\" pour une optimisation de niveau 3.\n\nModification du Makefile :\n\nLe Makefile généré par ./configure peut être modifié pour un contrôle plus fin sur le processus de build.\nVous pouvez ouvrir le Makefile dans un éditeur de texte et examiner les différents targets de build, les variables et les options configurées.\n\nObserver le Processus de Compilation :\n\nPendant la compilation avec make, observez les sorties dans le terminal. Elles fournissent des informations sur les fichiers en cours de compilation, les avertissements, et les erreurs éventuelles.\nLes messages d’erreur, en particulier, peuvent vous aider à identifier des problèmes spécifiques liés aux dépendances ou à la configuration de votre système.\n\n\n\n\nConseils Supplémentaires et Ressources pour la Compilation de Python\nAprès avoir compilé et installé votre version personnalisée de Python, voici quelques conseils et ressources supplémentaires pour approfondir vos connaissances et compétences en matière de compilation.\n\nExploration Approfondie du Makefile :\n\nPrenez le temps d’étudier le Makefile généré par ./configure. Il contient des informations précieuses sur les processus de build et les targets.\nExplorer le Makefile vous aidera à comprendre comment les différentes parties de Python sont compilées et liées ensemble.\n\nPersonnalisation Avancée :\n\nEn plus des flags d’optimisation et du choix du compilateur, envisagez d’explorer d’autres options de configuration. Par exemple, vous pouvez activer ou désactiver des modules spécifiques de Python lors de la compilation.\nLes options de configuration peuvent être explorées en exécutant ./configure --help.\n\nGestion des Dépendances :\n\nAssurez-vous que toutes les dépendances nécessaires sont installées sur votre système. Certaines fonctionnalités de Python peuvent nécessiter des bibliothèques externes.\nLes erreurs lors de la compilation sont souvent dues à l’absence de certaines bibliothèques de développement.\n\nRessources et Documentation :\n\nLa documentation officielle de Python est une ressource précieuse pour comprendre les différents aspects de la compilation de Python.\nDes forums et des communautés en ligne, comme Stack Overflow et les groupes Python, peuvent être des lieux d’échange d’informations et de conseils. #### Conclusion\n\n\nCompiler Python depuis la source offre non seulement une compréhension approfondie du fonctionnement interne de Python, mais permet également une personnalisation avancée du build. Cela peut être particulièrement utile pour les développeurs souhaitant contribuer au code source de Python ou nécessitant des versions spécifiques pour leurs projets.\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Travaux Pratiques",
      "TP - Construire son python depuis la source"
    ]
  },
  {
    "objectID": "content/Cours_1/IDEs/VsCode.html",
    "href": "content/Cours_1/IDEs/VsCode.html",
    "title": "VsCode - L’IDE Flexible et Polyvalent",
    "section": "",
    "text": "Présentation Générale de Visual Studio Code (VS Code)\nVisual Studio Code, communément appelé VS Code, est un IDE largement adopté par la communauté des développeurs Python. Sa réputation repose sur sa légèreté, sa flexibilité et ses capacités de personnalisation. Examinons en détail les caractéristiques qui font de VS Code un choix privilégié pour le développement Python.\n\n\n\n1. Caractéristiques Principales de VS Code\n\nÉditeur Polyvalent :\n\nVS Code est un éditeur de code source léger et performant, supportant Python ainsi que de nombreux autres langages de programmation.\nSon interface utilisateur épurée et réactive convient aussi bien aux petits scripts qu’aux grands projets.\n\nExtensions et Personnalisation :\n\nLa force de VS Code réside dans sa capacité à intégrer une multitude d’extensions, dont une extension Python officielle qui enrichit l’IDE de fonctionnalités dédiées à Python.\nLes utilisateurs peuvent personnaliser presque tous les aspects de l’IDE, des thèmes visuels aux fonctionnalités spécifiques grâce à des extensions.\n\nIntégration Git :\n\nVS Code intègre nativement le support de Git, offrant un contrôle de version efficace et directement accessible depuis l’interface de l’IDE.\n\n\n\n\n2. Débogage et Tests\n\nFonctionnalités Avancées de Débogage :\n\nVS Code propose des outils de débogage sophistiqués pour Python, permettant l’inspection de code, le suivi des variables, et l’exécution pas à pas.\nCes outils de débogage facilitent la résolution des erreurs et des problèmes complexes dans le code.\n\nSupport des Frameworks de Test :\n\nL’IDE prend en charge divers frameworks de test unitaire pour Python, permettant de créer, d’exécuter et de visualiser les résultats des tests directement dans l’interface.\n\n\n\n\n3. Gestion des Environnements Virtuels\n\nVS Code détecte automatiquement les environnements virtuels Python, les rendant facilement accessibles pour la gestion des dépendances et l’exécution du code.\n\n\n\n4. Personnalisation et Productivité\n\nLes utilisateurs peuvent personnaliser VS Code selon leurs préférences, avec des thèmes, des raccourcis clavier, et une multitude de réglages pour optimiser l’expérience de développement.\nDes fonctionnalités comme l’auto-complétion, la navigation intelligente dans le code et les snippets personnalisés augmentent la productivité des développeurs.\n\n\n\n5. Support pour la Data Science et le Développement Web\n\nData Science :\n\nVS Code intègre des outils pour la data science, notamment le support pour Jupyter Notebooks, offrant une expérience de travail interactive avec les données.\n\nDéveloppement Web :\n\nL’IDE fournit un support exhaustif pour les technologies web, facilitant le développement tant sur le front-end que le back-end.\n\n\n\n\n\n6. Communauté Active et Mises à Jour Constantes\n\nAvec une communauté dynamique et des mises à jour régulières, VS Code continue d’évoluer, ajoutant continuellement de nouvelles fonctionnalités et améliorations.\n\n\n\n7. Github Copilot\nEnfin, VS Code est le premier IDE à intégrer Github Copilot, un outil d’IA qui génère du code à partir soit de commande direct comme dans ChatGPT, soit en proposant une continuation direct du code en cours d’écriture. Pas toujours pertinent, cet outil peut cependant permettre un gain de temps énorme pour des actions répétitives ou pour identifier des erreurs de syntaxe.\nGithub Copilot necessite un abonnement payant, mais github offre au sein de github student pack un accès gratuit à cet outil.\n\n\nConclusion\nVisual Studio Code se distingue comme un environnement de développement hautement personnalisable et polyvalent, adapté à une vaste gamme de projets Python. Que ce soit pour la data science, le développement web, ou des applications générales, VS Code offre un ensemble d’outils et de fonctionnalités qui répondent aux besoins des développeurs de tous niveaux.\n\n\n\n\n Back to top",
    "crumbs": [
      "Quelques IDEs en Python",
      "VsCode - L'IDE Flexible et Polyvalent"
    ]
  },
  {
    "objectID": "content/Cours_1/4-Path.html",
    "href": "content/Cours_1/4-Path.html",
    "title": "Le PATH",
    "section": "",
    "text": "PATH est une variable d’environnement utilisée par le système d’exploitation pour localiser les fichiers exécutables requis pour lancer des programmes ou des commandes.\nElle contient une liste de répertoires séparés par un délimiteur spécifique au système d’exploitation : point-virgule (;) pour Windows et deux-points (:) pour Unix/Linux.\n\n\n\n\n\nLorsqu’une commande est saisie dans le terminal ou l’invite de commande, le système parcourt les répertoires listés dans PATH à la recherche d’un fichier exécutable correspondant au nom de la commande.\nSi le fichier est trouvé, il est exécuté. Sinon, un message d’erreur indique que la commande est introuvable.\n\n\n\n\n\n\n\nAjouter de nouveaux chemins à PATH est souvent nécessaire après l’installation de nouveaux logiciels ou scripts pour permettre leur exécution depuis n’importe quel répertoire.\nLa modification de PATH facilite l’accès à ces programmes sans avoir besoin de naviguer vers leur répertoire d’installation ou de spécifier leur chemin complet.\n\n\n\n\n\nSous Windows, PATH peut être modifié via les Propriétés Système ou l’Éditeur de Registre.\nSous Unix/Linux et MacOS, PATH est généralement modifié en éditant les fichiers de configuration de l’interpréteur de commandes, tels que .bashrc, .bash_profile, ou .zshrc.\n\n\n\n\n\n\n\n\nPATH permet de lancer des applications et des scripts facilement depuis n’importe quel répertoire dans le terminal, en supprimant le besoin de saisir des chemins complets.\n\n\n\n\n\nUne gestion efficace de PATH aide à maintenir une organisation claire des programmes et scripts fréquemment utilisés, en centralisant leur accès.\n\n\n\n\nRisques de Sécurité - Ajouter des répertoires non sécurisés ou de sources inconnues à PATH peut exposer le système à des risques de sécurité. Des exécutables malveillants dans ces répertoires pourraient être lancés involontairement.\nBonnes Pratiques - Il est recommandé de n’ajouter que des répertoires de confiance à PATH et de vérifier régulièrement son contenu pour éviter des risques de sécurité.\n\n\n\n\n\n\n\nAccès à PATH : Accessible via Panneau de configuration &gt; Système &gt; Paramètres système avancés &gt; Variables d’environnement.\nModification : Ajouter ou modifier les valeurs dans la variable Path sous Variables d’environnement.\nApplication des Changements : Les modifications prennent effet après redémarrage de l’invite de commande ou redémarrage du système.\n\n\n\n\n\nFichiers de Configuration : .bashrc, .bash_profile, ou .profile dans le répertoire personnel de l’utilisateur.\nModification : Ajouter export PATH=\"/nouveau/chemin:$PATH\" au fichier correspondant.\nApplication des Changements : Exécuter source ~/.bashrc ou ouvrir un nouveau terminal.\n\n\n\n\n\nSimilaire à Linux, MacOS utilise .bash_profile ou .zshrc pour les utilisateurs de zsh.\nLa modification et l’application des changements sont identiques à celles de Linux.\n\n\n\n\nLa configuration de la variable PATH pour une version de Python compilée manuellement est un processus essentiel pour s’assurer que le système utilise la bonne version de Python. Voici des instructions spécifiques pour Windows, Linux et MacOS.\n\n\n\nLocalisation de l’Exécutable Python:\n\nTrouvez le chemin où Python a été compilé et installé, par exemple, C:\\Users\\VotreNom\\mon_python.\n\nModification de PATH:\n\nOuvrez les Propriétés Système &gt; Variables d’environnement.\nSous “Variables système”, trouvez et sélectionnez la variable Path, puis cliquez sur Modifier.\nAjoutez le chemin vers le dossier contenant l’exécutable Python, par exemple, C:\\Users\\VotreNom\\mon_python.\nCliquez sur OK pour fermer les fenêtres.\n\nApplication des Changements:\n\nOuvrez une nouvelle invite de commande pour que les changements prennent effet.\nTapez python --version pour vérifier que la bonne version de Python est utilisée.\n\n\n\n\n\n\nLocalisation de l’Exécutable Python:\n\nSupposons que Python soit installé dans ~/mon_python/.\n\nModification de PATH:\n\nOuvrez le fichier .bashrc ou .bash_profile dans votre répertoire personnel avec un éditeur de texte.\nAjoutez la ligne export PATH=\"~/mon_python/bin:$PATH\" à la fin du fichier.\nEnregistrez et fermez le fichier.\n\nApplication des Changements:\n\nExécutez source ~/.bashrc ou redémarrez le terminal.\nVérifiez avec python --version que la version correcte de Python est utilisée.\n\n\n\n\n\n\nLocalisation de l’Exécutable Python:\n\nComme pour Linux, identifiez où Python a été installé, par exemple, ~/mon_python/.\n\nModification de PATH:\n\nSi vous utilisez Bash, modifiez .bash_profile ; si vous utilisez Zsh, modifiez .zshrc.\nAjoutez export PATH=\"~/mon_python/bin:$PATH\" à la fin du fichier correspondant.\nSauvegardez et fermez l’éditeur de texte.\n\nApplication des Changements:\n\nExécutez source ~/.bash_profile ou source ~/.zshrc, selon l’interpréteur de commandes que vous utilisez.\nUtilisez python --version pour confirmer que le système utilise la version Python compilée manuellement.\n\n\n\n\n\n\n\nOrdre dans PATH : L’ordre des chemins dans PATH est crucial. Le système recherche les exécutables dans l’ordre où les chemins apparaissent. Si vous voulez que votre version compilée de Python soit prioritaire, assurez-vous qu’elle apparaisse en premier dans la liste.\nSécurité : Soyez prudent lors de la modification de PATH, surtout sous Unix/Linux et MacOS, car une mauvaise configuration peut affecter le fonctionnement du système.\nVersion par Défaut : Si plusieurs versions de Python sont installées, la version exécutée par défaut sera celle trouvée en premier dans PATH.\n\nEn suivant ces étapes, vous pouvez configurer votre système pour utiliser une version spécifique de Python, vous offrant ainsi une plus grande flexibilité et contrôle sur votre environnement de développement.",
    "crumbs": [
      "Le PATH"
    ]
  },
  {
    "objectID": "content/Cours_1/4-Path.html#section-4.1---définition-de-path",
    "href": "content/Cours_1/4-Path.html#section-4.1---définition-de-path",
    "title": "Le PATH",
    "section": "",
    "text": "PATH est une variable d’environnement utilisée par le système d’exploitation pour localiser les fichiers exécutables requis pour lancer des programmes ou des commandes.\nElle contient une liste de répertoires séparés par un délimiteur spécifique au système d’exploitation : point-virgule (;) pour Windows et deux-points (:) pour Unix/Linux.",
    "crumbs": [
      "Le PATH"
    ]
  },
  {
    "objectID": "content/Cours_1/4-Path.html#section-4.2---fonctionnement-de-path",
    "href": "content/Cours_1/4-Path.html#section-4.2---fonctionnement-de-path",
    "title": "Le PATH",
    "section": "",
    "text": "Lorsqu’une commande est saisie dans le terminal ou l’invite de commande, le système parcourt les répertoires listés dans PATH à la recherche d’un fichier exécutable correspondant au nom de la commande.\nSi le fichier est trouvé, il est exécuté. Sinon, un message d’erreur indique que la commande est introuvable.",
    "crumbs": [
      "Le PATH"
    ]
  },
  {
    "objectID": "content/Cours_1/4-Path.html#section-4.3---modification-de-path",
    "href": "content/Cours_1/4-Path.html#section-4.3---modification-de-path",
    "title": "Le PATH",
    "section": "",
    "text": "Ajouter de nouveaux chemins à PATH est souvent nécessaire après l’installation de nouveaux logiciels ou scripts pour permettre leur exécution depuis n’importe quel répertoire.\nLa modification de PATH facilite l’accès à ces programmes sans avoir besoin de naviguer vers leur répertoire d’installation ou de spécifier leur chemin complet.\n\n\n\n\n\nSous Windows, PATH peut être modifié via les Propriétés Système ou l’Éditeur de Registre.\nSous Unix/Linux et MacOS, PATH est généralement modifié en éditant les fichiers de configuration de l’interpréteur de commandes, tels que .bashrc, .bash_profile, ou .zshrc.",
    "crumbs": [
      "Le PATH"
    ]
  },
  {
    "objectID": "content/Cours_1/4-Path.html#section-4.4---importance-et-utilisation-de-path",
    "href": "content/Cours_1/4-Path.html#section-4.4---importance-et-utilisation-de-path",
    "title": "Le PATH",
    "section": "",
    "text": "PATH permet de lancer des applications et des scripts facilement depuis n’importe quel répertoire dans le terminal, en supprimant le besoin de saisir des chemins complets.\n\n\n\n\n\nUne gestion efficace de PATH aide à maintenir une organisation claire des programmes et scripts fréquemment utilisés, en centralisant leur accès.\n\n\n\n\nRisques de Sécurité - Ajouter des répertoires non sécurisés ou de sources inconnues à PATH peut exposer le système à des risques de sécurité. Des exécutables malveillants dans ces répertoires pourraient être lancés involontairement.\nBonnes Pratiques - Il est recommandé de n’ajouter que des répertoires de confiance à PATH et de vérifier régulièrement son contenu pour éviter des risques de sécurité.",
    "crumbs": [
      "Le PATH"
    ]
  },
  {
    "objectID": "content/Cours_1/4-Path.html#section-4.5---configuration-de-path-pour-windows-linux-et-macos",
    "href": "content/Cours_1/4-Path.html#section-4.5---configuration-de-path-pour-windows-linux-et-macos",
    "title": "Le PATH",
    "section": "",
    "text": "Accès à PATH : Accessible via Panneau de configuration &gt; Système &gt; Paramètres système avancés &gt; Variables d’environnement.\nModification : Ajouter ou modifier les valeurs dans la variable Path sous Variables d’environnement.\nApplication des Changements : Les modifications prennent effet après redémarrage de l’invite de commande ou redémarrage du système.\n\n\n\n\n\nFichiers de Configuration : .bashrc, .bash_profile, ou .profile dans le répertoire personnel de l’utilisateur.\nModification : Ajouter export PATH=\"/nouveau/chemin:$PATH\" au fichier correspondant.\nApplication des Changements : Exécuter source ~/.bashrc ou ouvrir un nouveau terminal.\n\n\n\n\n\nSimilaire à Linux, MacOS utilise .bash_profile ou .zshrc pour les utilisateurs de zsh.\nLa modification et l’application des changements sont identiques à celles de Linux.\n\n\n\n\nLa configuration de la variable PATH pour une version de Python compilée manuellement est un processus essentiel pour s’assurer que le système utilise la bonne version de Python. Voici des instructions spécifiques pour Windows, Linux et MacOS.\n\n\n\nLocalisation de l’Exécutable Python:\n\nTrouvez le chemin où Python a été compilé et installé, par exemple, C:\\Users\\VotreNom\\mon_python.\n\nModification de PATH:\n\nOuvrez les Propriétés Système &gt; Variables d’environnement.\nSous “Variables système”, trouvez et sélectionnez la variable Path, puis cliquez sur Modifier.\nAjoutez le chemin vers le dossier contenant l’exécutable Python, par exemple, C:\\Users\\VotreNom\\mon_python.\nCliquez sur OK pour fermer les fenêtres.\n\nApplication des Changements:\n\nOuvrez une nouvelle invite de commande pour que les changements prennent effet.\nTapez python --version pour vérifier que la bonne version de Python est utilisée.\n\n\n\n\n\n\nLocalisation de l’Exécutable Python:\n\nSupposons que Python soit installé dans ~/mon_python/.\n\nModification de PATH:\n\nOuvrez le fichier .bashrc ou .bash_profile dans votre répertoire personnel avec un éditeur de texte.\nAjoutez la ligne export PATH=\"~/mon_python/bin:$PATH\" à la fin du fichier.\nEnregistrez et fermez le fichier.\n\nApplication des Changements:\n\nExécutez source ~/.bashrc ou redémarrez le terminal.\nVérifiez avec python --version que la version correcte de Python est utilisée.\n\n\n\n\n\n\nLocalisation de l’Exécutable Python:\n\nComme pour Linux, identifiez où Python a été installé, par exemple, ~/mon_python/.\n\nModification de PATH:\n\nSi vous utilisez Bash, modifiez .bash_profile ; si vous utilisez Zsh, modifiez .zshrc.\nAjoutez export PATH=\"~/mon_python/bin:$PATH\" à la fin du fichier correspondant.\nSauvegardez et fermez l’éditeur de texte.\n\nApplication des Changements:\n\nExécutez source ~/.bash_profile ou source ~/.zshrc, selon l’interpréteur de commandes que vous utilisez.\nUtilisez python --version pour confirmer que le système utilise la version Python compilée manuellement.\n\n\n\n\n\n\n\nOrdre dans PATH : L’ordre des chemins dans PATH est crucial. Le système recherche les exécutables dans l’ordre où les chemins apparaissent. Si vous voulez que votre version compilée de Python soit prioritaire, assurez-vous qu’elle apparaisse en premier dans la liste.\nSécurité : Soyez prudent lors de la modification de PATH, surtout sous Unix/Linux et MacOS, car une mauvaise configuration peut affecter le fonctionnement du système.\nVersion par Défaut : Si plusieurs versions de Python sont installées, la version exécutée par défaut sera celle trouvée en premier dans PATH.\n\nEn suivant ces étapes, vous pouvez configurer votre système pour utiliser une version spécifique de Python, vous offrant ainsi une plus grande flexibilité et contrôle sur votre environnement de développement.",
    "crumbs": [
      "Le PATH"
    ]
  },
  {
    "objectID": "content/Cours_1/2-Python_Execution.html",
    "href": "content/Cours_1/2-Python_Execution.html",
    "title": "Exécution d’un Programme Python",
    "section": "",
    "text": "L’apprentissage de la programmation en Python ne nécessite pas de connaissances préalables en informatique, mais comprendre comment un programme est exécuté est essentiel. Cette compréhension aide à gérer les packages, à résoudre les problèmes de version et à collaborer efficacement.\nUn programme est une série d’instructions écrites dans un langage compréhensible par un ordinateur, connu sous le nom de langage machine, composé de séquences binaires (0 et 1). Pour traduire un langage de haut niveau en langage machine, un processus de compilation est nécessaire.\n\n\n\nLa compilation est le processus qui consiste à traduire le code source en code machine, mais cela ne fait pas “que” cela, il va aussi vérifier que le code source est correcte. C’est à dire qu’il va vérifier que le code source est bien écrit dans le language que l’on a choisi. C’est ce que l’on appelle la syntaxe. Il va aussi vérifier que le code source est logique. C’est à dire qu’il va vérifier que le code source est bien écrit dans le bon ordre. C’est ce que l’on appelle la sémantique. Si le code source n’est pas correcte, le compilateur va nous renvoyer une erreur. C’est ce que l’on appelle une erreur de compilation. C’est une erreur qui se produit avant l’exécution du programme.\nMais la compilation va également permettre d’optimiser le code source. C’est à dire qu’il va le rendre plus rapide à l’exécution. Durant cette phase le compilateur va, en fonction des options choisi par le développeur, optimiser le code source, en supprimant par exemple les lignes de code qui ne sont pas utilisées, en supprimant des boucles ou recursion, en réduisant le nombre de variables, en réduisant le nombre d’instructions, en réduisant le nombre de sauts, en réduisant le nombre d’opérations, en réduisant le nombre de tests, en réduisant le nombre de fonctions, en réduisant le nombre de paramètres, en réduisant le nombre de variables locales, …\nC’est optimisation prennent cependant du temps, et ne sont pas toutes sans risques et les erreurs de compilations peuvent être nombreuses sur des programmes complexes, et la compilations peut demander un temps considérable à chaque fois que l’on apporte une modification.\nMais en Python, il n’y a pas de compilation ! Magie ?\n\n\n\nPython, comme tout les programmes qui s’execute sur l’ordinateur, provient bien d’un code qui a été compilé à un moment. La différence vient du fait que c’est l’interpreteur qui a été compilé, et qui est un programme va être capable de lire le code python et de le transformé au fur et à mesure en code machine. C’est ce que l’on appelle l’interprétation. C’est un processus qui se fait en deux étapes.\nLa première étape est l’analyse lexicale. C’est à dire que l’interpreteur va lire le code source et le découper en morceaux. C’est ce que l’on appelle les tokens. Il va ensuite les analyser pour vérifier que le code source est correcte. C’est à dire qu’il va vérifier que le code source est bien écrit dans le language que l’on a choisi. C’est ce que l’on appelle la syntaxe. Il va aussi vérifier que le code source est logique. C’est à dire qu’il va vérifier que le code source est bien écrit dans le bon ordre. C’est ce que l’on appelle la sémantique. Si le code source n’est pas correcte, l’interpreteur va nous renvoyer une erreur. C’est ce que l’on appelle une erreur d’analyse lexicale. C’est une erreur qui se produit avant l’exécution du programme.\nEn Python, l’interpreteur va alors produire un Bytecode. C’est un code intermédiaire qui est plus proche du language machine que le code source, mais qui n’est pas encore du language machine. C’est ce que l’on appelle parfois la compilation, mais cette étape est presque instantanée. Toutefois l’interpreteur stocke quand même ce bytecode pour ne pas le recalculer à chaque fois, vous le verrez dans le dossier pycache de vos projets python, qui sera crée automatiquement dès que vous lancerez un code.\nL’interpréteur exécute ce bytecode, ce qui entraîne l’exécution des instructions écrites dans le fichier source. Ce processus diffère de celui des langages compilés comme C ou Java, où le code source est d’abord entièrement transformé en code machine avant l’exécution. En Python, la compilation en bytecode et l’exécution sont des étapes dynamiques, ce qui confère au langage sa flexibilité et sa facilité de débogage, mais aussi impacte sa vitesse d’exécution.\n\n\n\nL’exécution d’un programme Python implique l’utilisation d’un binaire compilé de l’interpréteur Python. Ce processus est fondamental pour comprendre comment Python fonctionne sous le capot.\n\nLe Binaire Compilé: Lorsqu’on installe Python, on télécharge en fait un binaire compilé de l’interpréteur Python, ou selon les cas l’ensemble des morceaux necessaire pour que notre machine le construise. Ce binaire est spécifique à chaque système d’exploitation et architecture matérielle. Par exemple, les binaires pour Windows diffèrent de ceux pour Linux ou MacOS, comme les binaires des Mac M1 sont très différents de ceux des Mac avec les anciens processeurs Intel.\nAvantages du Binaire Compilé: Le fait d’avoir un binaire compilé spécifique à chaque plateforme permet à Python d’être portable et facile à déployer. Les développeurs peuvent écrire un script Python et s’attendre à ce qu’il fonctionne de la même manière sur différentes machines, à condition que l’interpréteur Python approprié soit installé.\n\nCe mécanisme d’interprétation via un binaire compilé est une caractéristique clé de Python, contribuant à sa polyvalence et sa facilité d’utilisation dans divers environnements de développement.\nMais donc, qui produit se binaire ? Y’en a-t-il une seule implémentation ? Puis-je le compiler moi même ?",
    "crumbs": [
      "Exécution d'un Programme Python"
    ]
  },
  {
    "objectID": "content/Cours_1/2-Python_Execution.html#section-2.1---un-programme---comment-ca-marche",
    "href": "content/Cours_1/2-Python_Execution.html#section-2.1---un-programme---comment-ca-marche",
    "title": "Exécution d’un Programme Python",
    "section": "",
    "text": "L’apprentissage de la programmation en Python ne nécessite pas de connaissances préalables en informatique, mais comprendre comment un programme est exécuté est essentiel. Cette compréhension aide à gérer les packages, à résoudre les problèmes de version et à collaborer efficacement.\nUn programme est une série d’instructions écrites dans un langage compréhensible par un ordinateur, connu sous le nom de langage machine, composé de séquences binaires (0 et 1). Pour traduire un langage de haut niveau en langage machine, un processus de compilation est nécessaire.",
    "crumbs": [
      "Exécution d'un Programme Python"
    ]
  },
  {
    "objectID": "content/Cours_1/2-Python_Execution.html#section-2.2---la-compilation",
    "href": "content/Cours_1/2-Python_Execution.html#section-2.2---la-compilation",
    "title": "Exécution d’un Programme Python",
    "section": "",
    "text": "La compilation est le processus qui consiste à traduire le code source en code machine, mais cela ne fait pas “que” cela, il va aussi vérifier que le code source est correcte. C’est à dire qu’il va vérifier que le code source est bien écrit dans le language que l’on a choisi. C’est ce que l’on appelle la syntaxe. Il va aussi vérifier que le code source est logique. C’est à dire qu’il va vérifier que le code source est bien écrit dans le bon ordre. C’est ce que l’on appelle la sémantique. Si le code source n’est pas correcte, le compilateur va nous renvoyer une erreur. C’est ce que l’on appelle une erreur de compilation. C’est une erreur qui se produit avant l’exécution du programme.\nMais la compilation va également permettre d’optimiser le code source. C’est à dire qu’il va le rendre plus rapide à l’exécution. Durant cette phase le compilateur va, en fonction des options choisi par le développeur, optimiser le code source, en supprimant par exemple les lignes de code qui ne sont pas utilisées, en supprimant des boucles ou recursion, en réduisant le nombre de variables, en réduisant le nombre d’instructions, en réduisant le nombre de sauts, en réduisant le nombre d’opérations, en réduisant le nombre de tests, en réduisant le nombre de fonctions, en réduisant le nombre de paramètres, en réduisant le nombre de variables locales, …\nC’est optimisation prennent cependant du temps, et ne sont pas toutes sans risques et les erreurs de compilations peuvent être nombreuses sur des programmes complexes, et la compilations peut demander un temps considérable à chaque fois que l’on apporte une modification.\nMais en Python, il n’y a pas de compilation ! Magie ?",
    "crumbs": [
      "Exécution d'un Programme Python"
    ]
  },
  {
    "objectID": "content/Cours_1/2-Python_Execution.html#section-2.3---linterprétation",
    "href": "content/Cours_1/2-Python_Execution.html#section-2.3---linterprétation",
    "title": "Exécution d’un Programme Python",
    "section": "",
    "text": "Python, comme tout les programmes qui s’execute sur l’ordinateur, provient bien d’un code qui a été compilé à un moment. La différence vient du fait que c’est l’interpreteur qui a été compilé, et qui est un programme va être capable de lire le code python et de le transformé au fur et à mesure en code machine. C’est ce que l’on appelle l’interprétation. C’est un processus qui se fait en deux étapes.\nLa première étape est l’analyse lexicale. C’est à dire que l’interpreteur va lire le code source et le découper en morceaux. C’est ce que l’on appelle les tokens. Il va ensuite les analyser pour vérifier que le code source est correcte. C’est à dire qu’il va vérifier que le code source est bien écrit dans le language que l’on a choisi. C’est ce que l’on appelle la syntaxe. Il va aussi vérifier que le code source est logique. C’est à dire qu’il va vérifier que le code source est bien écrit dans le bon ordre. C’est ce que l’on appelle la sémantique. Si le code source n’est pas correcte, l’interpreteur va nous renvoyer une erreur. C’est ce que l’on appelle une erreur d’analyse lexicale. C’est une erreur qui se produit avant l’exécution du programme.\nEn Python, l’interpreteur va alors produire un Bytecode. C’est un code intermédiaire qui est plus proche du language machine que le code source, mais qui n’est pas encore du language machine. C’est ce que l’on appelle parfois la compilation, mais cette étape est presque instantanée. Toutefois l’interpreteur stocke quand même ce bytecode pour ne pas le recalculer à chaque fois, vous le verrez dans le dossier pycache de vos projets python, qui sera crée automatiquement dès que vous lancerez un code.\nL’interpréteur exécute ce bytecode, ce qui entraîne l’exécution des instructions écrites dans le fichier source. Ce processus diffère de celui des langages compilés comme C ou Java, où le code source est d’abord entièrement transformé en code machine avant l’exécution. En Python, la compilation en bytecode et l’exécution sont des étapes dynamiques, ce qui confère au langage sa flexibilité et sa facilité de débogage, mais aussi impacte sa vitesse d’exécution.",
    "crumbs": [
      "Exécution d'un Programme Python"
    ]
  },
  {
    "objectID": "content/Cours_1/2-Python_Execution.html#section-2.4---binaire-compilé-et-interprétation-du-code-python",
    "href": "content/Cours_1/2-Python_Execution.html#section-2.4---binaire-compilé-et-interprétation-du-code-python",
    "title": "Exécution d’un Programme Python",
    "section": "",
    "text": "L’exécution d’un programme Python implique l’utilisation d’un binaire compilé de l’interpréteur Python. Ce processus est fondamental pour comprendre comment Python fonctionne sous le capot.\n\nLe Binaire Compilé: Lorsqu’on installe Python, on télécharge en fait un binaire compilé de l’interpréteur Python, ou selon les cas l’ensemble des morceaux necessaire pour que notre machine le construise. Ce binaire est spécifique à chaque système d’exploitation et architecture matérielle. Par exemple, les binaires pour Windows diffèrent de ceux pour Linux ou MacOS, comme les binaires des Mac M1 sont très différents de ceux des Mac avec les anciens processeurs Intel.\nAvantages du Binaire Compilé: Le fait d’avoir un binaire compilé spécifique à chaque plateforme permet à Python d’être portable et facile à déployer. Les développeurs peuvent écrire un script Python et s’attendre à ce qu’il fonctionne de la même manière sur différentes machines, à condition que l’interpréteur Python approprié soit installé.\n\nCe mécanisme d’interprétation via un binaire compilé est une caractéristique clé de Python, contribuant à sa polyvalence et sa facilité d’utilisation dans divers environnements de développement.\nMais donc, qui produit se binaire ? Y’en a-t-il une seule implémentation ? Puis-je le compiler moi même ?",
    "crumbs": [
      "Exécution d'un Programme Python"
    ]
  },
  {
    "objectID": "content/Cours_1/3-ManyPythons.html",
    "href": "content/Cours_1/3-ManyPythons.html",
    "title": "Versions et Compilation de Python",
    "section": "",
    "text": "Python, en tant que langage, existe sous différentes implémentations, chacune ayant des caractéristiques uniques adaptées à des besoins spécifiques. Voici quelques-unes des plus connues :\n\n\n\nDescription: C’est l’implémentation standard et la plus répandue de Python, écrite en C. CPython est souvent le choix par défaut pour le développement général en Python, bien qu’il soit limité par le Global Interpreter Lock (GIL).\nUtilisation: Idéal pour des applications générales, CPython est souvent utilisé pour le développement de logiciels et l’écriture de scripts.\nCaractéristiques: Il offre un bon équilibre entre performance et facilité d’utilisation et possède le plus grand nombre de bibliothèques tierces disponibles. Mais, comme vu dans la partie 1, c’est aussi une version qui repose actuellement sur le GIL.\n\n\n\n\n\nDescription: Jython est conçu pour la machine virtuelle Java (JVM), permettant l’intégration avec des environnements Java. Contrairement à CPython, Jython n’est pas restreint par le GIL, ce qui le rend plus adapté pour des applications nécessitant du multithreading.\nUtilisation: Elle permet aux développeurs d’utiliser des bibliothèques Java dans leurs programmes Python et vice-versa.\nCaractéristiques: Jython est particulièrement utile pour les applications nécessitant l’intégration de Python avec des environnements Java existants.\n\n\n\n\n\nDescription: IronPython est conçu pour être compatible avec le Common Language Runtime (CLR) de Microsoft .NET.\nUtilisation: Cette implémentation permet d’utiliser des bibliothèques .NET dans des programmes Python et d’intégrer Python dans des applications .NET.\nCaractéristiques: IronPython est idéal pour les développeurs travaillant dans l’écosystème .NET et souhaitant utiliser Python.\n\n\n\n\n\nDescription: PyPy est une implémentation de Python axée sur la performance et l’efficacité.\nUtilisation: Utilisée principalement lorsque la vitesse d’exécution est critique.\nCaractéristiques: PyPy utilise la compilation JIT (Just-In-Time) pour accélérer l’exécution des programmes Python. Cela peut entraîner des performances nettement meilleures, en particulier pour les programmes lourds en calcul. Attention toutefois à ne pas confondre vitesse et précipitations, cette versions repose toutefois toujours sur le GIL.\n\nChaque implémentation a ses avantages et peut être choisie selon les exigences spécifiques d’un projet. CPython reste l’implémentation dominante, mais les autres offrent des alternatives précieuses pour divers cas d’utilisation.\n\n\n\n\nUne question vient évidemment, pourquoi si PyPy offre des améliorations significatives en termes de performance, alors ne remplace-t-il pas CPython ? Bien que grâce à son approche JIT (Just-In-Time), il y a plusieurs raisons pour lesquelles il ne remplace pas complètement CPython :\n\n\n\nCPython: Étant l’implémentation de référence, CPython jouit d’une excellente compatibilité avec les extensions écrites en C. Ces extensions sont largement utilisées dans l’écosystème Python pour améliorer les performances et pour l’interaction avec des systèmes de bas niveau.\nPyPy: PyPy a des difficultés à intégrer certaines extensions C, notamment celles qui sont étroitement liées aux détails internes de CPython. Cette limitation peut poser des problèmes de compatibilité avec des bibliothèques importantes.\n\n\n\n\n\nCPython: Fournit des performances stables et prévisibles sur une large gamme d’applications. Pour des tâches spécifiques, en particulier celles qui impliquent beaucoup d’appels à des bibliothèques C, CPython peut être plus rapide.\nPyPy: Excellente performance pour les programmes Python purs, mais peut être moins performant dans des scénarios mixtes (Python et C) ou pour des scripts courts où l’overhead de JIT n’est pas amorti.\n\n\n\n\n\nPyPy: En raison de sa nature JIT, PyPy peut consommer plus de mémoire que CPython, en particulier pour des programmes de longue durée où le compilateur JIT génère et stocke de nombreuses versions optimisées de morceaux de code.\n\n\n\n\n\nCPython: Bénéficie d’une adoption massive et d’un support étendu de la part de la communauté Python. La plupart des développements, des tutoriels, et des supports se concentrent sur CPython.\nPyPy: Bien que gagnant en popularité, PyPy ne jouit pas du même niveau de support communautaire, et certains développeurs peuvent être moins familiers avec ses particularités.\n\n\n\n\n\nPyPy: Idéal pour des applications à longue durée d’exécution et intensives en calcul, où les avantages de JIT peuvent être pleinement exploités.\nCPython: Mieux adapté pour des applications générales, des scripts de courte durée, et des cas où la compatibilité avec l’écosystème existant est cruciale.\n\nEn résumé, bien que PyPy soit une alternative puissante à CPython, surtout en termes de vitesse d’exécution pour certains types de programmes, il ne peut pas remplacer complètement CPython en raison de problèmes de compatibilité, de différences de performance dans certains scénarios, et de la prévalence de CPython dans la communauté Python.\n\n\n\n\nBien que ces versions n’offrent pas toujours les même possibilités, le language reste strictement le même. Ainsi, dans certains cas où le besoin de performance est plus important, le fait de simplement changé d’interpreteur peut si il n’y a pas de conflit permettre de gagner de très nombreuses heures d’optimisation!\n\n\n\nNous avons vu la théorie, mais dans la pratique, très peu de développeur ont recompiler leur binaire de python. Mais, où trouver le code ? Le compilateur ? Y-a-t-il un interet à compiler Python soit même, dans la vie de tout les jours du développeur NON, l’intérêt reste marginale, mais pour autant: - Il y a un interet pédagogique - cela permet de comprendre comment compiler depuis la source (le code brut), installer un binaire etc… Ainsi cela peut vous permettre d’ajouter par exemple sans droit administrateur des versions de python de votre choix, par exemple à l’université ! - Cela peut permettre d’améliorer la performance de votre intepreteur, celui-ci étant alors compilé spécficiquement pour votre PC, les compilateurs proposant par exemple l’utilisation de la PGO (Profile Guided Optimization), où l’interet est d’améliorer le premier binaire créer après l’avoir fait tourner sur la machine sur une charge de travail représentative pour le rendre plus performant. - Profiter des améliorations de Python qui n’ont pas encore été intégré - possiblements des mois avant qu’ils ne soient disponibles\n\n\n\nCompiler Python à partir du code source permet de comprendre le processus sous-jacent et d’adapter l’installation aux besoins spécifiques. Les étapes sont détaillé dans le TP Constuire son python",
    "crumbs": [
      "Versions et Compilation de Python"
    ]
  },
  {
    "objectID": "content/Cours_1/3-ManyPythons.html#section-3.1---les-différentes-saveurs-de-python-cpython-jython-ironpython-pypy",
    "href": "content/Cours_1/3-ManyPythons.html#section-3.1---les-différentes-saveurs-de-python-cpython-jython-ironpython-pypy",
    "title": "Versions et Compilation de Python",
    "section": "",
    "text": "Python, en tant que langage, existe sous différentes implémentations, chacune ayant des caractéristiques uniques adaptées à des besoins spécifiques. Voici quelques-unes des plus connues :\n\n\n\nDescription: C’est l’implémentation standard et la plus répandue de Python, écrite en C. CPython est souvent le choix par défaut pour le développement général en Python, bien qu’il soit limité par le Global Interpreter Lock (GIL).\nUtilisation: Idéal pour des applications générales, CPython est souvent utilisé pour le développement de logiciels et l’écriture de scripts.\nCaractéristiques: Il offre un bon équilibre entre performance et facilité d’utilisation et possède le plus grand nombre de bibliothèques tierces disponibles. Mais, comme vu dans la partie 1, c’est aussi une version qui repose actuellement sur le GIL.\n\n\n\n\n\nDescription: Jython est conçu pour la machine virtuelle Java (JVM), permettant l’intégration avec des environnements Java. Contrairement à CPython, Jython n’est pas restreint par le GIL, ce qui le rend plus adapté pour des applications nécessitant du multithreading.\nUtilisation: Elle permet aux développeurs d’utiliser des bibliothèques Java dans leurs programmes Python et vice-versa.\nCaractéristiques: Jython est particulièrement utile pour les applications nécessitant l’intégration de Python avec des environnements Java existants.\n\n\n\n\n\nDescription: IronPython est conçu pour être compatible avec le Common Language Runtime (CLR) de Microsoft .NET.\nUtilisation: Cette implémentation permet d’utiliser des bibliothèques .NET dans des programmes Python et d’intégrer Python dans des applications .NET.\nCaractéristiques: IronPython est idéal pour les développeurs travaillant dans l’écosystème .NET et souhaitant utiliser Python.\n\n\n\n\n\nDescription: PyPy est une implémentation de Python axée sur la performance et l’efficacité.\nUtilisation: Utilisée principalement lorsque la vitesse d’exécution est critique.\nCaractéristiques: PyPy utilise la compilation JIT (Just-In-Time) pour accélérer l’exécution des programmes Python. Cela peut entraîner des performances nettement meilleures, en particulier pour les programmes lourds en calcul. Attention toutefois à ne pas confondre vitesse et précipitations, cette versions repose toutefois toujours sur le GIL.\n\nChaque implémentation a ses avantages et peut être choisie selon les exigences spécifiques d’un projet. CPython reste l’implémentation dominante, mais les autres offrent des alternatives précieuses pour divers cas d’utilisation.",
    "crumbs": [
      "Versions et Compilation de Python"
    ]
  },
  {
    "objectID": "content/Cours_1/3-ManyPythons.html#section-3.2---pourquoi-pypy-ne-remplace-pas-complètement-cpython-différences-et-limitations",
    "href": "content/Cours_1/3-ManyPythons.html#section-3.2---pourquoi-pypy-ne-remplace-pas-complètement-cpython-différences-et-limitations",
    "title": "Versions et Compilation de Python",
    "section": "",
    "text": "Une question vient évidemment, pourquoi si PyPy offre des améliorations significatives en termes de performance, alors ne remplace-t-il pas CPython ? Bien que grâce à son approche JIT (Just-In-Time), il y a plusieurs raisons pour lesquelles il ne remplace pas complètement CPython :\n\n\n\nCPython: Étant l’implémentation de référence, CPython jouit d’une excellente compatibilité avec les extensions écrites en C. Ces extensions sont largement utilisées dans l’écosystème Python pour améliorer les performances et pour l’interaction avec des systèmes de bas niveau.\nPyPy: PyPy a des difficultés à intégrer certaines extensions C, notamment celles qui sont étroitement liées aux détails internes de CPython. Cette limitation peut poser des problèmes de compatibilité avec des bibliothèques importantes.\n\n\n\n\n\nCPython: Fournit des performances stables et prévisibles sur une large gamme d’applications. Pour des tâches spécifiques, en particulier celles qui impliquent beaucoup d’appels à des bibliothèques C, CPython peut être plus rapide.\nPyPy: Excellente performance pour les programmes Python purs, mais peut être moins performant dans des scénarios mixtes (Python et C) ou pour des scripts courts où l’overhead de JIT n’est pas amorti.\n\n\n\n\n\nPyPy: En raison de sa nature JIT, PyPy peut consommer plus de mémoire que CPython, en particulier pour des programmes de longue durée où le compilateur JIT génère et stocke de nombreuses versions optimisées de morceaux de code.\n\n\n\n\n\nCPython: Bénéficie d’une adoption massive et d’un support étendu de la part de la communauté Python. La plupart des développements, des tutoriels, et des supports se concentrent sur CPython.\nPyPy: Bien que gagnant en popularité, PyPy ne jouit pas du même niveau de support communautaire, et certains développeurs peuvent être moins familiers avec ses particularités.\n\n\n\n\n\nPyPy: Idéal pour des applications à longue durée d’exécution et intensives en calcul, où les avantages de JIT peuvent être pleinement exploités.\nCPython: Mieux adapté pour des applications générales, des scripts de courte durée, et des cas où la compatibilité avec l’écosystème existant est cruciale.\n\nEn résumé, bien que PyPy soit une alternative puissante à CPython, surtout en termes de vitesse d’exécution pour certains types de programmes, il ne peut pas remplacer complètement CPython en raison de problèmes de compatibilité, de différences de performance dans certains scénarios, et de la prévalence de CPython dans la communauté Python.",
    "crumbs": [
      "Versions et Compilation de Python"
    ]
  },
  {
    "objectID": "content/Cours_1/3-ManyPythons.html#section-3.3---et-pour-vous-comment-utiliser-cette-information",
    "href": "content/Cours_1/3-ManyPythons.html#section-3.3---et-pour-vous-comment-utiliser-cette-information",
    "title": "Versions et Compilation de Python",
    "section": "",
    "text": "Bien que ces versions n’offrent pas toujours les même possibilités, le language reste strictement le même. Ainsi, dans certains cas où le besoin de performance est plus important, le fait de simplement changé d’interpreteur peut si il n’y a pas de conflit permettre de gagner de très nombreuses heures d’optimisation!",
    "crumbs": [
      "Versions et Compilation de Python"
    ]
  },
  {
    "objectID": "content/Cours_1/3-ManyPythons.html#section-3.4---compiler-un-code-python-cloner-et-construire-cpython",
    "href": "content/Cours_1/3-ManyPythons.html#section-3.4---compiler-un-code-python-cloner-et-construire-cpython",
    "title": "Versions et Compilation de Python",
    "section": "",
    "text": "Nous avons vu la théorie, mais dans la pratique, très peu de développeur ont recompiler leur binaire de python. Mais, où trouver le code ? Le compilateur ? Y-a-t-il un interet à compiler Python soit même, dans la vie de tout les jours du développeur NON, l’intérêt reste marginale, mais pour autant: - Il y a un interet pédagogique - cela permet de comprendre comment compiler depuis la source (le code brut), installer un binaire etc… Ainsi cela peut vous permettre d’ajouter par exemple sans droit administrateur des versions de python de votre choix, par exemple à l’université ! - Cela peut permettre d’améliorer la performance de votre intepreteur, celui-ci étant alors compilé spécficiquement pour votre PC, les compilateurs proposant par exemple l’utilisation de la PGO (Profile Guided Optimization), où l’interet est d’améliorer le premier binaire créer après l’avoir fait tourner sur la machine sur une charge de travail représentative pour le rendre plus performant. - Profiter des améliorations de Python qui n’ont pas encore été intégré - possiblements des mois avant qu’ils ne soient disponibles",
    "crumbs": [
      "Versions et Compilation de Python"
    ]
  },
  {
    "objectID": "content/Cours_1/3-ManyPythons.html#section-3.5---les-étapes",
    "href": "content/Cours_1/3-ManyPythons.html#section-3.5---les-étapes",
    "title": "Versions et Compilation de Python",
    "section": "",
    "text": "Compiler Python à partir du code source permet de comprendre le processus sous-jacent et d’adapter l’installation aux besoins spécifiques. Les étapes sont détaillé dans le TP Constuire son python",
    "crumbs": [
      "Versions et Compilation de Python"
    ]
  },
  {
    "objectID": "content/Cours_5/index.html",
    "href": "content/Cours_5/index.html",
    "title": "Concepts avancés",
    "section": "",
    "text": "Les cours de cette partie sont:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nL’arbre Syntaxique Abstrait ou AST\n\n\n\n\n\n\nRemi Genet\n\n\n2025-01-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython Orienté Objet - Les Dunders\n\n\nComprendre la base des objets en python avec les dunder\n\n\n\nRemi Genet\n\n\n2025-01-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython Orienté Objet - les Design Patterns\n\n\nDécouvrir les design paterns, et connaitre les plus standards\n\n\n\nRemi Genet\n\n\n2025-01-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTP-5\n\n\n\n\n\n\nRemi Genet\n\n\n2025-01-29\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to top",
    "crumbs": [
      "Concepts avancés"
    ]
  },
  {
    "objectID": "content/Cours_5/3-patterndesign.html",
    "href": "content/Cours_5/3-patterndesign.html",
    "title": "Python Orienté Objet - les Design Patterns",
    "section": "",
    "text": "Définition et Importance des Design Patterns:\n\nDéfinition: Un design pattern en programmation orientée objet est une solution réutilisable à un problème couramment rencontré dans la conception logicielle.\nRôle des Design Patterns: Ils fournissent un cadre de référence pour résoudre des problèmes de conception similaires et améliorent la lisibilité et la maintenabilité du code.\n\nCatégories des Design Patterns:\n\nPatterns de Création: Concernent la manière de créer des objets tout en séparant la logique de construction de leur représentation.\nPatterns Structurels: Se concentrent sur la composition des classes ou objets pour former des structures plus grandes.\nPatterns Comportementaux: Traitent de la communication entre les objets et la répartition des responsabilités.\n\n\n\n\n\n\n\nSingleton:\n\nPrincipe: Assure qu’une classe n’a qu’une seule instance et fournit un point d’accès global à celle-ci.\nApplication en Python:\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nFactory Method:\n\nPrincipe: Définit une interface pour créer un objet, mais laisse les sous-classes décider quelle classe instancier.\nApplication en Python:\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nAdapter:\n\nPrincipe: Permet à des interfaces incompatibles de travailler ensemble. Il agit comme un intermédiaire entre deux classes non compatibles.\nApplication en Python:\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nDecorator:\n\nPrincipe: Permet d’ajouter dynamiquement de nouvelles fonctionnalités à un objet sans modifier sa structure.\nApplication en Python:\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nObserver:\n\nPrincipe: Définit une dépendance entre objets de manière à ce que lorsque l’un change d’état, tous ses dépendants sont notifiés et mis à jour automatiquement.\nApplication en Python:\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nStrategy:\n\nPrincipe: Permet de définir une famille d’algorithmes, encapsule chacun d’eux et les rend interchangeables. La stratégie laisse l’algorithme varier indépendamment des clients qui l’utilisent.\nApplication en Python:\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nLes design patterns en POO en Python jouent un rôle crucial dans la conception de logiciels efficaces, maintenables et évolutifs. Ils permettent aux développeurs de suivre des modèles éprouvés pour résoudre des problèmes communs de conception logicielle. Cette approche ne remplace pas la créativité dans la conception logicielle, mais fournit un langage commun et des solutions éprouvées pour des problèmes de conception courants.",
    "crumbs": [
      "Python Orienté Objet - les Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_5/3-patterndesign.html#introduction-aux-design-patterns",
    "href": "content/Cours_5/3-patterndesign.html#introduction-aux-design-patterns",
    "title": "Python Orienté Objet - les Design Patterns",
    "section": "",
    "text": "Définition et Importance des Design Patterns:\n\nDéfinition: Un design pattern en programmation orientée objet est une solution réutilisable à un problème couramment rencontré dans la conception logicielle.\nRôle des Design Patterns: Ils fournissent un cadre de référence pour résoudre des problèmes de conception similaires et améliorent la lisibilité et la maintenabilité du code.\n\nCatégories des Design Patterns:\n\nPatterns de Création: Concernent la manière de créer des objets tout en séparant la logique de construction de leur représentation.\nPatterns Structurels: Se concentrent sur la composition des classes ou objets pour former des structures plus grandes.\nPatterns Comportementaux: Traitent de la communication entre les objets et la répartition des responsabilités.",
    "crumbs": [
      "Python Orienté Objet - les Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_5/3-patterndesign.html#a---design-patterns-de-création",
    "href": "content/Cours_5/3-patterndesign.html#a---design-patterns-de-création",
    "title": "Python Orienté Objet - les Design Patterns",
    "section": "",
    "text": "Singleton:\n\nPrincipe: Assure qu’une classe n’a qu’une seule instance et fournit un point d’accès global à celle-ci.\nApplication en Python:\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nFactory Method:\n\nPrincipe: Définit une interface pour créer un objet, mais laisse les sous-classes décider quelle classe instancier.\nApplication en Python:\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Python Orienté Objet - les Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_5/3-patterndesign.html#b---design-patterns-structurels",
    "href": "content/Cours_5/3-patterndesign.html#b---design-patterns-structurels",
    "title": "Python Orienté Objet - les Design Patterns",
    "section": "",
    "text": "Adapter:\n\nPrincipe: Permet à des interfaces incompatibles de travailler ensemble. Il agit comme un intermédiaire entre deux classes non compatibles.\nApplication en Python:\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nDecorator:\n\nPrincipe: Permet d’ajouter dynamiquement de nouvelles fonctionnalités à un objet sans modifier sa structure.\nApplication en Python:\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Python Orienté Objet - les Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_5/3-patterndesign.html#c---design-patterns-comportementaux",
    "href": "content/Cours_5/3-patterndesign.html#c---design-patterns-comportementaux",
    "title": "Python Orienté Objet - les Design Patterns",
    "section": "",
    "text": "Observer:\n\nPrincipe: Définit une dépendance entre objets de manière à ce que lorsque l’un change d’état, tous ses dépendants sont notifiés et mis à jour automatiquement.\nApplication en Python:\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nStrategy:\n\nPrincipe: Permet de définir une famille d’algorithmes, encapsule chacun d’eux et les rend interchangeables. La stratégie laisse l’algorithme varier indépendamment des clients qui l’utilisent.\nApplication en Python:\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Python Orienté Objet - les Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_5/3-patterndesign.html#conclusion",
    "href": "content/Cours_5/3-patterndesign.html#conclusion",
    "title": "Python Orienté Objet - les Design Patterns",
    "section": "",
    "text": "Les design patterns en POO en Python jouent un rôle crucial dans la conception de logiciels efficaces, maintenables et évolutifs. Ils permettent aux développeurs de suivre des modèles éprouvés pour résoudre des problèmes communs de conception logicielle. Cette approche ne remplace pas la créativité dans la conception logicielle, mais fournit un langage commun et des solutions éprouvées pour des problèmes de conception courants.",
    "crumbs": [
      "Python Orienté Objet - les Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_2/2-FonctionsEtModules.html",
    "href": "content/Cours_2/2-FonctionsEtModules.html",
    "title": "Fonctions et Modules",
    "section": "",
    "text": "Les fonctions en Python sont des blocs de code réutilisables conçus pour effectuer une tâche spécifique. La création de fonctions bien définies est un élément clé de la programmation efficace et lisible.\n\n\n\nPour définir une fonction en Python, utilisez le mot-clé def, suivi du nom de la fonction, des parenthèses et des paramètres.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nAppelez une fonction en utilisant son nom suivi des arguments entre parenthèses.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\n\nLes fonctions peuvent avoir des arguments par défaut, qui prennent une valeur spécifiée si aucun argument n’est fourni.\nLes arguments nommés permettent de passer des arguments dans n’importe quel ordre en spécifiant leur nom.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nLes variables définies dans une fonction ont une portée locale à cette fonction. Les variables définies en dehors ont une portée globale.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nLes modules et packages en Python permettent de structurer et d’organiser le code de manière logique et réutilisable.\n\n\n\nUn module est un fichier Python contenant des fonctions, des classes et des variables, ainsi que du code exécutable.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nUn package est une collection de modules. Il contient un fichier spécial nommé __init__.py.\n\nPour créer un package, créez un répertoire portant le nom du package, puis ajoutez-y des modules et un fichier __init__.py.\nImportez des modules spécifiques du package :\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nPython propose des fonctions intégrées et des expressions lambda pour effectuer des opérations fonctionnelles courantes comme le mappage, le filtrage et la réduction des données.\n\n\n\nLes expressions lambda sont de petites fonctions anonymes.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nmap() applique une fonction à chaque élément d’une séquence.\nfilter() crée une liste de tous les éléments pour lesquels une fonction renvoie True.\nreduce() applique une fonction cumulativement aux éléments d’une séquence, de gauche à droite, pour réduire la séquence à une seule valeur.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\nEn Python, *args et kwargs permettent de gérer de manière flexible un nombre variable d’arguments dans les fonctions.\n\n\n\n*args est utilisé pour passer une liste variable d’arguments non-nommés à une fonction. Les arguments sont accessibles comme une tuple.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nkwargs permet de passer une liste variable d’arguments nommés. Les arguments sont accessibles comme un dictionnaire.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nLes expressions lambda en Python offrent un moyen compact de créer des fonctions anonymes pour des opérations simples.\n\n\n\nLes expressions lambda sont souvent utilisées pour des fonctions courtes et simples, comme des arguments pour des fonctions comme map, filter, et sorted.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nL’organisation des projets en modules et packages est essentielle pour maintenir une structure claire et une maintenance facile du code.\n\n\n\nUn module en Python est simplement un fichier .py. Pour utiliser un module, utilisez import nom_du_module.\nUn package est un répertoire contenant un fichier spécial __init__.py et un ou plusieurs modules.\n\n\n\n\n\nUtilisez import pour accéder aux fonctions, classes et variables d’un module ou package. Les alias peuvent être utilisés pour simplifier les noms.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nLes packages permettent de regrouper des modules logiquement liés, facilitant ainsi la réutilisation et la distribution du code.\nIls aident à éviter les conflits de noms et rendent le code plus organisable et maintenable.\n\n\n\n\n\nLa compréhension de la façon dont Python importe des modules et gère les chemins d’accès aux packages est essentielle pour éviter des erreurs courantes, notamment les dépendances circulaires.\n\n\n\nLorsque vous importez un module, Python recherche d’abord dans le répertoire courant, puis dans les répertoires listés dans la variable d’environnement PYTHONPATH, et enfin dans les emplacements par défaut.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPYTHONPATH est similaire à PATH vu précédemment. Il s’agit d’une liste de répertoires dans lesquels Python cherche des modules à importer.\n\n\n\n\n\nLorsque vous utilisez from X import Y, Python exécute tout le code à la racine du module X. Cela signifie que tout code au niveau du module, y compris les importations, sera exécuté lors de l’importation.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nUne dépendance circulaire se produit lorsque deux modules s’importent mutuellement. Cela peut entraîner des erreurs d’exécution car l’ordre d’importation peut affecter la disponibilité des fonctions et des classes.\n\nPour éviter cela, structurez votre code pour minimiser les dépendances inter-modules.\nConsidérez l’utilisation de l’importation à l’intérieur des fonctions ou des classes si l’importation est nécessaire uniquement dans une portée locale.\n\n\n\n\n\n\nÉvitez les importations génériques (from module import *) car elles peuvent polluer l’espace de noms.\nUtilisez des alias pour clarifier l’origine des modules ou pour éviter des conflits de noms.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nComprendre les subtilités des importations en Python, y compris leur coût et les conventions d’abréviation, peut améliorer la lisibilité et l’efficacité du code.\n\n\n\nEn Python, importer plusieurs fois le même module ne pénalise pas les performances de manière significative. Lorsqu’un module est importé pour la première fois, il est compilé en bytecode et stocké en mémoire. Les importations suivantes du même module font simplement référence à la version en mémoire.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nCela signifie que vous pouvez importer le même module dans différents fichiers ou plusieurs fois dans le même fichier sans vous soucier d’un impact négatif sur les performances.\n\n\n\n\n\nIl existe des conventions d’abréviations pour certains modules fréquemment utilisés en Python. Utiliser ces abréviations peut rendre votre code plus lisible et conforme aux standards de la communauté.\n\n\n\nModule\nAbréviation Standard\n\n\n\n\npandas\npd\n\n\nnumpy\nnp\n\n\nmatplotlib.pyplot\nplt\n\n\nseaborn\nsns\n\n\ntensorflow\ntf\n\n\nscikit-learn\nskl\n\n\nscipy\nsp\n\n\nos\nos (généralement utilisé tel quel)\n\n\nsys\nsys (généralement utilisé tel quel)\n\n\n\nCes abréviations sont largement reconnues et leur utilisation est recommandée pour maintenir la cohérence avec les pratiques de la communauté Python.\n\n\n\n\n\nEn plus d’utiliser des abréviations standard, il est également conseillé de regrouper les importations en haut du fichier.\nSéparez les importations standard, tierces et locales par des lignes vides pour une meilleure lisibilité.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n```",
    "crumbs": [
      "Fonctions et Modules"
    ]
  },
  {
    "objectID": "content/Cours_2/2-FonctionsEtModules.html#section-2.1-définition-et-appel-de-fonctions",
    "href": "content/Cours_2/2-FonctionsEtModules.html#section-2.1-définition-et-appel-de-fonctions",
    "title": "Fonctions et Modules",
    "section": "",
    "text": "Les fonctions en Python sont des blocs de code réutilisables conçus pour effectuer une tâche spécifique. La création de fonctions bien définies est un élément clé de la programmation efficace et lisible.\n\n\n\nPour définir une fonction en Python, utilisez le mot-clé def, suivi du nom de la fonction, des parenthèses et des paramètres.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nAppelez une fonction en utilisant son nom suivi des arguments entre parenthèses.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\n\nLes fonctions peuvent avoir des arguments par défaut, qui prennent une valeur spécifiée si aucun argument n’est fourni.\nLes arguments nommés permettent de passer des arguments dans n’importe quel ordre en spécifiant leur nom.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nLes variables définies dans une fonction ont une portée locale à cette fonction. Les variables définies en dehors ont une portée globale.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Fonctions et Modules"
    ]
  },
  {
    "objectID": "content/Cours_2/2-FonctionsEtModules.html#section-2.2-modules-et-packages",
    "href": "content/Cours_2/2-FonctionsEtModules.html#section-2.2-modules-et-packages",
    "title": "Fonctions et Modules",
    "section": "",
    "text": "Les modules et packages en Python permettent de structurer et d’organiser le code de manière logique et réutilisable.\n\n\n\nUn module est un fichier Python contenant des fonctions, des classes et des variables, ainsi que du code exécutable.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nUn package est une collection de modules. Il contient un fichier spécial nommé __init__.py.\n\nPour créer un package, créez un répertoire portant le nom du package, puis ajoutez-y des modules et un fichier __init__.py.\nImportez des modules spécifiques du package :\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Fonctions et Modules"
    ]
  },
  {
    "objectID": "content/Cours_2/2-FonctionsEtModules.html#section-2.3-lambda-map-filter-et-reduce",
    "href": "content/Cours_2/2-FonctionsEtModules.html#section-2.3-lambda-map-filter-et-reduce",
    "title": "Fonctions et Modules",
    "section": "",
    "text": "Python propose des fonctions intégrées et des expressions lambda pour effectuer des opérations fonctionnelles courantes comme le mappage, le filtrage et la réduction des données.\n\n\n\nLes expressions lambda sont de petites fonctions anonymes.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nmap() applique une fonction à chaque élément d’une séquence.\nfilter() crée une liste de tous les éléments pour lesquels une fonction renvoie True.\nreduce() applique une fonction cumulativement aux éléments d’une séquence, de gauche à droite, pour réduire la séquence à une seule valeur.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Fonctions et Modules"
    ]
  },
  {
    "objectID": "content/Cours_2/2-FonctionsEtModules.html#section-2.7-manipulation-des-arguments-de-fonction-avec-args-et-kwargs",
    "href": "content/Cours_2/2-FonctionsEtModules.html#section-2.7-manipulation-des-arguments-de-fonction-avec-args-et-kwargs",
    "title": "Fonctions et Modules",
    "section": "",
    "text": "En Python, *args et kwargs permettent de gérer de manière flexible un nombre variable d’arguments dans les fonctions.\n\n\n\n*args est utilisé pour passer une liste variable d’arguments non-nommés à une fonction. Les arguments sont accessibles comme une tuple.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nkwargs permet de passer une liste variable d’arguments nommés. Les arguments sont accessibles comme un dictionnaire.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Fonctions et Modules"
    ]
  },
  {
    "objectID": "content/Cours_2/2-FonctionsEtModules.html#section-2.8-expressions-lambda-pour-des-fonctions-anonymes",
    "href": "content/Cours_2/2-FonctionsEtModules.html#section-2.8-expressions-lambda-pour-des-fonctions-anonymes",
    "title": "Fonctions et Modules",
    "section": "",
    "text": "Les expressions lambda en Python offrent un moyen compact de créer des fonctions anonymes pour des opérations simples.\n\n\n\nLes expressions lambda sont souvent utilisées pour des fonctions courtes et simples, comme des arguments pour des fonctions comme map, filter, et sorted.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Fonctions et Modules"
    ]
  },
  {
    "objectID": "content/Cours_2/2-FonctionsEtModules.html#section-2.9-modules-et-packages-pour-structurer-les-projets",
    "href": "content/Cours_2/2-FonctionsEtModules.html#section-2.9-modules-et-packages-pour-structurer-les-projets",
    "title": "Fonctions et Modules",
    "section": "",
    "text": "L’organisation des projets en modules et packages est essentielle pour maintenir une structure claire et une maintenance facile du code.\n\n\n\nUn module en Python est simplement un fichier .py. Pour utiliser un module, utilisez import nom_du_module.\nUn package est un répertoire contenant un fichier spécial __init__.py et un ou plusieurs modules.\n\n\n\n\n\nUtilisez import pour accéder aux fonctions, classes et variables d’un module ou package. Les alias peuvent être utilisés pour simplifier les noms.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nLes packages permettent de regrouper des modules logiquement liés, facilitant ainsi la réutilisation et la distribution du code.\nIls aident à éviter les conflits de noms et rendent le code plus organisable et maintenable.",
    "crumbs": [
      "Fonctions et Modules"
    ]
  },
  {
    "objectID": "content/Cours_2/2-FonctionsEtModules.html#section-2.10-mécanisme-dimportation-en-python-et-gestion-des-dépendances",
    "href": "content/Cours_2/2-FonctionsEtModules.html#section-2.10-mécanisme-dimportation-en-python-et-gestion-des-dépendances",
    "title": "Fonctions et Modules",
    "section": "",
    "text": "La compréhension de la façon dont Python importe des modules et gère les chemins d’accès aux packages est essentielle pour éviter des erreurs courantes, notamment les dépendances circulaires.\n\n\n\nLorsque vous importez un module, Python recherche d’abord dans le répertoire courant, puis dans les répertoires listés dans la variable d’environnement PYTHONPATH, et enfin dans les emplacements par défaut.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPYTHONPATH est similaire à PATH vu précédemment. Il s’agit d’une liste de répertoires dans lesquels Python cherche des modules à importer.\n\n\n\n\n\nLorsque vous utilisez from X import Y, Python exécute tout le code à la racine du module X. Cela signifie que tout code au niveau du module, y compris les importations, sera exécuté lors de l’importation.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nUne dépendance circulaire se produit lorsque deux modules s’importent mutuellement. Cela peut entraîner des erreurs d’exécution car l’ordre d’importation peut affecter la disponibilité des fonctions et des classes.\n\nPour éviter cela, structurez votre code pour minimiser les dépendances inter-modules.\nConsidérez l’utilisation de l’importation à l’intérieur des fonctions ou des classes si l’importation est nécessaire uniquement dans une portée locale.\n\n\n\n\n\n\nÉvitez les importations génériques (from module import *) car elles peuvent polluer l’espace de noms.\nUtilisez des alias pour clarifier l’origine des modules ou pour éviter des conflits de noms.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Fonctions et Modules"
    ]
  },
  {
    "objectID": "content/Cours_2/2-FonctionsEtModules.html#section-2.11-coût-des-importations-répétées-et-abréviations-standard-en-python",
    "href": "content/Cours_2/2-FonctionsEtModules.html#section-2.11-coût-des-importations-répétées-et-abréviations-standard-en-python",
    "title": "Fonctions et Modules",
    "section": "",
    "text": "Comprendre les subtilités des importations en Python, y compris leur coût et les conventions d’abréviation, peut améliorer la lisibilité et l’efficacité du code.\n\n\n\nEn Python, importer plusieurs fois le même module ne pénalise pas les performances de manière significative. Lorsqu’un module est importé pour la première fois, il est compilé en bytecode et stocké en mémoire. Les importations suivantes du même module font simplement référence à la version en mémoire.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nCela signifie que vous pouvez importer le même module dans différents fichiers ou plusieurs fois dans le même fichier sans vous soucier d’un impact négatif sur les performances.\n\n\n\n\n\nIl existe des conventions d’abréviations pour certains modules fréquemment utilisés en Python. Utiliser ces abréviations peut rendre votre code plus lisible et conforme aux standards de la communauté.\n\n\n\nModule\nAbréviation Standard\n\n\n\n\npandas\npd\n\n\nnumpy\nnp\n\n\nmatplotlib.pyplot\nplt\n\n\nseaborn\nsns\n\n\ntensorflow\ntf\n\n\nscikit-learn\nskl\n\n\nscipy\nsp\n\n\nos\nos (généralement utilisé tel quel)\n\n\nsys\nsys (généralement utilisé tel quel)\n\n\n\nCes abréviations sont largement reconnues et leur utilisation est recommandée pour maintenir la cohérence avec les pratiques de la communauté Python.\n\n\n\n\n\nEn plus d’utiliser des abréviations standard, il est également conseillé de regrouper les importations en haut du fichier.\nSéparez les importations standard, tierces et locales par des lignes vides pour une meilleure lisibilité.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n```",
    "crumbs": [
      "Fonctions et Modules"
    ]
  },
  {
    "objectID": "content/Cours_2/3-IntroducingPOOConcept.html",
    "href": "content/Cours_2/3-IntroducingPOOConcept.html",
    "title": "Introduction à la POO en Python",
    "section": "",
    "text": "La Programmation Orientée Objet (POO) est un paradigme de programmation basé sur le concept d’« objets », qui peuvent contenir des données sous forme d’attributs, et du code sous forme de méthodes. En Python, la POO offre une approche flexible et puissante pour structurer et concevoir des applications.\n\n\n\nEncapsulation: Regroupe les données et les méthodes qui manipulent ces données au sein d’une unité appelée « classe ». Cela permet de cacher la représentation interne des données à l’extérieur de la classe, une pratique connue sous le nom de “cachette d’information”.\nHéritage: Permet à une classe de hériter des attributs et méthodes d’une autre classe. Cela facilite la réutilisation du code et la création d’une hiérarchie de classes.\nPolymorphisme: Signifie que des fonctions ou des méthodes peuvent être utilisées avec des objets de différents types. Il s’appuie sur l’héritage pour fournir cette flexibilité.\n\n\n\n\n\nPython est un langage multi-paradigme qui supporte à la fois la programmation procédurale et la POO. Ce qui le rend particulièrement puissant est sa capacité à offrir une syntaxe claire et une grande flexibilité dans la conception de classes et d’objets.\nContrairement à d’autres langages où les objets et les types de base sont distincts, en Python, tout est un objet. Cela inclut les types de base comme les nombres, les chaînes et les listes. Cette uniformité rend le langage cohérent et élégant.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nEn Python, même les fonctions sont des objets. Cela permet des concepts avancés comme les décorateurs et les fonctions de première classe.\n\n\n\n\n\nLa POO offre plusieurs avantages qui la rendent idéale pour un large éventail d’applications de programmation.\n\n\n\nModularité et Réutilisation du Code**: La POO en Python permet de créer des modules et des bibliothèques réutilisables. Les classes peuvent être conçues comme des composants réutilisables dans différents projets.\nSimplicité et Clarté: La structure de classe en POO permet une organisation claire du code. Cela facilite la maintenance et la mise à jour des applications.\nExtensibilité: La capacité à étendre les classes existantes via l’héritage rend le code adaptable et évolutif.\nAdaptabilité à de Multiples Domaines: De la conception de jeux à l’intelligence artificielle et au développement web, la POO est utilisée dans de nombreux domaines, reflétant sa polyvalence et son adaptabilité.\n\n\n\n\n\nPython ajoute une touche de flexibilité et de simplicité à la POO, rendant l’apprentissage et l’utilisation de ce paradigme plus accessibles par rapport à des langages plus stricts et formels.\nLes mécanismes avancés de Python, tels que le duck typing et les méthodes magiques, ouvrent des possibilités de conception et d’implémentation qui vont au-delà des approches traditionnelles de la POO.\nL’écosystème riche de Python en frameworks et bibliothèques orientés objet (comme Django pour le web ou Pandas pour la manipulation de données) montre l’efficacité et la popularité de la POO dans la communauté Python.\n\n\n\n\n\n\nLes classes sont au cœur de la POO en Python. Elles servent de modèle pour créer des objets (instances).\n\n\n\nUne classe en Python est définie en utilisant le mot-clé class. Elle peut contenir des attributs (variables) et des méthodes (fonctions).\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nLa méthode __init__ est un constructeur. Elle est appelée lors de la création d’une nouvelle instance de la classe.\n\n\n\n\n\nAprès avoir défini une classe, vous pouvez créer des instances (objets) et accéder à leurs attributs et méthodes.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nL’héritage permet à une classe de hériter des attributs et méthodes d’une autre classe.\n\n\n\nEn Python, une classe peut hériter d’une autre classe, ce qui lui permet de reprendre ses attributs et méthodes.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nLa fonction super() est utilisée pour appeler le constructeur de la classe parente.\n\n\n\n\n\nLe polymorphisme permet d’utiliser des objets de différentes classes de manière interchangeable.\n\n\n\nLe polymorphisme se manifeste lorsqu’une interface commune (comme une méthode) est implémentée de différentes manières par différentes classes.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nLa fonction isinstance() est utilisée pour vérifier le type d’une instance.\n\n\n\n\n\n\nL’encapsulation et l’abstraction sont des principes de POO essentiels pour créer des modèles financiers robustes et flexibles.\n\n\n\nL’encapsulation consiste à regrouper les données et les méthodes qui les manipulent, et à restreindre l’accès direct aux données d’une classe. Cela est crucial pour la sécurité et l’intégrité des modèles financiers.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nLes attributs précédés de __ sont considérés comme privés et ne sont pas accessibles directement en dehors de la classe.\n\n\n\n\n\nL’abstraction permet de créer des modèles simplifiés en ne retenant que les détails pertinents. Elle est utile pour modéliser des produits financiers complexes.\n\nPar exemple, une classe abstraite ProduitFinancier peut définir une interface pour le calcul du prix, tandis que les sous-classes concrétisent ces calculs pour différents produits.\n\n\n\n\n\n\nUtilisons la POO pour modéliser un scénario financier concret, comme le pricing d’obligations.\n\n\n\nImaginons que nous devons calculer le prix de différentes obligations avec des caractéristiques variées. Nous pouvons utiliser des classes pour modéliser ces obligations et effectuer les calculs nécessaires.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nDans cet exemple, chaque instance de Obligation représente une obligation distincte. La méthode prix calcule le prix actuel de l’obligation en actualisant ses flux de trésorerie futurs au taux du marché.",
    "crumbs": [
      "Introduction à la POO en Python"
    ]
  },
  {
    "objectID": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.1-introduction-à-la-poo-et-son-application-en-python",
    "href": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.1-introduction-à-la-poo-et-son-application-en-python",
    "title": "Introduction à la POO en Python",
    "section": "",
    "text": "La Programmation Orientée Objet (POO) est un paradigme de programmation basé sur le concept d’« objets », qui peuvent contenir des données sous forme d’attributs, et du code sous forme de méthodes. En Python, la POO offre une approche flexible et puissante pour structurer et concevoir des applications.\n\n\n\nEncapsulation: Regroupe les données et les méthodes qui manipulent ces données au sein d’une unité appelée « classe ». Cela permet de cacher la représentation interne des données à l’extérieur de la classe, une pratique connue sous le nom de “cachette d’information”.\nHéritage: Permet à une classe de hériter des attributs et méthodes d’une autre classe. Cela facilite la réutilisation du code et la création d’une hiérarchie de classes.\nPolymorphisme: Signifie que des fonctions ou des méthodes peuvent être utilisées avec des objets de différents types. Il s’appuie sur l’héritage pour fournir cette flexibilité.\n\n\n\n\n\nPython est un langage multi-paradigme qui supporte à la fois la programmation procédurale et la POO. Ce qui le rend particulièrement puissant est sa capacité à offrir une syntaxe claire et une grande flexibilité dans la conception de classes et d’objets.\nContrairement à d’autres langages où les objets et les types de base sont distincts, en Python, tout est un objet. Cela inclut les types de base comme les nombres, les chaînes et les listes. Cette uniformité rend le langage cohérent et élégant.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nEn Python, même les fonctions sont des objets. Cela permet des concepts avancés comme les décorateurs et les fonctions de première classe.",
    "crumbs": [
      "Introduction à la POO en Python"
    ]
  },
  {
    "objectID": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.2-lintérêt-et-les-avantages-de-la-poo-en-python",
    "href": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.2-lintérêt-et-les-avantages-de-la-poo-en-python",
    "title": "Introduction à la POO en Python",
    "section": "",
    "text": "La POO offre plusieurs avantages qui la rendent idéale pour un large éventail d’applications de programmation.\n\n\n\nModularité et Réutilisation du Code**: La POO en Python permet de créer des modules et des bibliothèques réutilisables. Les classes peuvent être conçues comme des composants réutilisables dans différents projets.\nSimplicité et Clarté: La structure de classe en POO permet une organisation claire du code. Cela facilite la maintenance et la mise à jour des applications.\nExtensibilité: La capacité à étendre les classes existantes via l’héritage rend le code adaptable et évolutif.\nAdaptabilité à de Multiples Domaines: De la conception de jeux à l’intelligence artificielle et au développement web, la POO est utilisée dans de nombreux domaines, reflétant sa polyvalence et son adaptabilité.\n\n\n\n\n\nPython ajoute une touche de flexibilité et de simplicité à la POO, rendant l’apprentissage et l’utilisation de ce paradigme plus accessibles par rapport à des langages plus stricts et formels.\nLes mécanismes avancés de Python, tels que le duck typing et les méthodes magiques, ouvrent des possibilités de conception et d’implémentation qui vont au-delà des approches traditionnelles de la POO.\nL’écosystème riche de Python en frameworks et bibliothèques orientés objet (comme Django pour le web ou Pandas pour la manipulation de données) montre l’efficacité et la popularité de la POO dans la communauté Python.",
    "crumbs": [
      "Introduction à la POO en Python"
    ]
  },
  {
    "objectID": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.3-définition-et-utilisation-des-classes-en-python",
    "href": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.3-définition-et-utilisation-des-classes-en-python",
    "title": "Introduction à la POO en Python",
    "section": "",
    "text": "Les classes sont au cœur de la POO en Python. Elles servent de modèle pour créer des objets (instances).\n\n\n\nUne classe en Python est définie en utilisant le mot-clé class. Elle peut contenir des attributs (variables) et des méthodes (fonctions).\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nLa méthode __init__ est un constructeur. Elle est appelée lors de la création d’une nouvelle instance de la classe.\n\n\n\n\n\nAprès avoir défini une classe, vous pouvez créer des instances (objets) et accéder à leurs attributs et méthodes.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Introduction à la POO en Python"
    ]
  },
  {
    "objectID": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.4-héritage-en-python",
    "href": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.4-héritage-en-python",
    "title": "Introduction à la POO en Python",
    "section": "",
    "text": "L’héritage permet à une classe de hériter des attributs et méthodes d’une autre classe.\n\n\n\nEn Python, une classe peut hériter d’une autre classe, ce qui lui permet de reprendre ses attributs et méthodes.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nLa fonction super() est utilisée pour appeler le constructeur de la classe parente.",
    "crumbs": [
      "Introduction à la POO en Python"
    ]
  },
  {
    "objectID": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.5-polymorphisme-en-python",
    "href": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.5-polymorphisme-en-python",
    "title": "Introduction à la POO en Python",
    "section": "",
    "text": "Le polymorphisme permet d’utiliser des objets de différentes classes de manière interchangeable.\n\n\n\nLe polymorphisme se manifeste lorsqu’une interface commune (comme une méthode) est implémentée de différentes manières par différentes classes.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nLa fonction isinstance() est utilisée pour vérifier le type d’une instance.",
    "crumbs": [
      "Introduction à la POO en Python"
    ]
  },
  {
    "objectID": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.6-encapsulation-et-abstraction-dans-la-modélisation-financière",
    "href": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.6-encapsulation-et-abstraction-dans-la-modélisation-financière",
    "title": "Introduction à la POO en Python",
    "section": "",
    "text": "L’encapsulation et l’abstraction sont des principes de POO essentiels pour créer des modèles financiers robustes et flexibles.\n\n\n\nL’encapsulation consiste à regrouper les données et les méthodes qui les manipulent, et à restreindre l’accès direct aux données d’une classe. Cela est crucial pour la sécurité et l’intégrité des modèles financiers.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nLes attributs précédés de __ sont considérés comme privés et ne sont pas accessibles directement en dehors de la classe.\n\n\n\n\n\nL’abstraction permet de créer des modèles simplifiés en ne retenant que les détails pertinents. Elle est utile pour modéliser des produits financiers complexes.\n\nPar exemple, une classe abstraite ProduitFinancier peut définir une interface pour le calcul du prix, tandis que les sous-classes concrétisent ces calculs pour différents produits.",
    "crumbs": [
      "Introduction à la POO en Python"
    ]
  },
  {
    "objectID": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.7-exemple-pratique-en-finance-de-marché",
    "href": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.7-exemple-pratique-en-finance-de-marché",
    "title": "Introduction à la POO en Python",
    "section": "",
    "text": "Utilisons la POO pour modéliser un scénario financier concret, comme le pricing d’obligations.\n\n\n\nImaginons que nous devons calculer le prix de différentes obligations avec des caractéristiques variées. Nous pouvons utiliser des classes pour modéliser ces obligations et effectuer les calculs nécessaires.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nDans cet exemple, chaque instance de Obligation représente une obligation distincte. La méthode prix calcule le prix actuel de l’obligation en actualisant ses flux de trésorerie futurs au taux du marché.",
    "crumbs": [
      "Introduction à la POO en Python"
    ]
  },
  {
    "objectID": "content/Cours_2/Exercices.html",
    "href": "content/Cours_2/Exercices.html",
    "title": "Exercices d’applications",
    "section": "",
    "text": "Liste des fichiers à télécharger\n\n Telecharger le premier jeu d'exercice \n Telecharger le premier second d'exercice \n\n\n\n\n Back to top",
    "crumbs": [
      "Travaux Pratiques",
      "Exercices d'applications"
    ]
  },
  {
    "objectID": "content/Projets/L3_EIF_2024.html",
    "href": "content/Projets/L3_EIF_2024.html",
    "title": "Projets Introduction à Python - Millésime 2024",
    "section": "",
    "text": "Dans le cadre de votre formation en L3 Économie et Ingénierie Financière, une série de sujets de projets vous sont proposés. Ces projets visent à consolider vos connaissances théoriques et à développer vos compétences pratiques. Ces projets sont conçus pour renforcer vos connaissances théoriques tout en développant vos compétences pratiques. Ils représentent une occasion précieuse de vous préparer aux défis réels que vous rencontrerez dans votre future carrière professionnelle.\nVous êtes encouragés à choisir un sujet qui correspond à vos intérêts personnels et à vos aspirations professionnelles. Les thèmes proposés couvrent une variété de domaines, reflétant ainsi les diverses opportunités qui pourraient se présenter à vous dans le futur. Ils ont été soigneusement sélectionnés pour leur pertinence pratique et leur valeur pédagogique.\nNéanmoins, cette liste de sujets n’est pas exhaustive. Vous êtes libres et même encouragés à proposer vos propres idées de projets. Vos suggestions peuvent être envoyées par mail pour validation, afin de s’assurer de leur faisabilité et de leur adéquation avec les objectifs du cours. Bien que ce soit principalement un cours de programmation, les projets qui s’éloignent du domaine financier tout en intégrant les concepts abordés en cours sont également bienvenus.\nLa date limite de soumission des projets est fixée au 28 avril. Veuillez noter qu’un malus pour retard de soumission sera appliqué selon la formule suivante : (((x/25) - 1) %), où (x) représente le nombre de jours de retard.\nLes projets doivent être soumis par mail à remi.gnt@gmail.com. Il est préférable d’envoyer votre travail sous forme de fichier zip, mais un lien vers un Google Drive est également acceptable. Veuillez éviter les plateformes d’envoi telles que WeTransfer, qui ont une durée de téléchargement limitée.\nDe plus, il est vivement conseillé de soumettre votre projet via GitHub. Envoyer un simple mail avec un lien vers votre projet GitHub ou m’inviter à rejoindre votre dépôt (username GitHub : remigenet) peut vous faire bénéficier de points bonus. Un point bonus sera attribué à chaque groupe soumettant sur GitHub, et deux points supplémentaires si l’utilisation de GitHub montre un travail d’équipe effectif tout au long du projet. Pour faciliter l’organisation, j’ai créé un espace sur GitHub pour regrouper les projets : https://github.com/L3-EIF-2023. Vous pouvez demander à être ajouté à cette organisation et y déposer votre projet.\nCe projet est également une excellente opportunité d’enrichir votre CV. Un travail de qualité, rendu public sur votre compte GitHub, démontre non seulement vos compétences en programmation, mais aussi votre capacité à travailler en équipe. Pour ceux qui cherchent bientôt une alternance, c’est un avantage considérable.\nEnfin, le poids du projets dans la note finale sera de 75% à 100%, en effet le QCM de cours ne sera pris en compte que si la note est supérieure à la note du projet.\n\n\n\n\n\nDans le domaine des contrats dérivés, il est essentiel de comprendre que chaque contrat, qu’il s’agisse d’un future, d’un perpétuel, d’une option ou de toute autre structure plus exotique, représente un engagement entre deux parties. La valeur et, par conséquent, le prix d’échange de ces contrats sont déterminés par les termes et conditions spécifiques qu’ils contiennent.\n\nContrat Perpétuel vs Spot :\n\nContrat Perpétuel : Ce type de contrat à terme, couramment utilisé dans les marchés de dérivés et en particulier dans les crypto-monnaies, se distingue des contrats à terme traditionnels par l’absence de date d’expiration. Son objectif principal est de suivre le prix du marché au comptant (spot). Pour ce faire, il utilise des taux de financement qui ajustent régulièrement son prix afin de le maintenir aligné avec le marché spot.\nTaux de Financement : Ces taux jouent un rôle crucial dans la garantie que le prix du contrat perpétuel reste en adéquation avec le marché au comptant. Leur valeur peut varier, devenant positive ou négative en fonction de la dynamique du marché, notamment en situations de contango ou de backwardation.\nMarché Spot : Il s’agit du marché où les actifs, comme le Bitcoin, sont échangés pour une livraison immédiate. La fongibilité de ce marché entre les différentes plateformes d’échange permet une grande flexibilité dans l’achat et la vente d’actifs.\n\nPosition Longue sur Contrat Dérivé : Prendre une position longue dans un contrat dérivé signifie s’engager à acheter un actif, basé sur la spéculation que la valeur de l’actif sous-jacent augmentera. Cette position est différente de l’achat direct d’actifs sur le marché spot.\nCollatéral et Haircut :\n\nLe collatéral est un élément clé dans la sécurisation des positions prises dans les contrats dérivés. Sa proportion requise peut varier selon la taille et le risque de la position.\nLe terme “haircut” appliqué au collatéral non-USD fait référence à la réduction de la valeur du collatéral pour compenser le risque de change associé.\n\n\nEn résumé, la valeur intrinsèque d’un contrat dérivé découle des conditions spécifiques qu’il impose, avec le contrat perpétuel servant d’exemple principal où les taux de financement sont les clauses permettant de synchroniser son prix avec celui du marché spot.\n\n\n\nL’objectif principal est de comparer les coûts d’une position longue sur un contrat perpétuel avec ceux de l’achat direct de l’actif sur le marché spot. Les aspects suivants seront pris en compte :\n\nPour 2 Personnes :\n\nCalcul sous l’hypothèse d’un besoin en liquidité équivalent à 25% en tant que collatéral (marge initiale). La comparaison inclura les éventuelles différences de prix entre le contrat perpétuel et le marché spot lors de l’ouverture et de la fermeture de la position, en tenant compte des taux de financement historiques.\n\nPour 3 Personnes :\n\nIntégration des contraintes de couverture (en se basant sur celles d’une plateforme d’échange spécifique), avec une analyse des variations des exigences en collatéral en fonction de la taille de la position. Il sera également pris en compte le fait que la position sur le marché spot ne peut pas couvrir la position future, ainsi que les coûts de financement pour les USD engagés.\n\nPour 4 Personnes :\n\nLa récupération des données doit être intégrée dans les classes développées, avec la mise en œuvre d’un système de cache pour optimiser l’efficacité du traitement des données. L’objectif est de rendre l’utilisation de la classe aussi simple que possible pour l’utilisateur.\n\nPour 5 Personnes :\n\nAnalyse de la stratégie de cash and carry en utilisant un contrat perpétuel.\nStratégie de Cash and Carry avec Contrat Perpétuel : Cette approche implique la comparaison entre l’achat d’un actif sur le marché spot et sa vente simultanée via un contrat perpétuel, en comprenant les risques potentiels associés à cette stratégie.\n\nPour 6-7 Personnes :\n\nEn tenant compte de tous les éléments mentionnés précédemment, y compris les contraintes de collatéral imposées par l’exchange et un montant initial en dollars qui ne peut être augmenté, réaliser un backtest de la stratégie de cash and carry. Ce test prendra en compte la taille initiale de la position, qui dépendra du levier choisi initialement. En cas de rapprochement de la position courte sur le contrat perpétuel de sa marge de maintenance, simuler une réduction des positions par vente partielle sur le marché spot (réalisation des plus-values) et un rachat partiel sur le contrat dérivé (réalisation des moins-values), en utilisant un prix de clôture pour les deux positions basé sur le VWAP (Volume Weighted Average Price) sur une période où la participation au volume ne dépasse pas 10% du volume total.\n\n\n\n\n\n\n\n\nUn backtest est une méthode utilisée dans le domaine de la finance pour évaluer la viabilité et la performance d’une stratégie d’investissement. Cette technique implique de simuler la manière dont une stratégie aurait performé en utilisant des données historiques. Le but est de fournir un aperçu de la façon dont une stratégie aurait réagi dans différentes conditions de marché passées.\n\n\n\nÉvaluation des Stratégies : Le backtest permet aux traders et aux investisseurs de tester leurs stratégies sur des données passées avant de les appliquer dans des conditions réelles de marché. C’est un outil essentiel pour identifier les forces et les faiblesses d’une stratégie avant son déploiement.\nRéduction des Risques : En testant une stratégie sur des données historiques, les investisseurs peuvent mieux comprendre et gérer les risques potentiels.\nOptimisation des Stratégies : Les résultats d’un backtest peuvent être utilisés pour affiner et améliorer une stratégie, en ajustant ses paramètres pour maximiser les rendements potentiels.\n\n\n\n\nBien que le backtest soit un outil puissant, il est important de reconnaître ses limites. Les résultats d’un backtest sont toujours basés sur des hypothèses et des simulations, et ne peuvent garantir des performances futures. Les limitations clés incluent :\n\nHypothèses de Simulation : Un backtest repose sur des hypothèses qui peuvent ne pas être entièrement représentatives des conditions réelles du marché.\nBiais de Survie : Les données historiques peuvent exclure les actifs ou stratégies qui ont échoué dans le passé, conduisant à une perception faussée de la performance.\nChangements du Marché : Les conditions de marché évoluent constamment, et une stratégie qui a réussi dans le passé pourrait ne pas être aussi efficace dans le futur en raison de changements dans les dynamiques du marché.\n\n\n\n\nDévelopper un backtester sous forme de classe, qui utilise une fonction prenant en entrée un historique de barres OHLCV (Open, High, Low, Close, Volume) et renvoyant la position d’une stratégie d’investissement.\n\n\n\n\n\nPour 2 Personnes :\n\nStockage Local des Données : Les données seront stockées localement et incluses dans le projet pour faciliter les tests.\nAnalyse d’Un Actif : Le backtester se concentrera sur un seul actif avec des positions variant entre -100% et 100%.\nRésultats : Génération d’un graphique représentant la performance de la stratégie sur la période choisie, accompagné de statistiques de base telles que le rendement moyen, la variance, et le bêta.\n\nPour 3 Personnes (Option A) :\n\nStratégie sur Plusieurs Actifs : Extension du backtester pour accepter une fonction de stratégie applicable à plusieurs actifs.\nStatistiques Avancées : Calcul de statistiques plus élaborées comme le bêta en hausse et en baisse, le drawdown maximal, s’inspirant de sources telles que Quantalys ou Morningstar.\n\nOU\nPour 3 Personnes (Option B) :\n\nTéléchargement et Cache Asynchrone : Mise en place d’un système pour le téléchargement et le stockage en cache des données de manière asynchrone.\n\nPour 4 Personnes :\n\nCombinaison des points mentionnés dans les options pour 3 personnes (Option A et B).\n\nPour 5 Personnes :\n\nIntégration des Crypto-monnaies : Ajout de la capacité à analyser les stratégies impliquant des contrats dérivés perpétuels ou futurs.\nSpécificités des Dérivés :\n\nPour les contrats perpétuels, le calcul inclura le coût du taux de financement.\nPour les contrats futurs, le calcul se basera sur le rollover, en utilisant le VWAP (Volume Weighted Average Price) sur une journée comme prix de rollover.",
    "crumbs": [
      "Projets Introduction à Python - Millésime 2024"
    ]
  },
  {
    "objectID": "content/Projets/L3_EIF_2024.html#introduction",
    "href": "content/Projets/L3_EIF_2024.html#introduction",
    "title": "Projets Introduction à Python - Millésime 2024",
    "section": "",
    "text": "Dans le cadre de votre formation en L3 Économie et Ingénierie Financière, une série de sujets de projets vous sont proposés. Ces projets visent à consolider vos connaissances théoriques et à développer vos compétences pratiques. Ces projets sont conçus pour renforcer vos connaissances théoriques tout en développant vos compétences pratiques. Ils représentent une occasion précieuse de vous préparer aux défis réels que vous rencontrerez dans votre future carrière professionnelle.\nVous êtes encouragés à choisir un sujet qui correspond à vos intérêts personnels et à vos aspirations professionnelles. Les thèmes proposés couvrent une variété de domaines, reflétant ainsi les diverses opportunités qui pourraient se présenter à vous dans le futur. Ils ont été soigneusement sélectionnés pour leur pertinence pratique et leur valeur pédagogique.\nNéanmoins, cette liste de sujets n’est pas exhaustive. Vous êtes libres et même encouragés à proposer vos propres idées de projets. Vos suggestions peuvent être envoyées par mail pour validation, afin de s’assurer de leur faisabilité et de leur adéquation avec les objectifs du cours. Bien que ce soit principalement un cours de programmation, les projets qui s’éloignent du domaine financier tout en intégrant les concepts abordés en cours sont également bienvenus.\nLa date limite de soumission des projets est fixée au 28 avril. Veuillez noter qu’un malus pour retard de soumission sera appliqué selon la formule suivante : (((x/25) - 1) %), où (x) représente le nombre de jours de retard.\nLes projets doivent être soumis par mail à remi.gnt@gmail.com. Il est préférable d’envoyer votre travail sous forme de fichier zip, mais un lien vers un Google Drive est également acceptable. Veuillez éviter les plateformes d’envoi telles que WeTransfer, qui ont une durée de téléchargement limitée.\nDe plus, il est vivement conseillé de soumettre votre projet via GitHub. Envoyer un simple mail avec un lien vers votre projet GitHub ou m’inviter à rejoindre votre dépôt (username GitHub : remigenet) peut vous faire bénéficier de points bonus. Un point bonus sera attribué à chaque groupe soumettant sur GitHub, et deux points supplémentaires si l’utilisation de GitHub montre un travail d’équipe effectif tout au long du projet. Pour faciliter l’organisation, j’ai créé un espace sur GitHub pour regrouper les projets : https://github.com/L3-EIF-2023. Vous pouvez demander à être ajouté à cette organisation et y déposer votre projet.\nCe projet est également une excellente opportunité d’enrichir votre CV. Un travail de qualité, rendu public sur votre compte GitHub, démontre non seulement vos compétences en programmation, mais aussi votre capacité à travailler en équipe. Pour ceux qui cherchent bientôt une alternance, c’est un avantage considérable.\nEnfin, le poids du projets dans la note finale sera de 75% à 100%, en effet le QCM de cours ne sera pris en compte que si la note est supérieure à la note du projet.",
    "crumbs": [
      "Projets Introduction à Python - Millésime 2024"
    ]
  },
  {
    "objectID": "content/Projets/L3_EIF_2024.html#sujet-a-analyse-de-contrat-perpétuel-vs-spot-pour-position-longue",
    "href": "content/Projets/L3_EIF_2024.html#sujet-a-analyse-de-contrat-perpétuel-vs-spot-pour-position-longue",
    "title": "Projets Introduction à Python - Millésime 2024",
    "section": "",
    "text": "Dans le domaine des contrats dérivés, il est essentiel de comprendre que chaque contrat, qu’il s’agisse d’un future, d’un perpétuel, d’une option ou de toute autre structure plus exotique, représente un engagement entre deux parties. La valeur et, par conséquent, le prix d’échange de ces contrats sont déterminés par les termes et conditions spécifiques qu’ils contiennent.\n\nContrat Perpétuel vs Spot :\n\nContrat Perpétuel : Ce type de contrat à terme, couramment utilisé dans les marchés de dérivés et en particulier dans les crypto-monnaies, se distingue des contrats à terme traditionnels par l’absence de date d’expiration. Son objectif principal est de suivre le prix du marché au comptant (spot). Pour ce faire, il utilise des taux de financement qui ajustent régulièrement son prix afin de le maintenir aligné avec le marché spot.\nTaux de Financement : Ces taux jouent un rôle crucial dans la garantie que le prix du contrat perpétuel reste en adéquation avec le marché au comptant. Leur valeur peut varier, devenant positive ou négative en fonction de la dynamique du marché, notamment en situations de contango ou de backwardation.\nMarché Spot : Il s’agit du marché où les actifs, comme le Bitcoin, sont échangés pour une livraison immédiate. La fongibilité de ce marché entre les différentes plateformes d’échange permet une grande flexibilité dans l’achat et la vente d’actifs.\n\nPosition Longue sur Contrat Dérivé : Prendre une position longue dans un contrat dérivé signifie s’engager à acheter un actif, basé sur la spéculation que la valeur de l’actif sous-jacent augmentera. Cette position est différente de l’achat direct d’actifs sur le marché spot.\nCollatéral et Haircut :\n\nLe collatéral est un élément clé dans la sécurisation des positions prises dans les contrats dérivés. Sa proportion requise peut varier selon la taille et le risque de la position.\nLe terme “haircut” appliqué au collatéral non-USD fait référence à la réduction de la valeur du collatéral pour compenser le risque de change associé.\n\n\nEn résumé, la valeur intrinsèque d’un contrat dérivé découle des conditions spécifiques qu’il impose, avec le contrat perpétuel servant d’exemple principal où les taux de financement sont les clauses permettant de synchroniser son prix avec celui du marché spot.\n\n\n\nL’objectif principal est de comparer les coûts d’une position longue sur un contrat perpétuel avec ceux de l’achat direct de l’actif sur le marché spot. Les aspects suivants seront pris en compte :\n\nPour 2 Personnes :\n\nCalcul sous l’hypothèse d’un besoin en liquidité équivalent à 25% en tant que collatéral (marge initiale). La comparaison inclura les éventuelles différences de prix entre le contrat perpétuel et le marché spot lors de l’ouverture et de la fermeture de la position, en tenant compte des taux de financement historiques.\n\nPour 3 Personnes :\n\nIntégration des contraintes de couverture (en se basant sur celles d’une plateforme d’échange spécifique), avec une analyse des variations des exigences en collatéral en fonction de la taille de la position. Il sera également pris en compte le fait que la position sur le marché spot ne peut pas couvrir la position future, ainsi que les coûts de financement pour les USD engagés.\n\nPour 4 Personnes :\n\nLa récupération des données doit être intégrée dans les classes développées, avec la mise en œuvre d’un système de cache pour optimiser l’efficacité du traitement des données. L’objectif est de rendre l’utilisation de la classe aussi simple que possible pour l’utilisateur.\n\nPour 5 Personnes :\n\nAnalyse de la stratégie de cash and carry en utilisant un contrat perpétuel.\nStratégie de Cash and Carry avec Contrat Perpétuel : Cette approche implique la comparaison entre l’achat d’un actif sur le marché spot et sa vente simultanée via un contrat perpétuel, en comprenant les risques potentiels associés à cette stratégie.\n\nPour 6-7 Personnes :\n\nEn tenant compte de tous les éléments mentionnés précédemment, y compris les contraintes de collatéral imposées par l’exchange et un montant initial en dollars qui ne peut être augmenté, réaliser un backtest de la stratégie de cash and carry. Ce test prendra en compte la taille initiale de la position, qui dépendra du levier choisi initialement. En cas de rapprochement de la position courte sur le contrat perpétuel de sa marge de maintenance, simuler une réduction des positions par vente partielle sur le marché spot (réalisation des plus-values) et un rachat partiel sur le contrat dérivé (réalisation des moins-values), en utilisant un prix de clôture pour les deux positions basé sur le VWAP (Volume Weighted Average Price) sur une période où la participation au volume ne dépasse pas 10% du volume total.",
    "crumbs": [
      "Projets Introduction à Python - Millésime 2024"
    ]
  },
  {
    "objectID": "content/Projets/L3_EIF_2024.html#sujet-b-introduction-aux-concepts-clés-du-projet-de-backtester-pour-stratégies-dinvestissement",
    "href": "content/Projets/L3_EIF_2024.html#sujet-b-introduction-aux-concepts-clés-du-projet-de-backtester-pour-stratégies-dinvestissement",
    "title": "Projets Introduction à Python - Millésime 2024",
    "section": "",
    "text": "Un backtest est une méthode utilisée dans le domaine de la finance pour évaluer la viabilité et la performance d’une stratégie d’investissement. Cette technique implique de simuler la manière dont une stratégie aurait performé en utilisant des données historiques. Le but est de fournir un aperçu de la façon dont une stratégie aurait réagi dans différentes conditions de marché passées.\n\n\n\nÉvaluation des Stratégies : Le backtest permet aux traders et aux investisseurs de tester leurs stratégies sur des données passées avant de les appliquer dans des conditions réelles de marché. C’est un outil essentiel pour identifier les forces et les faiblesses d’une stratégie avant son déploiement.\nRéduction des Risques : En testant une stratégie sur des données historiques, les investisseurs peuvent mieux comprendre et gérer les risques potentiels.\nOptimisation des Stratégies : Les résultats d’un backtest peuvent être utilisés pour affiner et améliorer une stratégie, en ajustant ses paramètres pour maximiser les rendements potentiels.\n\n\n\n\nBien que le backtest soit un outil puissant, il est important de reconnaître ses limites. Les résultats d’un backtest sont toujours basés sur des hypothèses et des simulations, et ne peuvent garantir des performances futures. Les limitations clés incluent :\n\nHypothèses de Simulation : Un backtest repose sur des hypothèses qui peuvent ne pas être entièrement représentatives des conditions réelles du marché.\nBiais de Survie : Les données historiques peuvent exclure les actifs ou stratégies qui ont échoué dans le passé, conduisant à une perception faussée de la performance.\nChangements du Marché : Les conditions de marché évoluent constamment, et une stratégie qui a réussi dans le passé pourrait ne pas être aussi efficace dans le futur en raison de changements dans les dynamiques du marché.\n\n\n\n\nDévelopper un backtester sous forme de classe, qui utilise une fonction prenant en entrée un historique de barres OHLCV (Open, High, Low, Close, Volume) et renvoyant la position d’une stratégie d’investissement.\n\n\n\n\n\nPour 2 Personnes :\n\nStockage Local des Données : Les données seront stockées localement et incluses dans le projet pour faciliter les tests.\nAnalyse d’Un Actif : Le backtester se concentrera sur un seul actif avec des positions variant entre -100% et 100%.\nRésultats : Génération d’un graphique représentant la performance de la stratégie sur la période choisie, accompagné de statistiques de base telles que le rendement moyen, la variance, et le bêta.\n\nPour 3 Personnes (Option A) :\n\nStratégie sur Plusieurs Actifs : Extension du backtester pour accepter une fonction de stratégie applicable à plusieurs actifs.\nStatistiques Avancées : Calcul de statistiques plus élaborées comme le bêta en hausse et en baisse, le drawdown maximal, s’inspirant de sources telles que Quantalys ou Morningstar.\n\nOU\nPour 3 Personnes (Option B) :\n\nTéléchargement et Cache Asynchrone : Mise en place d’un système pour le téléchargement et le stockage en cache des données de manière asynchrone.\n\nPour 4 Personnes :\n\nCombinaison des points mentionnés dans les options pour 3 personnes (Option A et B).\n\nPour 5 Personnes :\n\nIntégration des Crypto-monnaies : Ajout de la capacité à analyser les stratégies impliquant des contrats dérivés perpétuels ou futurs.\nSpécificités des Dérivés :\n\nPour les contrats perpétuels, le calcul inclura le coût du taux de financement.\nPour les contrats futurs, le calcul se basera sur le rollover, en utilisant le VWAP (Volume Weighted Average Price) sur une journée comme prix de rollover.",
    "crumbs": [
      "Projets Introduction à Python - Millésime 2024"
    ]
  },
  {
    "objectID": "content/Projets/L3_EIF_2024.html#quest-ce-quun-carnet-dordres",
    "href": "content/Projets/L3_EIF_2024.html#quest-ce-quun-carnet-dordres",
    "title": "Projets Introduction à Python - Millésime 2024",
    "section": "Qu’est-ce qu’un Carnet d’Ordres ?",
    "text": "Qu’est-ce qu’un Carnet d’Ordres ?\nUn carnet d’ordres est un outil essentiel dans le fonctionnement des marchés financiers, particulièrement dans les marchés électroniques. Il représente une liste organisée d’ordres d’achat et de vente pour un actif spécifique, montrant la profondeur de marché et les niveaux de prix auxquels les participants sont prêts à acheter ou vendre.\n\nImportance du Carnet d’Ordres\n\nTransparence du Marché : Le carnet d’ordres offre une vue transparente sur la liquidité du marché, les intérêts d’achat et de vente, et aide à déterminer le prix de marché actuel d’un actif.\nDécisions de Trading : Les traders utilisent les informations du carnet d’ordres pour prendre des décisions éclairées, en analysant la profondeur du marché et les tendances des ordres.\n\n\n\nMarchés Électroniques\nDans les marchés électroniques modernes, les carnets d’ordres sont entièrement numérisés. Ils permettent un traitement rapide des ordres et une mise à jour en temps réel, ce qui est crucial pour la dynamique rapide des marchés financiers actuels.\n\n\nLe Fixing\nLe fixing est un processus utilisé pour déterminer les prix d’ouverture et de fermeture des actifs sur les marchés financiers. Il est particulièrement important dans les marchés où le trading n’est pas continu, comme certains marchés européens. Le fixing garantit un prix équitable basé sur l’ensemble des ordres disponibles à un moment donné.\n\n\nConcepts Clés à Explorer dans le Projet\n\nTick et Lot :\n\nTick : C’est le plus petit mouvement de prix possible pour un actif. Il joue un rôle crucial dans la détermination des variations de prix dans le carnet d’ordres.\nLot : Représente la quantité minimale ou un multiple d’un actif pouvant être échangé. Cela affecte la façon dont les ordres sont placés et exécutés dans le carnet d’ordres.\n\nRôles de Maker et Taker :\n\nMaker : Un participant du marché qui fournit de la liquidité en plaçant des ordres qui ne sont pas immédiatement exécutés (ordres limites).\nTaker : Un participant qui retire de la liquidité en exécutant immédiatement contre des ordres existants (ordres au marché).\n\n\n\n\nObjectifs et Applications du Projet\n\nPour 2 Personnes :\n\nDéveloppement d’une Classe : Création d’une classe en programmation permettant l’ajout et l’annulation d’ordres par participant, respectant les principes d’un carnet d’ordres continu.\nExemple d’Utilisation : Fournir un exemple concret d’utilisation de la classe.\n\nPour 3 Personnes :\n\nSystème de Fixing : Ajout d’un mécanisme de fixing efficace pour simuler les fixings d’ouverture et de fermeture, comme cela se fait sur les marchés européens.\n\nPour 4 Personnes :\n\nRécupération de Snapshot : Intégration d’une fonctionnalité pour récupérer automatiquement un instantané (snapshot) du carnet d’ordres de Binance et utiliser cet état comme point de départ dans la classe.\n\nPour 5 Personnes :\n\nSimulation du Carnet d’Ordres : Création de simulations basées sur des distributions de probabilité pour prédire l’évolution du carnet d’ordres dans les secondes ou minutes suivantes.\n\nPour 6 Personnes :\n\nOptimisation du Placement des Ordres : Utilisation de la classe développée pour déterminer le meilleur prix pour un ordre en tenant compte des frais de transaction pour les positions maker et taker.\n\nPour 7 Personnes :\n\nAnalyse de l’Impact du Spread et des Frais : Étude de l’effet du spread et des frais sur le placement optimal des ordres.",
    "crumbs": [
      "Projets Introduction à Python - Millésime 2024"
    ]
  },
  {
    "objectID": "content/Projets/L3_EIF_2024.html#sujet-d-option-et-volatilité-sur-les-crypto-monnaies",
    "href": "content/Projets/L3_EIF_2024.html#sujet-d-option-et-volatilité-sur-les-crypto-monnaies",
    "title": "Projets Introduction à Python - Millésime 2024",
    "section": "Sujet D : Option et Volatilité sur les Crypto-monnaies",
    "text": "Sujet D : Option et Volatilité sur les Crypto-monnaies",
    "crumbs": [
      "Projets Introduction à Python - Millésime 2024"
    ]
  },
  {
    "objectID": "content/Projets/L3_EIF_2024.html#concepts-clés-à-explorer-dans-le-projet-sur-les",
    "href": "content/Projets/L3_EIF_2024.html#concepts-clés-à-explorer-dans-le-projet-sur-les",
    "title": "Projets Introduction à Python - Millésime 2024",
    "section": "Concepts Clés à Explorer dans le Projet sur les",
    "text": "Concepts Clés à Explorer dans le Projet sur les\n\n1. Volatilité Implicite\nLa volatilité implicite est un concept fondamental dans le monde des options. Elle représente les attentes du marché concernant la volatilité future de l’actif sous-jacent à l’option. Crucialement, la volatilité implicite n’est pas directement observable ; elle est plutôt déduite du prix actuel de l’option en utilisant des modèles de tarification. Cela la rend distincte de la volatilité historique, qui est basée sur les variations passées du prix de l’actif. Comprendre la volatilité implicite est vital pour évaluer correctement le prix d’une option et anticiper les mouvements potentiels du marché.\n\n\n2. Stratégie de Vente d’Options\nLa vente d’options implique une série de décisions stratégiques basées sur la volatilité et les attentes du marché. En vendant une option, le vendeur assume l’obligation de vendre (dans le cas d’un call) ou d’acheter (dans le cas d’un put) l’actif sous-jacent à un prix déterminé (strike price), si l’acheteur de l’option choisit de l’exercer. Les vendeurs d’options doivent évaluer soigneusement le niveau approprié de volatilité implicite et le prix de l’option pour gérer le risque et maximiser le profit. Ils doivent également tenir compte de la probabilité que l’option soit exercée et des conséquences potentielles sur leur portefeuille d’investissement.\n\n\n3. Modèle de Black-Scholes et Simulations de Monte Carlo\nLe modèle de Black-Scholes est une formule mathématique célèbre pour déterminer le prix théorique des options d’achat et de vente. Ce modèle prend en compte divers facteurs, notamment le prix actuel de l’actif sous-jacent, le prix d’exercice de l’option (strike price), le temps restant jusqu’à l’échéance, la volatilité de l’actif sous-jacent et le taux d’intérêt sans risque. En parallèle, les simulations de Monte Carlo sont des techniques utilisées pour modéliser et comprendre le comportement des options dans divers scénarios de marché. Ces simulations permettent de générer une gamme de résultats potentiels en variant les entrées (comme la volatilité et les taux de mouvement des prix) pour évaluer la probabilité de différents résultats et mieux comprendre les risques et opportunités associés à une option donnée.\n\n\nObjectifs et Applications du Projet\n\nPour 2 Personnes :\n\n\nCréation d’une Classe pour le Calcul du Prix d’Option :\n\nObjectif : Développer une classe capable de calculer le prix d’une option en fonction de sa volatilité implicite, du strike price, du dernier prix, et de l’échéance. Le taux sans risque sera considéré comme étant de 0%.\nMéthodes d’Implémentation : Intégrer la méthode de Black-Scholes pour la tarification des options et effectuer des simulations de Monte Carlo pour analyser divers scénarios de marché.\n\n\n\nPour 3 Personnes :\n\n\nSimulation du PnL d’un Vendeur d’Options :\n\nUtiliser des données historiques d’au moins un an pour simuler le PnL (Profit and Loss) d’un participant vendant des calls et des puts. Explorer différentes approches de volatilité, incluant la volatilité historique constante, la volatilité sur une fenêtre glissante, et la valeur absolue du rendement sur la période précédente.\nHypothèses de Backtest : Consistera à vendre ou acheter le même montant notionnel tous les jours, en fixant les strike prices à un pourcentage spécifique du prix courant de l’actif.\n\n\n\nPour 4 Personnes :\n\n\nMeilleur Prix et Performance :\n\nRépéter la simulation de PnL en ajoutant un élément de compétition pour déterminer qui offre le meilleur prix chaque jour. Analyser et comparer les performances en fonction des prix proposés.\n\n\n\nPour 5 Personnes :\n\n\nAnalyse Avancée de la Volatilité :\n\nRéaliser une analyse approfondie de la volatilité, en utilisant des méthodes statistiques, économétriques ou de machine learning. Examiner des facteurs tels que la saisonnalité hebdomadaire, l’autorégressivité, et effectuer des régressions linéaires en corrélation avec d’autres actifs financiers.\n\n\n\nPour 6 Personnes :\n\n\nPerformance dans un Environnement Concurrentiel :\n\nAppliquer et tester la stratégie développée dans un contexte de marché simulé avec d’autres participants fictifs. Analyser la performance de la stratégie en considérant soit un investissement fixe de 10 000 $, soit en utilisant une approche d’intérêts composés avec réinvestissement des gains ou des pertes.",
    "crumbs": [
      "Projets Introduction à Python - Millésime 2024"
    ]
  },
  {
    "objectID": "content/Cours_3/3-MachineLearning.html",
    "href": "content/Cours_3/3-MachineLearning.html",
    "title": "Machine Learning",
    "section": "",
    "text": "Python est devenu la langue de prédilection pour le machine learning (ML) en raison de sa simplicité, de sa richesse en bibliothèques, et de sa communauté active. Des bibliothèques comme Scikit-learn, TensorFlow, et PyTorch facilitent la mise en œuvre de diverses techniques de ML.\n\n\n\n\nScikit-learn est une bibliothèque Python polyvalente pour le machine learning. Elle offre des outils simples et efficaces pour l’analyse de données et la modélisation statistique.\nFonctionnalités clés :\n\nClassification, Régression, et Clustering: Algorithmes pour les tâches de ML les plus courantes.\nPrétraitement des Données: Outils pour normaliser, échelonner, et transformer les données.\nSélection de Modèles et Validation Croisée: Méthodes pour choisir les meilleurs modèles et paramètres.\n\n\n\n\n\n\nClassification avec Scikit-learn:\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nTensorFlow et PyTorch sont des bibliothèques plus spécialisées, offrant des fonctionnalités avancées pour les réseaux de neurones profonds et l’apprentissage automatique à grande échelle.\nElles sont particulièrement adaptées pour :\n\nRéseaux de Neurones Profonds: Construction et entraînement de modèles complexes.\nTraitement de Données à Grande Échelle: Gestion efficace des ensembles de données volumineux.\nPersonnalisation et Recherche: Flexibilité pour expérimenter de nouvelles idées en ML.\n\n\n\n\n\n\nObjectif: Se familiariser avec le processus de base du machine learning en utilisant Scikit-learn.\nÉnoncé: Utilisez Scikit-learn pour construire un classificateur simple sur un jeu de données standard, évaluez ses performances, et essayez d’améliorer ses résultats en ajustant les paramètres.\nSolution:\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nLe machine learning en Python offre un éventail impressionnant d’outils et de techniques pour l’analyse de données, la prédiction, et la compréhension des modèles complexes. Que vous débutiez avec Scikit-learn ou que vous plongiez dans des modèles plus avancés avec TensorFlow ou PyTorch, Python a les ressources pour répondre à vos besoins en ML.\n\n\n\n\n\n\n\nStatsmodels est une bibliothèque Python spécialisée dans les modèles statistiques et l’économétrie. Elle est particulièrement utile pour les analyses statistiques traditionnelles.\nFonctionnalités clés de Statsmodels :\n\nRégressions Linéaires et Logistiques: Outils pour modéliser les relations entre variables.\nTests Statistiques: Tests pour valider les hypothèses sur les données.\nExploration de Séries Temporelles: Outils pour analyser les données dépendant du temps.\n\n\n\n\n\n\nPyTorch est une bibliothèque d’apprentissage profond très appréciée dans la communauté de recherche en raison de sa flexibilité et de sa facilité d’utilisation.\nAspects saillants de PyTorch :\n\nAutograd: Système de différenciation automatique pour le calcul des gradients.\nRéseaux de Neurones Personnalisés: Facilité de création et d’expérimentation avec de nouveaux modèles.\nPerformances en Temps Réel: Optimisé pour les calculs sur GPU, idéal pour l’entraînement de modèles complexes.\n\n\n\n\n\n\nTensorFlow est une bibliothèque développée par Google, largement utilisée pour des applications d’apprentissage automatique complexes, en particulier celles nécessitant une grande échelle de calcul.\nCaractéristiques principales de TensorFlow :\n\nArchitecture Flexible: Convient à la fois pour la recherche et la production.\nTensorBoard: Outil pour la visualisation et le monitoring des modèles.\nTFLite pour les Applications Mobiles et Embarquées: Permet de déployer des modèles ML sur des appareils mobiles.\n\n\n\n\n\n\nObjectif: Se familiariser avec l’apprentissage profond en utilisant PyTorch ou TensorFlow.\nÉnoncé: Construisez et entraînez un réseau de neurones simple pour classifier des images à partir d’un jeu de données standard comme MNIST.\nSolution (avec PyTorch) :\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nL’écosystème du machine learning en Python est riche et varié, offrant des outils adaptés à une large gamme de besoins, de l’analyse statistique traditionnelle avec Statsmodels à l’apprentissage profond avec PyTorch et TensorFlow. Chaque outil a ses propres forces, et le choix dépend des objectifs spécifiques du projet, de l’expertise de l’utilisateur, et du contexte d’application.",
    "crumbs": [
      "Machine Learning"
    ]
  },
  {
    "objectID": "content/Cours_3/3-MachineLearning.html#introduction-au-machine-learning-avec-python",
    "href": "content/Cours_3/3-MachineLearning.html#introduction-au-machine-learning-avec-python",
    "title": "Machine Learning",
    "section": "",
    "text": "Python est devenu la langue de prédilection pour le machine learning (ML) en raison de sa simplicité, de sa richesse en bibliothèques, et de sa communauté active. Des bibliothèques comme Scikit-learn, TensorFlow, et PyTorch facilitent la mise en œuvre de diverses techniques de ML.",
    "crumbs": [
      "Machine Learning"
    ]
  },
  {
    "objectID": "content/Cours_3/3-MachineLearning.html#scikit-learn-un-point-de-départ-pour-le-machine-learning",
    "href": "content/Cours_3/3-MachineLearning.html#scikit-learn-un-point-de-départ-pour-le-machine-learning",
    "title": "Machine Learning",
    "section": "",
    "text": "Scikit-learn est une bibliothèque Python polyvalente pour le machine learning. Elle offre des outils simples et efficaces pour l’analyse de données et la modélisation statistique.\nFonctionnalités clés :\n\nClassification, Régression, et Clustering: Algorithmes pour les tâches de ML les plus courantes.\nPrétraitement des Données: Outils pour normaliser, échelonner, et transformer les données.\nSélection de Modèles et Validation Croisée: Méthodes pour choisir les meilleurs modèles et paramètres.",
    "crumbs": [
      "Machine Learning"
    ]
  },
  {
    "objectID": "content/Cours_3/3-MachineLearning.html#exemple-dutilisation-de-scikit-learn",
    "href": "content/Cours_3/3-MachineLearning.html#exemple-dutilisation-de-scikit-learn",
    "title": "Machine Learning",
    "section": "",
    "text": "Classification avec Scikit-learn:\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Machine Learning"
    ]
  },
  {
    "objectID": "content/Cours_3/3-MachineLearning.html#tensorflow-et-pytorch-pour-des-applications-plus-avancées",
    "href": "content/Cours_3/3-MachineLearning.html#tensorflow-et-pytorch-pour-des-applications-plus-avancées",
    "title": "Machine Learning",
    "section": "",
    "text": "TensorFlow et PyTorch sont des bibliothèques plus spécialisées, offrant des fonctionnalités avancées pour les réseaux de neurones profonds et l’apprentissage automatique à grande échelle.\nElles sont particulièrement adaptées pour :\n\nRéseaux de Neurones Profonds: Construction et entraînement de modèles complexes.\nTraitement de Données à Grande Échelle: Gestion efficace des ensembles de données volumineux.\nPersonnalisation et Recherche: Flexibilité pour expérimenter de nouvelles idées en ML.",
    "crumbs": [
      "Machine Learning"
    ]
  },
  {
    "objectID": "content/Cours_3/3-MachineLearning.html#exercice-pratique",
    "href": "content/Cours_3/3-MachineLearning.html#exercice-pratique",
    "title": "Machine Learning",
    "section": "",
    "text": "Objectif: Se familiariser avec le processus de base du machine learning en utilisant Scikit-learn.\nÉnoncé: Utilisez Scikit-learn pour construire un classificateur simple sur un jeu de données standard, évaluez ses performances, et essayez d’améliorer ses résultats en ajustant les paramètres.\nSolution:\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Machine Learning"
    ]
  },
  {
    "objectID": "content/Cours_3/3-MachineLearning.html#conclusion",
    "href": "content/Cours_3/3-MachineLearning.html#conclusion",
    "title": "Machine Learning",
    "section": "",
    "text": "Le machine learning en Python offre un éventail impressionnant d’outils et de techniques pour l’analyse de données, la prédiction, et la compréhension des modèles complexes. Que vous débutiez avec Scikit-learn ou que vous plongiez dans des modèles plus avancés avec TensorFlow ou PyTorch, Python a les ressources pour répondre à vos besoins en ML.",
    "crumbs": [
      "Machine Learning"
    ]
  },
  {
    "objectID": "content/Cours_3/3-MachineLearning.html#statsmodels-analyse-statistique-en-python",
    "href": "content/Cours_3/3-MachineLearning.html#statsmodels-analyse-statistique-en-python",
    "title": "Machine Learning",
    "section": "",
    "text": "Statsmodels est une bibliothèque Python spécialisée dans les modèles statistiques et l’économétrie. Elle est particulièrement utile pour les analyses statistiques traditionnelles.\nFonctionnalités clés de Statsmodels :\n\nRégressions Linéaires et Logistiques: Outils pour modéliser les relations entre variables.\nTests Statistiques: Tests pour valider les hypothèses sur les données.\nExploration de Séries Temporelles: Outils pour analyser les données dépendant du temps.",
    "crumbs": [
      "Machine Learning"
    ]
  },
  {
    "objectID": "content/Cours_3/3-MachineLearning.html#pytorch-apprentissage-profond-et-recherche",
    "href": "content/Cours_3/3-MachineLearning.html#pytorch-apprentissage-profond-et-recherche",
    "title": "Machine Learning",
    "section": "",
    "text": "PyTorch est une bibliothèque d’apprentissage profond très appréciée dans la communauté de recherche en raison de sa flexibilité et de sa facilité d’utilisation.\nAspects saillants de PyTorch :\n\nAutograd: Système de différenciation automatique pour le calcul des gradients.\nRéseaux de Neurones Personnalisés: Facilité de création et d’expérimentation avec de nouveaux modèles.\nPerformances en Temps Réel: Optimisé pour les calculs sur GPU, idéal pour l’entraînement de modèles complexes.",
    "crumbs": [
      "Machine Learning"
    ]
  },
  {
    "objectID": "content/Cours_3/3-MachineLearning.html#tensorflow-machine-learning-à-grande-échelle",
    "href": "content/Cours_3/3-MachineLearning.html#tensorflow-machine-learning-à-grande-échelle",
    "title": "Machine Learning",
    "section": "",
    "text": "TensorFlow est une bibliothèque développée par Google, largement utilisée pour des applications d’apprentissage automatique complexes, en particulier celles nécessitant une grande échelle de calcul.\nCaractéristiques principales de TensorFlow :\n\nArchitecture Flexible: Convient à la fois pour la recherche et la production.\nTensorBoard: Outil pour la visualisation et le monitoring des modèles.\nTFLite pour les Applications Mobiles et Embarquées: Permet de déployer des modèles ML sur des appareils mobiles.",
    "crumbs": [
      "Machine Learning"
    ]
  },
  {
    "objectID": "content/Cours_3/3-MachineLearning.html#exercice-pratique-avec-pytorch-ou-tensorflow",
    "href": "content/Cours_3/3-MachineLearning.html#exercice-pratique-avec-pytorch-ou-tensorflow",
    "title": "Machine Learning",
    "section": "",
    "text": "Objectif: Se familiariser avec l’apprentissage profond en utilisant PyTorch ou TensorFlow.\nÉnoncé: Construisez et entraînez un réseau de neurones simple pour classifier des images à partir d’un jeu de données standard comme MNIST.\nSolution (avec PyTorch) :\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Machine Learning"
    ]
  },
  {
    "objectID": "content/Cours_3/3-MachineLearning.html#conclusion-1",
    "href": "content/Cours_3/3-MachineLearning.html#conclusion-1",
    "title": "Machine Learning",
    "section": "",
    "text": "L’écosystème du machine learning en Python est riche et varié, offrant des outils adaptés à une large gamme de besoins, de l’analyse statistique traditionnelle avec Statsmodels à l’apprentissage profond avec PyTorch et TensorFlow. Chaque outil a ses propres forces, et le choix dépend des objectifs spécifiques du projet, de l’expertise de l’utilisateur, et du contexte d’application.",
    "crumbs": [
      "Machine Learning"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Dataframes.html",
    "href": "content/Cours_3/1-Dataframes.html",
    "title": "Les DataFrames",
    "section": "",
    "text": "Un dataframe est une structure de données bidimensionnelle, similaire à une feuille de calcul ou une table de base de données. Ils sont extrêmement utiles pour la manipulation et l’analyse de données structurées. En Python, la bibliothèque la plus courante pour travailler avec des dataframes est Pandas.\n\n\n\n\nManipulation de données: Pandas offre des fonctionnalités puissantes pour nettoyer, transformer et analyser les données.\nFacilité d’utilisation: Avec une API intuitive, Pandas permet une prise en main rapide pour les nouveaux utilisateurs.\nIntégration avec d’autres bibliothèques: Pandas se combine bien avec des bibliothèques pour la visualisation (comme Matplotlib) et le calcul scientifique (comme NumPy).\n\n\n\n\n\nInstallation:\n\npip install pandas\n\nImportation et Création d’un Dataframe:\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nOpérations de Base:\n\nAfficher les données: print(df) ou Display(df) (dans un notebook - affiche un tableau de façon plus lisible. Il faut importer from IPython.display import display)\nAccéder aux colonnes: df['Nom']\nFiltrage: df[df['Age'] &gt; 30]\n\n\n\n\n\n\nObjectif: Créer un dataframe, ajouter des données, puis les filtrer.\nÉnoncé: Vous avez une liste de noms et d’âges. Créez un dataframe, ajoutez une colonne ‘Profession’, puis filtrez pour afficher seulement les personnes de plus de 30 ans.\nSolution:\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nLes dataframes, via la bibliothèque Pandas, sont des outils essentiels en Python pour la manipulation de données. Leur simplicité et leur puissance en font un choix privilégié pour les data scientists et les analystes de données.",
    "crumbs": [
      "Les DataFrames"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Dataframes.html#introduction-aux-dataframes",
    "href": "content/Cours_3/1-Dataframes.html#introduction-aux-dataframes",
    "title": "Les DataFrames",
    "section": "",
    "text": "Un dataframe est une structure de données bidimensionnelle, similaire à une feuille de calcul ou une table de base de données. Ils sont extrêmement utiles pour la manipulation et l’analyse de données structurées. En Python, la bibliothèque la plus courante pour travailler avec des dataframes est Pandas.",
    "crumbs": [
      "Les DataFrames"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Dataframes.html#pourquoi-utiliser-pandas-pour-les-dataframes",
    "href": "content/Cours_3/1-Dataframes.html#pourquoi-utiliser-pandas-pour-les-dataframes",
    "title": "Les DataFrames",
    "section": "",
    "text": "Manipulation de données: Pandas offre des fonctionnalités puissantes pour nettoyer, transformer et analyser les données.\nFacilité d’utilisation: Avec une API intuitive, Pandas permet une prise en main rapide pour les nouveaux utilisateurs.\nIntégration avec d’autres bibliothèques: Pandas se combine bien avec des bibliothèques pour la visualisation (comme Matplotlib) et le calcul scientifique (comme NumPy).",
    "crumbs": [
      "Les DataFrames"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Dataframes.html#utilisation-de-base-de-pandas",
    "href": "content/Cours_3/1-Dataframes.html#utilisation-de-base-de-pandas",
    "title": "Les DataFrames",
    "section": "",
    "text": "Installation:\n\npip install pandas\n\nImportation et Création d’un Dataframe:\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nOpérations de Base:\n\nAfficher les données: print(df) ou Display(df) (dans un notebook - affiche un tableau de façon plus lisible. Il faut importer from IPython.display import display)\nAccéder aux colonnes: df['Nom']\nFiltrage: df[df['Age'] &gt; 30]",
    "crumbs": [
      "Les DataFrames"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Dataframes.html#exercice-pratique",
    "href": "content/Cours_3/1-Dataframes.html#exercice-pratique",
    "title": "Les DataFrames",
    "section": "",
    "text": "Objectif: Créer un dataframe, ajouter des données, puis les filtrer.\nÉnoncé: Vous avez une liste de noms et d’âges. Créez un dataframe, ajoutez une colonne ‘Profession’, puis filtrez pour afficher seulement les personnes de plus de 30 ans.\nSolution:\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Les DataFrames"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Dataframes.html#conclusion",
    "href": "content/Cours_3/1-Dataframes.html#conclusion",
    "title": "Les DataFrames",
    "section": "",
    "text": "Les dataframes, via la bibliothèque Pandas, sont des outils essentiels en Python pour la manipulation de données. Leur simplicité et leur puissance en font un choix privilégié pour les data scientists et les analystes de données.",
    "crumbs": [
      "Les DataFrames"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Dataframes.html#manipulation-de-grandes-données",
    "href": "content/Cours_3/1-Dataframes.html#manipulation-de-grandes-données",
    "title": "Les DataFrames",
    "section": "Manipulation de Grandes Données",
    "text": "Manipulation de Grandes Données\nQuand on travaille avec de grands ensembles de données, il est crucial de savoir comment gérer efficacement la mémoire et le temps de traitement.\n\nLecture par morceaux: Pandas permet de lire de grandes données par morceaux, ce qui réduit la consommation de mémoire.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nOptimisation des types de données: Parfois, changer le type de données d’une colonne peut réduire significativement l’utilisation de la mémoire.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Les DataFrames"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Dataframes.html#opérations-sur-les-colonnes-et-les-lignes",
    "href": "content/Cours_3/1-Dataframes.html#opérations-sur-les-colonnes-et-les-lignes",
    "title": "Les DataFrames",
    "section": "Opérations sur les Colonnes et les Lignes",
    "text": "Opérations sur les Colonnes et les Lignes\n\nAjout et suppression de colonnes:\n\nAjout: df['Nouvelle_Colonne'] = df['Colonne1'] + df['Colonne2']\nSuppression: df.drop('Colonne', axis=1, inplace=True)\n\nApplication de fonctions:\n\ndf['Colonne'].apply(lambda x: x * 2)",
    "crumbs": [
      "Les DataFrames"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Dataframes.html#exercice-pratique-avancé",
    "href": "content/Cours_3/1-Dataframes.html#exercice-pratique-avancé",
    "title": "Les DataFrames",
    "section": "Exercice Pratique Avancé",
    "text": "Exercice Pratique Avancé\n\nObjectif: Manipuler un grand fichier CSV et effectuer des opérations sur les colonnes.\nÉnoncé: Lisez un grand fichier CSV par morceaux. Pour chaque morceau, ajoutez une colonne ‘AgeDoubled’ qui est le double de la colonne ‘Age’, puis enregistrez chaque morceau modifié dans un nouveau fichier.\nSolution:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Les DataFrames"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Dataframes.html#conclusion-1",
    "href": "content/Cours_3/1-Dataframes.html#conclusion-1",
    "title": "Les DataFrames",
    "section": "Conclusion",
    "text": "Conclusion\nLa maîtrise des opérations avancées sur les dataframes est essentielle pour traiter efficacement des ensembles de données complexes. Les possibilités offertes par Pandas en font un outil incontournable pour la manipulation et l’analyse de données en Python.\n\nExemples Concrets d’Utilisation des Dataframes et Optimisation des Performances",
    "crumbs": [
      "Les DataFrames"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Dataframes.html#utilisation-dans-des-scénarios-réels",
    "href": "content/Cours_3/1-Dataframes.html#utilisation-dans-des-scénarios-réels",
    "title": "Les DataFrames",
    "section": "Utilisation dans des Scénarios Réels",
    "text": "Utilisation dans des Scénarios Réels\n\nAnalyse de Données: Les dataframes sont fréquemment utilisés pour l’analyse de données dans divers domaines, comme la finance, la recherche scientifique, et le marketing.\n\nExemple: Analyse des tendances de vente en e-commerce. On peut charger les données des transactions, calculer les métriques clés comme le chiffre d’affaires, et identifier les produits les plus vendus.\n\nTraitement de Données pour le Machine Learning: Avant de construire des modèles de machine learning, il est souvent nécessaire de nettoyer et de transformer les données.\n\nExemple: Préparation de données pour la prédiction de prix immobiliers. On peut utiliser les dataframes pour gérer des données manquantes, encoder des variables catégorielles, et normaliser les valeurs.\n\nRapports et Visualisation: Les dataframes se couplent bien avec des outils de visualisation pour créer des rapports et des graphiques.\n\nExemple: Création d’un rapport sur la performance des employés. On peut combiner des données issues de différentes sources, calculer des KPIs, et générer des graphiques pour la présentation.",
    "crumbs": [
      "Les DataFrames"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Dataframes.html#optimisation-des-performances",
    "href": "content/Cours_3/1-Dataframes.html#optimisation-des-performances",
    "title": "Les DataFrames",
    "section": "Optimisation des Performances",
    "text": "Optimisation des Performances\n\nUtilisation de Dask pour le Traitement Parallèle: Pour des ensembles de données très volumineux, Dask offre une solution de traitement parallèle compatible avec l’API de Pandas.\n\nimport dask.dataframe as dd\ndask_df = dd.from_pandas(pandas_df, npartitions=10)\n\nOptimisation du Code:\n\nUtiliser iterrows() et itertuples() pour itérer sur les dataframes de manière plus performante.\nPréférer les opérations vectorisées aux boucles lorsque c’est possible.",
    "crumbs": [
      "Les DataFrames"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Dataframes.html#exercice-pratique-de-synthèse",
    "href": "content/Cours_3/1-Dataframes.html#exercice-pratique-de-synthèse",
    "title": "Les DataFrames",
    "section": "Exercice Pratique de Synthèse",
    "text": "Exercice Pratique de Synthèse\n\nObjectif: Combiner plusieurs fichiers de données, effectuer une analyse simple, et visualiser les résultats.\nÉnoncé: Vous avez plusieurs fichiers CSV représentant les ventes mensuelles d’une entreprise. Fusionnez-les, calculez le total des ventes par mois, puis créez un graphique linéaire des ventes.\nSolution:\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Les DataFrames"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Dataframes.html#conclusion-2",
    "href": "content/Cours_3/1-Dataframes.html#conclusion-2",
    "title": "Les DataFrames",
    "section": "Conclusion",
    "text": "Conclusion\nLes dataframes, grâce à leur flexibilité et leur puissance, sont un outil fondamental pour l’analyse de données, le traitement préparatoire pour le machine learning, et la création de rapports et visualisations. L’optimisation des performances et l’utilisation de bibliothèques complémentaires comme Dask peuvent augmenter considérablement l’efficacité du travail avec de grandes quantités de données.",
    "crumbs": [
      "Les DataFrames"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Dataframes.html#bonus-astuces-et-meilleures-pratiques-avec-les-dataframes",
    "href": "content/Cours_3/1-Dataframes.html#bonus-astuces-et-meilleures-pratiques-avec-les-dataframes",
    "title": "Les DataFrames",
    "section": "Bonus : Astuces et Meilleures Pratiques avec les Dataframes",
    "text": "Bonus : Astuces et Meilleures Pratiques avec les Dataframes\nAprès avoir abordé les bases, les aspects avancés et des exemples concrets d’utilisation des dataframes, il est utile de conclure avec quelques astuces et meilleures pratiques qui peuvent rendre le travail avec les dataframes encore plus efficace et agréable.",
    "crumbs": [
      "Les DataFrames"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Dataframes.html#astuces-pour-la-manipulation-de-dataframes",
    "href": "content/Cours_3/1-Dataframes.html#astuces-pour-la-manipulation-de-dataframes",
    "title": "Les DataFrames",
    "section": "Astuces pour la Manipulation de Dataframes",
    "text": "Astuces pour la Manipulation de Dataframes\n\nChainage de Méthodes: Pandas permet de chaîner les méthodes, ce qui rend le code plus lisible et concis.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nOn parle aussi pour décrire ce genre d’API, de fluent API. Le terme API fait ici référence à l’API utilisateur, c’est à dire l’ensemble des fonctions et méthodes que l’on peut utiliser pour interagir avec une bibliothèque. Une API est dite fluide lorsqu’elle permet d’enchaîner les appels de méthodes, comme dans l’exemple ci-dessus.\n\nUtilisation de query pour le Filtrage: La méthode query permet un filtrage plus lisible et souvent plus rapide.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nAssignation Conditionnelle avec np.where: Pour créer de nouvelles colonnes basées sur des conditions.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Les DataFrames"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Dataframes.html#meilleures-pratiques",
    "href": "content/Cours_3/1-Dataframes.html#meilleures-pratiques",
    "title": "Les DataFrames",
    "section": "Meilleures Pratiques",
    "text": "Meilleures Pratiques\n\nÉviter les Boucles Autant que Possible: Préférer les opérations vectorisées pour une meilleure performance.\nUtilisation Judicieuse de la Mémoire: Être attentif aux types de données, en particulier avec de grands ensembles de données.\nTester avec des Sous-ensembles de Données: Avant d’appliquer des opérations à l’ensemble du dataframe, tester avec un petit échantillon.\nDocumentation et Commentaires: S’assurer que le code est bien documenté pour faciliter la compréhension et la maintenance.",
    "crumbs": [
      "Les DataFrames"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Dataframes.html#exercice-de-réflexion",
    "href": "content/Cours_3/1-Dataframes.html#exercice-de-réflexion",
    "title": "Les DataFrames",
    "section": "Exercice de Réflexion",
    "text": "Exercice de Réflexion\n\nObjectif: Réfléchir à l’optimisation du traitement des données.\nÉnoncé: Imaginez que vous avez un dataframe très large avec plusieurs colonnes inutilisées et des types de données non optimisés. Comment aborderiez-vous sa nettoyage et son optimisation pour une analyse efficace?\nSolution Suggérée:\n\nSupprimer les colonnes inutiles pour économiser de la mémoire.\nConvertir les colonnes avec des données catégorielles en type ‘category’.\nUtiliser des fonctions vectorisées pour les transformations de données.",
    "crumbs": [
      "Les DataFrames"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Dataframes.html#conclusion-3",
    "href": "content/Cours_3/1-Dataframes.html#conclusion-3",
    "title": "Les DataFrames",
    "section": "Conclusion",
    "text": "Conclusion\nLa maîtrise des dataframes dans Pandas ne se limite pas seulement à connaître diverses fonctions et méthodes, mais implique également une compréhension des meilleures pratiques et astuces pour optimiser la performance et la lisibilité du code. Cela inclut une utilisation efficace de la mémoire, l’évitement des boucles inutiles, et une bonne documentation du code.\nVous trouverez également des exemples simple d’utilisation de tout les fonctions standards dans ce Notebook\nque vous pouvez également télécharger directement ici:\n Telecharger le Notebook d'exemple \nPour vous entrainer, vous pouvez télécharger le fichier suivant et l’importer dans un notebook Jupyter :\n Telecharger le Notebook du TP \n Download the population_communes dataset",
    "crumbs": [
      "Les DataFrames"
    ]
  },
  {
    "objectID": "content/Cours_3/2-Calcul_Scientifique_et_Optimization.html",
    "href": "content/Cours_3/2-Calcul_Scientifique_et_Optimization.html",
    "title": "Calcul Scientifique et Optimization",
    "section": "",
    "text": "b Introduction au Calcul Scientifique Le calcul scientifique est une discipline essentielle dans de nombreux domaines de la recherche et de l’industrie. En Python, cela implique souvent l’utilisation de bibliothèques telles que NumPy, SciPy, et autres, qui fournissent des outils efficaces pour le calcul numérique.\n\n\n\nNumPy est une bibliothèque de base pour le calcul scientifique en Python. Elle offre des structures de données puissantes, optimisées pour les opérations mathématiques complexes et la manipulation de grands ensembles de données.\n\n\n\n\n\nTableaux Multidimensionnels: Les ndarray de NumPy sont plus performants que les listes Python pour les opérations mathématiques.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nOpérations Mathématiques Rapides et Efficaces: NumPy permet des calculs vectorisés, ce qui est plus rapide que les boucles traditionnelles.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nFonctions Mathématiques Avancées: NumPy inclut des fonctions pour l’algèbre linéaire, la transformée de Fourier, et plus.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nSciPy s’appuie sur NumPy pour offrir un ensemble plus large de fonctionnalités pour le calcul scientifique, notamment dans l’optimisation, l’intégration numérique, et la statistique.\n\n\n\n\n\nOptimisation: Trouver le minimum ou le maximum d’une fonction.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nObjectif: Utiliser NumPy et SciPy pour résoudre un problème d’optimisation.\nÉnoncé: Définissez une fonction mathématique simple (par exemple, un polynôme) et utilisez SciPy pour trouver son minimum.\nSolution:\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nLe calcul scientifique en Python, grâce à des bibliothèques comme NumPy et SciPy, est une composante essentielle pour les chercheurs et les ingénieurs. Ces outils offrent des capacités puissantes pour traiter des problèmes mathématiques complexes, de l’algèbre linéaire à l’optimisation numérique.\n\n\n\n\n\nIndexation Sophistiquée: NumPy offre des méthodes d’indexation avancées qui permettent de manipuler et d’accéder aux données de manière très flexible.\n\nIndexation Booléenne: Sélectionner des éléments basés sur des conditions.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIndexation Fantaisie: Sélectionner des éléments en utilisant des listes d’indices.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nBroadcasting: Une méthode puissante pour effectuer des opérations arithmétiques sur des tableaux de formes différentes.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nManipulation de Formes: Reshaper les tableaux pour les adapter aux besoins de vos calculs.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\nOptimisation Multivariable: SciPy n’est pas limité à l’optimisation de fonctions à une seule variable. Il peut également optimiser des fonctions avec plusieurs variables.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nContraintes et Bornes: Vous pouvez ajouter des contraintes et des bornes à votre problème d’optimisation pour le rendre plus réaliste.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\nObjectif: Approfondir l’utilisation de NumPy et SciPy pour des calculs complexes.\nÉnoncé: Créez un tableau 2D avec NumPy et utilisez l’indexation fantaisie pour sélectionner des éléments spécifiques. Ensuite, définissez une fonction multivariable et utilisez SciPy pour la minimiser avec des contraintes.\nSolution:\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nLes fonctionnalités avancées de NumPy et SciPy ouvrent des possibilités presque illimitées pour le calcul scientifique en Python. L’indexation avancée, le broadcasting, l’optimisation multivariable, et les contraintes ne sont que quelques exemples des outils puissants à la disposition des scientifiques et ingénieurs. Maîtriser ces outils peut significativement accélérer et améliorer la qualité de la recherche et du développement.\n\n\n\n\n\n\n\nIngénierie: L’utilisation de NumPy et SciPy en ingénierie est cruciale pour des tâches telles que l’analyse structurelle, la simulation de systèmes dynamiques, et la conception assistée par ordinateur (CAO).\n\nExemple: Dans l’ingénierie mécanique, on utilise souvent ces outils pour résoudre des équations différentielles qui modélisent le comportement dynamique des systèmes.\n\nPhysique et Chimie: Les calculs complexes en physique et en chimie, comme la modélisation moléculaire ou la dynamique des fluides, peuvent être réalisés avec efficacité grâce à ces bibliothèques.\n\nExemple: Les chercheurs en physique quantique peuvent utiliser SciPy pour résoudre des problèmes d’optimisation dans la recherche de l’état fondamental des systèmes quantiques.\n\nFinance et Économétrie: NumPy et SciPy sont largement utilisés dans le domaine de la finance pour l’analyse de risques, la modélisation de marchés, et l’optimisation de portefeuilles.\n\nExemple: En finance quantitative, ces outils aident à optimiser les portefeuilles en minimisant le risque pour un rendement donné.\n\n\n\n\n\n\nUtilisation de Cython ou Numba: Pour des calculs intensifs, l’utilisation de Cython ou Numba pour compiler le code Python en code machine peut apporter une amélioration significative des performances.\nParallélisation des Calculs: L’utilisation de la parallélisation, par exemple avec Dask ou des opérations multithreading/multiprocessing, peut accélérer les calculs lourds.\nGestion Efficace de la Mémoire: Utiliser des techniques comme la vectorisation et éviter les copies inutiles de données pour réduire la consommation de mémoire.\n\n\n\n\nLe calcul scientifique et l’optimisation en Python, grâce à des bibliothèques comme NumPy et SciPy, jouent un rôle clé dans une multitude de domaines. Que ce soit pour résoudre des problèmes complexes en ingénierie, en physique, en chimie, ou en finance, ces outils offrent les capacités nécessaires pour réaliser des analyses précises et des simulations efficaces. La maîtrise de ces outils est donc essentielle pour tout scientifique ou ingénieur souhaitant exploiter pleinement le potentiel du calcul numérique.",
    "crumbs": [
      "Calcul Scientifique et Optimization"
    ]
  },
  {
    "objectID": "content/Cours_3/2-Calcul_Scientifique_et_Optimization.html#numpy-fondement-du-calcul-scientifique-en-python",
    "href": "content/Cours_3/2-Calcul_Scientifique_et_Optimization.html#numpy-fondement-du-calcul-scientifique-en-python",
    "title": "Calcul Scientifique et Optimization",
    "section": "",
    "text": "NumPy est une bibliothèque de base pour le calcul scientifique en Python. Elle offre des structures de données puissantes, optimisées pour les opérations mathématiques complexes et la manipulation de grands ensembles de données.",
    "crumbs": [
      "Calcul Scientifique et Optimization"
    ]
  },
  {
    "objectID": "content/Cours_3/2-Calcul_Scientifique_et_Optimization.html#fonctionnalités-clés-de-numpy",
    "href": "content/Cours_3/2-Calcul_Scientifique_et_Optimization.html#fonctionnalités-clés-de-numpy",
    "title": "Calcul Scientifique et Optimization",
    "section": "",
    "text": "Tableaux Multidimensionnels: Les ndarray de NumPy sont plus performants que les listes Python pour les opérations mathématiques.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nOpérations Mathématiques Rapides et Efficaces: NumPy permet des calculs vectorisés, ce qui est plus rapide que les boucles traditionnelles.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nFonctions Mathématiques Avancées: NumPy inclut des fonctions pour l’algèbre linéaire, la transformée de Fourier, et plus.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Calcul Scientifique et Optimization"
    ]
  },
  {
    "objectID": "content/Cours_3/2-Calcul_Scientifique_et_Optimization.html#scipy-élargissement-des-capacités-de-calcul",
    "href": "content/Cours_3/2-Calcul_Scientifique_et_Optimization.html#scipy-élargissement-des-capacités-de-calcul",
    "title": "Calcul Scientifique et Optimization",
    "section": "",
    "text": "SciPy s’appuie sur NumPy pour offrir un ensemble plus large de fonctionnalités pour le calcul scientifique, notamment dans l’optimisation, l’intégration numérique, et la statistique.",
    "crumbs": [
      "Calcul Scientifique et Optimization"
    ]
  },
  {
    "objectID": "content/Cours_3/2-Calcul_Scientifique_et_Optimization.html#exemple-dutilisation-de-scipy-pour-loptimisation",
    "href": "content/Cours_3/2-Calcul_Scientifique_et_Optimization.html#exemple-dutilisation-de-scipy-pour-loptimisation",
    "title": "Calcul Scientifique et Optimization",
    "section": "",
    "text": "Optimisation: Trouver le minimum ou le maximum d’une fonction.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Calcul Scientifique et Optimization"
    ]
  },
  {
    "objectID": "content/Cours_3/2-Calcul_Scientifique_et_Optimization.html#exercice-pratique",
    "href": "content/Cours_3/2-Calcul_Scientifique_et_Optimization.html#exercice-pratique",
    "title": "Calcul Scientifique et Optimization",
    "section": "",
    "text": "Objectif: Utiliser NumPy et SciPy pour résoudre un problème d’optimisation.\nÉnoncé: Définissez une fonction mathématique simple (par exemple, un polynôme) et utilisez SciPy pour trouver son minimum.\nSolution:\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Calcul Scientifique et Optimization"
    ]
  },
  {
    "objectID": "content/Cours_3/2-Calcul_Scientifique_et_Optimization.html#conclusion",
    "href": "content/Cours_3/2-Calcul_Scientifique_et_Optimization.html#conclusion",
    "title": "Calcul Scientifique et Optimization",
    "section": "",
    "text": "Le calcul scientifique en Python, grâce à des bibliothèques comme NumPy et SciPy, est une composante essentielle pour les chercheurs et les ingénieurs. Ces outils offrent des capacités puissantes pour traiter des problèmes mathématiques complexes, de l’algèbre linéaire à l’optimisation numérique.\n\n\n\n\n\nIndexation Sophistiquée: NumPy offre des méthodes d’indexation avancées qui permettent de manipuler et d’accéder aux données de manière très flexible.\n\nIndexation Booléenne: Sélectionner des éléments basés sur des conditions.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIndexation Fantaisie: Sélectionner des éléments en utilisant des listes d’indices.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nBroadcasting: Une méthode puissante pour effectuer des opérations arithmétiques sur des tableaux de formes différentes.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nManipulation de Formes: Reshaper les tableaux pour les adapter aux besoins de vos calculs.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\nOptimisation Multivariable: SciPy n’est pas limité à l’optimisation de fonctions à une seule variable. Il peut également optimiser des fonctions avec plusieurs variables.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nContraintes et Bornes: Vous pouvez ajouter des contraintes et des bornes à votre problème d’optimisation pour le rendre plus réaliste.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\nObjectif: Approfondir l’utilisation de NumPy et SciPy pour des calculs complexes.\nÉnoncé: Créez un tableau 2D avec NumPy et utilisez l’indexation fantaisie pour sélectionner des éléments spécifiques. Ensuite, définissez une fonction multivariable et utilisez SciPy pour la minimiser avec des contraintes.\nSolution:\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nLes fonctionnalités avancées de NumPy et SciPy ouvrent des possibilités presque illimitées pour le calcul scientifique en Python. L’indexation avancée, le broadcasting, l’optimisation multivariable, et les contraintes ne sont que quelques exemples des outils puissants à la disposition des scientifiques et ingénieurs. Maîtriser ces outils peut significativement accélérer et améliorer la qualité de la recherche et du développement.\n\n\n\n\n\n\n\nIngénierie: L’utilisation de NumPy et SciPy en ingénierie est cruciale pour des tâches telles que l’analyse structurelle, la simulation de systèmes dynamiques, et la conception assistée par ordinateur (CAO).\n\nExemple: Dans l’ingénierie mécanique, on utilise souvent ces outils pour résoudre des équations différentielles qui modélisent le comportement dynamique des systèmes.\n\nPhysique et Chimie: Les calculs complexes en physique et en chimie, comme la modélisation moléculaire ou la dynamique des fluides, peuvent être réalisés avec efficacité grâce à ces bibliothèques.\n\nExemple: Les chercheurs en physique quantique peuvent utiliser SciPy pour résoudre des problèmes d’optimisation dans la recherche de l’état fondamental des systèmes quantiques.\n\nFinance et Économétrie: NumPy et SciPy sont largement utilisés dans le domaine de la finance pour l’analyse de risques, la modélisation de marchés, et l’optimisation de portefeuilles.\n\nExemple: En finance quantitative, ces outils aident à optimiser les portefeuilles en minimisant le risque pour un rendement donné.\n\n\n\n\n\n\nUtilisation de Cython ou Numba: Pour des calculs intensifs, l’utilisation de Cython ou Numba pour compiler le code Python en code machine peut apporter une amélioration significative des performances.\nParallélisation des Calculs: L’utilisation de la parallélisation, par exemple avec Dask ou des opérations multithreading/multiprocessing, peut accélérer les calculs lourds.\nGestion Efficace de la Mémoire: Utiliser des techniques comme la vectorisation et éviter les copies inutiles de données pour réduire la consommation de mémoire.\n\n\n\n\nLe calcul scientifique et l’optimisation en Python, grâce à des bibliothèques comme NumPy et SciPy, jouent un rôle clé dans une multitude de domaines. Que ce soit pour résoudre des problèmes complexes en ingénierie, en physique, en chimie, ou en finance, ces outils offrent les capacités nécessaires pour réaliser des analyses précises et des simulations efficaces. La maîtrise de ces outils est donc essentielle pour tout scientifique ou ingénieur souhaitant exploiter pleinement le potentiel du calcul numérique.",
    "crumbs": [
      "Calcul Scientifique et Optimization"
    ]
  },
  {
    "objectID": "content/Cours_3/pandas_short_example.html",
    "href": "content/Cours_3/pandas_short_example.html",
    "title": "Exemple sur pandas",
    "section": "",
    "text": "Telecharger le Notebook d'exemple \n\nimport pandas as pd\n\n\ndata = [\n    {'beer_name': 'a', 'type': 'blonde', 'price': 2},\n    {'beer_name': 'b', 'type': 'blonde', 'price': 2},\n    {'beer_name': 'c', 'type': 'blonde', 'price': 3},\n    {'beer_name': 'd', 'type': 'brune', 'price': 4},\n    {'beer_name': 'e', 'type': 'ale', 'price': 2}\n]\n\n\ndf = pd.DataFrame(data)  # créer un dataframe à partir d'une liste de dict\n\n\ndf\n\n\n\n\n\n\n\n\n\nbeer_name\ntype\nprice\n\n\n\n\n0\na\nblonde\n2\n\n\n1\nb\nblonde\n2\n\n\n2\nc\nblonde\n3\n\n\n3\nd\nbrune\n4\n\n\n4\ne\nale\n2\n\n\n\n\n\n\n\n\n\ndf.columns\n\nIndex(['beer_name', 'type', 'price'], dtype='object')\n\n\n\ntype(df)\n\npandas.core.frame.DataFrame\n\n\n\n# Créer un dataframe à partir d'un dict de list:\ndf2 = pd.DataFrame({\n    'x': [1,2,3,5],\n    'y': [4,22,33,5]\n})\n\n\ndf2\n\n\n\n\n\n\n\n\n\nx\ny\n\n\n\n\n0\n1\n4\n\n\n1\n2\n22\n\n\n2\n3\n33\n\n\n3\n5\n5\n\n\n\n\n\n\n\n\n\ndf2.shape\n\n(4, 2)\n\n\n\ndf2.columns\n\nIndex(['x', 'y'], dtype='object')\n\n\n\ndf2.x\n\n0    1\n1    2\n2    3\n3    5\nName: x, dtype: int64\n\n\n\ntype(df2.x)\n\npandas.core.series.Series\n\n\n\nl = [1, 2, 3, None]\ns = pd.Series(l)\n\n\nl\n\n[1, 2, 3, None]\n\n\n\ns\n\n0    1.0\n1    2.0\n2    3.0\n3    NaN\ndtype: float64\n\n\n\ns.mean()\n\n2.0\n\n\n\ndf2['x']  \n\n0    1\n1    2\n2    3\n3    5\nName: x, dtype: int64\n\n\n\ndf2['x'] + 10\n\n0    11\n1    12\n2    13\n3    15\nName: x, dtype: int64\n\n\n\ndf2['x'] + df2['y']\n\n0     5\n1    24\n2    36\n3    10\ndtype: int64\n\n\n\ndf2['x'] &gt; 2  # renvoie une série de booléens\n\n0    False\n1    False\n2     True\n3     True\nName: x, dtype: bool\n\n\n\n(df2['x'] &gt; 2) & (df2['x'] &lt; 5)  # on peut combiner les séries de booléens avec & et |\n\n0    False\n1    False\n2     True\n3    False\nName: x, dtype: bool\n\n\n\ndf\n\n\n\n\n\n\n\n\n\nbeer_name\ntype\nprice\n\n\n\n\n0\na\nblonde\n2\n\n\n1\nb\nblonde\n2\n\n\n2\nc\nblonde\n3\n\n\n3\nd\nbrune\n4\n\n\n4\ne\nale\n2\n\n\n\n\n\n\n\n\n\ndf['price']\n\n0    2\n1    2\n2    3\n3    4\n4    2\nName: price, dtype: int64\n\n\n\nbool_serie = df['price'] &gt; 2\nbool_serie\n\n0    False\n1    False\n2     True\n3     True\n4    False\nName: price, dtype: bool\n\n\n\n# on peut se servir de la syntaxe [] avec une série de booléens pour filtrer des lignes:\ndf[bool_serie]\n\n\n\n\n\n\n\n\n\nbeer_name\ntype\nprice\n\n\n\n\n2\nc\nblonde\n3\n\n\n3\nd\nbrune\n4\n\n\n\n\n\n\n\n\n\n# Ici on extrait les lignes qui on un price &lt;= 2 + celles qui ont un price &gt; 3\ndf[(df['price'] &gt; 3) | (df['price'] &lt;= 2)]\n\n\n\n\n\n\n\n\n\nbeer_name\ntype\nprice\n\n\n\n\n0\na\nblonde\n2\n\n\n1\nb\nblonde\n2\n\n\n3\nd\nbrune\n4\n\n\n4\ne\nale\n2\n\n\n\n\n\n\n\n\n\ns = df.price\ns\n\n0    2\n1    2\n2    3\n3    4\n4    2\nName: price, dtype: int64\n\n\n\ns.sort_values()\n\n0    2\n1    2\n4    2\n2    3\n3    4\nName: price, dtype: int64\n\n\n\ndf.sort_values('price')\n\n\n\n\n\n\n\n\n\nbeer_name\ntype\nprice\n\n\n\n\n0\na\nblonde\n2\n\n\n1\nb\nblonde\n2\n\n\n4\ne\nale\n2\n\n\n2\nc\nblonde\n3\n\n\n3\nd\nbrune\n4\n\n\n\n\n\n\n\n\n\ndf.sort_values(['type', 'price'])  # tri sur plusieurs colonnes\n\n\n\n\n\n\n\n\n\nbeer_name\ntype\nprice\n\n\n\n\n4\ne\nale\n2\n\n\n0\na\nblonde\n2\n\n\n1\nb\nblonde\n2\n\n\n2\nc\nblonde\n3\n\n\n3\nd\nbrune\n4\n\n\n\n\n\n\n\n\n\ndfsorted = df.sort_values(['type', 'price'])\ndfsorted\n\n\n\n\n\n\n\n\n\nbeer_name\ntype\nprice\n\n\n\n\n4\ne\nale\n2\n\n\n0\na\nblonde\n2\n\n\n1\nb\nblonde\n2\n\n\n2\nc\nblonde\n3\n\n\n3\nd\nbrune\n4\n\n\n\n\n\n\n\n\n\ndfsorted.sort_index()  # trier par l'index\n\n\n\n\n\n\n\n\n\nbeer_name\ntype\nprice\n\n\n\n\n0\na\nblonde\n2\n\n\n1\nb\nblonde\n2\n\n\n2\nc\nblonde\n3\n\n\n3\nd\nbrune\n4\n\n\n4\ne\nale\n2\n\n\n\n\n\n\n\n\n\ndf['type']  # une colonne qui contient des str\n\n0    blonde\n1    blonde\n2    blonde\n3     brune\n4       ale\nName: type, dtype: object\n\n\n\n# L'attribut .str permet d'accéder aux méthodes des str habituelles:\ndf['type'].str.startswith('b')\n\n0     True\n1     True\n2     True\n3     True\n4    False\nName: type, dtype: bool\n\n\n\ndf\n\n\n\n\n\n\n\n\n\nbeer_name\ntype\nprice\n\n\n\n\n0\na\nblonde\n2\n\n\n1\nb\nblonde\n2\n\n\n2\nc\nblonde\n3\n\n\n3\nd\nbrune\n4\n\n\n4\ne\nale\n2\n\n\n\n\n\n\n\n\n\ndf[['price', 'type']]  # prendre un sous-ensemble des colonnes\n\n\n\n\n\n\n\n\n\nprice\ntype\n\n\n\n\n0\n2\nblonde\n\n\n1\n2\nblonde\n\n\n2\n3\nblonde\n\n\n3\n4\nbrune\n\n\n4\n2\nale\n\n\n\n\n\n\n\n\n\ndf.loc[[0, 2]]  # extrait les lignes à l'index 0 et 2\n\n\n\n\n\n\n\n\n\nbeer_name\ntype\nprice\n\n\n\n\n0\na\nblonde\n2\n\n\n2\nc\nblonde\n3\n\n\n\n\n\n\n\n\n\ndf.loc[0:2]  # extrait les lignes aux index 0, 1, et 2 *inclus*\n\n\n\n\n\n\n\n\n\nbeer_name\ntype\nprice\n\n\n\n\n0\na\nblonde\n2\n\n\n1\nb\nblonde\n2\n\n\n2\nc\nblonde\n3\n\n\n\n\n\n\n\n\n\n# extrait les lignes aux index 1, 2, et 3 *inclus*, avec les colonnes price et type:\ndf.loc[1:3, ['price', 'type']]  \n\n\n\n\n\n\n\n\n\nprice\ntype\n\n\n\n\n1\n2\nblonde\n\n\n2\n3\nblonde\n\n\n3\n4\nbrune\n\n\n\n\n\n\n\n\n\ndf['plop'] = [10, 11, 12, 13, 14]  # ajout d'une colonne\n\n\ndf\n\n\n\n\n\n\n\n\n\nbeer_name\ntype\nprice\nplop\n\n\n\n\n0\na\nblonde\n2\n10\n\n\n1\nb\nblonde\n2\n11\n\n\n2\nc\nblonde\n3\n12\n\n\n3\nd\nbrune\n4\n13\n\n\n4\ne\nale\n2\n14\n\n\n\n\n\n\n\n\n\ndf2 = df.set_index('plop')  # on place la colonne 'plop' en index\ndf2\n\n\n\n\n\n\n\n\n\nbeer_name\ntype\nprice\n\n\nplop\n\n\n\n\n\n\n\n10\na\nblonde\n2\n\n\n11\nb\nblonde\n2\n\n\n12\nc\nblonde\n3\n\n\n13\nd\nbrune\n4\n\n\n14\ne\nale\n2\n\n\n\n\n\n\n\n\n\ndf2.loc[10:12, 'beer_name':'price']\n\n\n\n\n\n\n\n\n\nbeer_name\ntype\nprice\n\n\nplop\n\n\n\n\n\n\n\n10\na\nblonde\n2\n\n\n11\nb\nblonde\n2\n\n\n12\nc\nblonde\n3\n\n\n\n\n\n\n\n\n\ndf_with_beername_index = df.set_index('beer_name')\n\n\ndf_with_beername_index\n\n\n\n\n\n\n\n\n\ntype\nprice\nplop\n\n\nbeer_name\n\n\n\n\n\n\n\na\nblonde\n2\n10\n\n\nb\nblonde\n2\n11\n\n\nc\nblonde\n3\n12\n\n\nd\nbrune\n4\n13\n\n\ne\nale\n2\n14\n\n\n\n\n\n\n\n\n\ndf_with_beername_index.loc[['a', 'c'], ['price', 'plop']]\n\n\n\n\n\n\n\n\n\nprice\nplop\n\n\nbeer_name\n\n\n\n\n\n\na\n2\n10\n\n\nc\n3\n12\n\n\n\n\n\n\n\n\n\ndf_with_type_index = df.set_index('type')\ndf_with_type_index\n\n\n\n\n\n\n\n\n\nbeer_name\nprice\nplop\n\n\ntype\n\n\n\n\n\n\n\nblonde\na\n2\n10\n\n\nblonde\nb\n2\n11\n\n\nblonde\nc\n3\n12\n\n\nbrune\nd\n4\n13\n\n\nale\ne\n2\n14\n\n\n\n\n\n\n\n\n\ndf_with_type_index.loc['blonde']\n\n\n\n\n\n\n\n\n\nbeer_name\nprice\nplop\n\n\ntype\n\n\n\n\n\n\n\nblonde\na\n2\n10\n\n\nblonde\nb\n2\n11\n\n\nblonde\nc\n3\n12\n\n\n\n\n\n\n\n\n\n# iloc est similaire à loc sauf qu'il prend en paramètre les positions des lignes/colonnes,\n# contrairement à loc qui prend leurs valeurs.\ndf_with_type_index.iloc[:2, 1:]  # extrait les lignes 0 à 2 (exclue) et les colonnes 1 et suivantes\n\n\n\n\n\n\n\n\n\nprice\nplop\n\n\ntype\n\n\n\n\n\n\nblonde\n2\n10\n\n\nblonde\n2\n11\n\n\n\n\n\n\n\n\n\ndf \n\n\n\n\n\n\n\n\n\nbeer_name\ntype\nprice\nplop\n\n\n\n\n0\na\nblonde\n2\n10\n\n\n1\nb\nblonde\n2\n11\n\n\n2\nc\nblonde\n3\n12\n\n\n3\nd\nbrune\n4\n13\n\n\n4\ne\nale\n2\n14\n\n\n\n\n\n\n\n\n\n# Extrait la valeur de la 1ère cellule:\ndf.iloc[0, 0]\n\n'a'\n\n\n\ndfbis = df.copy()\n\n\ndfbis\n\n\n\n\n\n\n\n\n\nbeer_name\ntype\nprice\nplop\n\n\n\n\n0\na\nblonde\n2\n10\n\n\n1\nb\nblonde\n2\n11\n\n\n2\nc\nblonde\n3\n12\n\n\n3\nd\nbrune\n4\n13\n\n\n4\ne\nale\n2\n14\n\n\n\n\n\n\n\n\n\n# Concaténer 2 dataframes:\npd.concat([\n    df,\n    dfbis\n])\n\n\n\n\n\n\n\n\n\nbeer_name\ntype\nprice\nplop\n\n\n\n\n0\na\nblonde\n2\n10\n\n\n1\nb\nblonde\n2\n11\n\n\n2\nc\nblonde\n3\n12\n\n\n3\nd\nbrune\n4\n13\n\n\n4\ne\nale\n2\n14\n\n\n0\na\nblonde\n2\n10\n\n\n1\nb\nblonde\n2\n11\n\n\n2\nc\nblonde\n3\n12\n\n\n3\nd\nbrune\n4\n13\n\n\n4\ne\nale\n2\n14\n\n\n\n\n\n\n\n\n\ndf_with_type_index\n\n\n\n\n\n\n\n\n\nbeer_name\nprice\nplop\n\n\ntype\n\n\n\n\n\n\n\nblonde\na\n2\n10\n\n\nblonde\nb\n2\n11\n\n\nblonde\nc\n3\n12\n\n\nbrune\nd\n4\n13\n\n\nale\ne\n2\n14\n\n\n\n\n\n\n\n\n\ndf_with_type_index.reset_index()\n\n\n\n\n\n\n\n\n\ntype\nbeer_name\nprice\nplop\n\n\n\n\n0\nblonde\na\n2\n10\n\n\n1\nblonde\nb\n2\n11\n\n\n2\nblonde\nc\n3\n12\n\n\n3\nbrune\nd\n4\n13\n\n\n4\nale\ne\n2\n14\n\n\n\n\n\n\n\n\n\nfor elem in df.index:\n    print(elem)\n\n0\n1\n2\n3\n4\n\n\n\ndf.set_index(['type', 'price']).sort_index()\n\n\n\n\n\n\n\n\n\n\nbeer_name\nplop\n\n\ntype\nprice\n\n\n\n\n\n\nale\n2\ne\n14\n\n\nblonde\n2\na\n10\n\n\n2\nb\n11\n\n\n3\nc\n12\n\n\nbrune\n4\nd\n13\n\n\n\n\n\n\n\n\n\ndf.to_csv('output.csv', index=False)  # exporter le dataframe dans un fichier csv\n\n\npd.read_csv('output.csv')  # créer un dataframe à partir d'un csv\n\n\n\n\n\n\n\n\n\nbeer_name\ntype\nprice\nplop\n\n\n\n\n0\na\nblonde\n2\n10\n\n\n1\nb\nblonde\n2\n11\n\n\n2\nc\nblonde\n3\n12\n\n\n3\nd\nbrune\n4\n13\n\n\n4\ne\nale\n2\n14\n\n\n\n\n\n\n\n\n\npd.read_csv('output2.csv')\n\n\n\n\n\n\n\n\n\nbeer_name\nprice\ntype\ngood\n\n\n\n\n0\na\n2\nblonde\nnon renseigne\n\n\n1\nb\n2\nblonde\noui\n\n\n2\nc\n3\nblonde\noui\n\n\n3\nd\n4\nbrune\nnon renseigne\n\n\n4\ne\n2\nale\nnon renseigne\n\n\n5\nx\n1\nblonde\noui\n\n\n\n\n\n\n\n\n\n# read_csv dispose de plein d'options\npd.read_csv('output2.csv', na_values=['non renseigne'], true_values=['oui'])\n\n\n\n\n\n\n\n\n\nbeer_name\nprice\ntype\ngood\n\n\n\n\n0\na\n2\nblonde\nNaN\n\n\n1\nb\n2\nblonde\nTrue\n\n\n2\nc\n3\nblonde\nTrue\n\n\n3\nd\n4\nbrune\nNaN\n\n\n4\ne\n2\nale\nNaN\n\n\n5\nx\n1\nblonde\nTrue\n\n\n\n\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Exemple sur pandas"
    ]
  },
  {
    "objectID": "content/Cours_3/Exercice-pandas_and_geography.html",
    "href": "content/Cours_3/Exercice-pandas_and_geography.html",
    "title": "TP - Utiliser pandas",
    "section": "",
    "text": "On va travailler sur le csv de donnée population commune:\n\n1- importer le fichier et donné le nombre de ville présente dans celui-ci\n\ndf = #TODO\n\n2- Donnée le nombre de ville par région\n\n#Display(nb_villes_region)\n\n3-Donnée la moyenne et l’écart-type globale et par région de la population (totale) par ville\n\n#Display(stats_region)\n\n4- Existe-t-il des villes sans population ?\n\n#print(f'there is {unpopulated} unpopulated cities')\n\n5- Verifiez qu’un code de département n’est pas présent dans 2 régions différentes\n\n#print(f'')\n\n6- Des villes portent-elles le même nom ?\n\n#print(f'')\n\n7-Créer une colonne ‘base du nom’ qui tronquent les noms des villes possedant des tirets avant ceux-ci (exemple: Abbeville-Saint-Lucien devient Abbeville)\n\n#print(f'')\n\n8- Combien de ville ayant des noms différents portent un ‘base du nom’ similaire ?\n\n#print(f'')\n\n9- A l’aide de matplotlib, tracer une courbe de densité cumulative de la différence entre population totale et municipale\n\n#print(f'')\n\n Telecharger le Notebook du TP \n Download the population_communes dataset \n\n\n\n Back to top",
    "crumbs": [
      "Travaux Pratiques",
      "TP - Utiliser pandas"
    ]
  },
  {
    "objectID": "content/Cours_3/TP-3.html",
    "href": "content/Cours_3/TP-3.html",
    "title": "TP-3 Libraries",
    "section": "",
    "text": "TP : Analyse et Prévision des Volumes d’Actifs Financiers\nCe TP se concentre sur la récupération des données de prix d’actifs, la prévision de volumes et la visualisation de la volatilité. Nous allons suivre les étapes suivantes :\n\n1. Récupération des Données avec yfinance\nNous utiliserons le package yfinance pour récupérer les données de prix journaliers de 10 actifs différents.\n\n\n2. Prévision de Volume avec Modèles Simples\nNous mettrons en œuvre des modèles de prévision simples comme la régression linéaire et ARIMA pour prédire le volume des transactions pour le jour suivant (1-step ahead forecast).\n\n\n3. Visualisation des Volumes par Rapport à la Volatilité\nNous visualiserons les volumes des actifs en relation avec leur volatilité, en utilisant la valeur absolue des rendements comme proxy de la volatilité.\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Travaux Pratiques",
      "TP-3 Libraries"
    ]
  },
  {
    "objectID": "content/Cours_4/TP-RequetteruneAPI.html",
    "href": "content/Cours_4/TP-RequetteruneAPI.html",
    "title": "TP - Requettes API avec Python",
    "section": "",
    "text": "Visualisation de données avec Python\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/Cours_4/index.html",
    "href": "content/Cours_4/index.html",
    "title": "Bonne pratiques, Dangers, et Astuces",
    "section": "",
    "text": "Les cours de cette partie sont:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAsynchronie et Multiprocessing\n\n\n\n\n\n\nRemi Genet\n\n\n2025-01-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMutabilité et Scope\n\n\n\n\n\n\nRemi Genet\n\n\n2025-01-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTP - Requettes API avec Python\n\n\nAsynchronie vs synchronie\n\n\n\nRemi Genet\n\n\n2025-01-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTypage en Python\n\n\nTypage en Python - Utile ou pas ?\n\n\n\nRemi Genet\n\n\n2025-01-29\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to top",
    "crumbs": [
      "Bonne pratiques, Dangers, et Astuces"
    ]
  },
  {
    "objectID": "content/Cours_4/TP_OOP_n_ASYNC.html",
    "href": "content/Cours_4/TP_OOP_n_ASYNC.html",
    "title": "TP - Creer un outil de récupération de donnée",
    "section": "",
    "text": "Telecharger le Notebook de TP",
    "crumbs": [
      "Travaux Pratiques",
      "TP - Creer un outil de récupération de donnée"
    ]
  },
  {
    "objectID": "content/Cours_4/TP_OOP_n_ASYNC.html#objectifs-de-la-session",
    "href": "content/Cours_4/TP_OOP_n_ASYNC.html#objectifs-de-la-session",
    "title": "TP - Creer un outil de récupération de donnée",
    "section": "Objectifs de la session :",
    "text": "Objectifs de la session :\n\nUtiliser la programmation orientée objet (POO) pour structurer le code et encapsuler les méthodes\nUtiliser requests pour récupérer des données sur Internet\nUtiliser pandas pour réagréger ces données\nAjouter une méthode asynchrone pour améliorer les performances",
    "crumbs": [
      "Travaux Pratiques",
      "TP - Creer un outil de récupération de donnée"
    ]
  },
  {
    "objectID": "content/Cours_4/TP_OOP_n_ASYNC.html#sujets",
    "href": "content/Cours_4/TP_OOP_n_ASYNC.html#sujets",
    "title": "TP - Creer un outil de récupération de donnée",
    "section": "Sujets:",
    "text": "Sujets:\nL’objectif est de créer une classe encapsulant la récupération de bars OHLCV depuis une API, en permettant une aggrégation à une fréquence différente de celle des données récupérées.\n\nRappel:\nPour rappel, les OHLCV signifie simplement Open, high, low, close, volume, il s’agit d’une des formes les plus standard d’aggrégation de données financiere de marché. En effet, pour n’importe quel marchés (dans le sens carnet d’ordre avec un asset et une currency, que ce soit du forex, des contrats, des crypto, des equity..), la donnée brute du marché est, d’une part couteuse auprès des provider, d’autres part difficile à utiliser et à comprendre facilement. En effet, la donnée la plus brute serait l’ensemble des ajouts, modfication et annulation d’ordre sur le marché, ce qui avec les marchés éléctroniques et le trading algorithmique représente une quantité colossalle par jour. Une version filtré de celle-ci est l’ensemble des transactions ayant eu lieue durant la journée, ce qui réduit très grandement la quantité de données mais reste très peu pratique. Les bars OHLCV sont une représentation aggrégé de cette donnée, car elle représente sur chaque période l’aggrégation par premier, dernier, max, min, somme…\n\n\nAPI utilisée:\nPour le TP d’aujourd’hui nous allons utiliser les bars OHLCV de l’API de Binance, car celle-ci ne necessitent pas d’authentification, mais seulement une limite de requette par minute par IP. Les données peuvent être récupéré par requette get sur des urls construit comme: https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=30m\nla documentation se trouvant ici: https://binance-docs.github.io/apidocs/spot/en/#kline-candlestick-data\n\n\nConsignes:\nObjectif final: - Pouvoir récupérer facilement pour n’importe quel symbol/liste de symbols les bars à la minute sur une période donnée - Pouvoir étendre cette période ensuite - Pouvoir recuperer des données aggrégés à une autre fréquence (&gt;1minute) en aggregant les données déjà acquise - Ajouter une option pour effectuer la récupération de facon asynchrone\netape 1: Penser la classe: Construire une classe permettant de représenter le problème ci-dessus: - Poser d’abord sur papier / en brouillon de code la classe de base, ses attributes et ses méthodes - Penser à comment vous aller pouvoir l’utiliser ensuite\netape 2: Implementer le minimum necessaire et tester avec requests: - Avant de se lancer dans l’aggrégation et dans l’async, implementer de facon iterative en testant votre code\netape 3: Ajouter une méthode pour acceder au donnée récupéré avec une autre fréquence\netape 4: Creer une variance de votre méthode de récupération qui est asynchrone - Idéallement, vous avez séparé le code de sorte que chaque requette soit effectué dans une fonction - Ainsi il est possible d’utiliser asyncio.gather/asyncio.wait pour attendre de multiples coroutines\n\n# Good Luck",
    "crumbs": [
      "Travaux Pratiques",
      "TP - Creer un outil de récupération de donnée"
    ]
  },
  {
    "objectID": "content/Cours_4/TP_OOP_n_ASYNC.html#nb-async-et-notebook",
    "href": "content/Cours_4/TP_OOP_n_ASYNC.html#nb-async-et-notebook",
    "title": "TP - Creer un outil de récupération de donnée",
    "section": "NB: async et notebook",
    "text": "NB: async et notebook\nLes notebook et un .py lancé normalement auront quelque différence dans le cas d’une utilisation asynchrone. En effet, dans un contexte standard (fichier .py), il est necessaire de créer une boucle d’evenement dans lequels les coroutines s’executeront. La façon standard de faire cela est:\n\nimport asyncio\n\n# async and normal functions ....\n\nasync def main():\n    # what you would have put in __name__ == '__main__' usually\n    pass\n\nif __name__ == '__main__':\n    asyncio.run(main())\n\n&lt;frozen genericpath&gt;:89: RuntimeWarning: coroutine 'main' was never awaited\nRuntimeWarning: Enable tracemalloc to get the object allocation traceback\n\n\nRuntimeError: asyncio.run() cannot be called from a running event loop\n\n\nCe qui est ci-dessus marche et est là façon la plus usuelle de lancer un code asynchrone dans un .py, mais dans un notebook vous obtiendrez une erreur:\nRuntimeError: asyncio.run() cannot be called from a running event loop\nEn effet, le code s’execute déjà de façon asynchrone dans un notebook, et il n’y a pas besoin d’utiliser asyncio.run pour pouvoir utiliser await !\n\nimport asyncio\n\nasync def test(x):\n    print('enter test - waiting', x)\n    await asyncio.sleep(x)\n    return x\n\nasync def main():\n    a = await test(2)\n    b = await test(1)\n    print(a + b)\n    \nloop = asyncio.get_event_loop()\nloop\n\n&lt;_UnixSelectorEventLoop running=True closed=False debug=False&gt;\n\n\n\nIl est donc possible d’attendre une fonction asynchrone directement en utilisant await:\n\nawait main()\n\nenter test - waiting 2\nenter test - waiting 1\n3\n\n\n\n\nCe qui revient à l’ajouter à la boucle actuel\n\nawait loop.create_task(main())\n\nenter test - waiting 2\nenter test - waiting 1\n3\n\n\n\n\nUne méthode possible pour lancer de façon similaire votre code entre un .py et un notebook est de creer un processus séparé pour executer le code, comme ci-dessous par exemple:\n\n%%time \n\nimport multiprocessing\n\ndef run_in_process():\n    def run():\n        loop = asyncio.new_event_loop()\n        asyncio.run(main())\n\n    process = multiprocessing.Process(target=run)  #ou multiprocessing.Process(target=run, args=tuple d'argument) si vous avez des arguments dans votre fonction run\n    process.start() # démarre le processus\n    process.join() # l'attends --&gt; rend le lancement de run_in_process bloquant, i.e. vous ne pouvez pas en lancer plusieurs à la fois\n\nrun_in_process()\nrun_in_process()\nrun_in_process()\n\nenter test - waiting 2\nenter test - waiting 1\n3\nenter test - waiting 2\nenter test - waiting 1\n3\nenter test - waiting 2\nenter test - waiting 1\n3\nCPU times: user 14.6 ms, sys: 18.3 ms, total: 32.9 ms\nWall time: 9.07 s\n\n\n\n\nEn enlevant le join des process on attend plus les process et l’on execute les 3 boucles d’evenement en même temps\n\n%%time \n\ndef run_in_process():\n    def run():\n        loop = asyncio.new_event_loop()\n        asyncio.run(main())\n\n    process = multiprocessing.Process(target=run)  \n    process.start() \n    #process.join() # Ici l'on attend pas la fin du process\n\nrun_in_process()\nrun_in_process()\nrun_in_process()\n\nenter test - waiting 2CPU times: user 3.4 ms, sys: 12 ms, total: 15.4 ms\nWall time: 13.4 ms\n\n\nenter test - waiting 2enter test - waiting 2\nenter test - waiting enter test - waiting1 \n1\nenter test - waiting 1\n33\n\n3\n\n\n\n\nMais l’on voit que %%time n’affiche presque rien, en effet on ne verifie pas que les processus soit terminé avant de passer à la suite, on peut faire cela comme suit:\n\n%%time\n\ndef run_in_process():\n    def run():\n        loop = asyncio.new_event_loop()\n        asyncio.run(main())\n\n    process = multiprocessing.Process(target=run)  \n    process.start() \n    #process.join() # Ici l'on attend pas la fin du process\n    return process\n\nlist_processes = []\nlist_processes.append(run_in_process())\nlist_processes.append(run_in_process())\nlist_processes.append(run_in_process())\nfor p in list_processes:\n    p.join()\n\nenter test - waiting 2enter test - waiting\n 2\nenter test - waiting 2\nenter test - waiting 1enter test - waiting \n1\nenter test - waiting 1\n3\n3\n3\nCPU times: user 5.22 ms, sys: 19.8 ms, total: 25.1 ms\nWall time: 3.02 s",
    "crumbs": [
      "Travaux Pratiques",
      "TP - Creer un outil de récupération de donnée"
    ]
  },
  {
    "objectID": "content/Cours_4/TP_OOP_n_ASYNC.html#cest-peu-ou-prou-la-meme-chose-avec-lasync---il-faut-bien-penser-à-lendroit-où-lon-va-synchroniser-les-différents-evenement",
    "href": "content/Cours_4/TP_OOP_n_ASYNC.html#cest-peu-ou-prou-la-meme-chose-avec-lasync---il-faut-bien-penser-à-lendroit-où-lon-va-synchroniser-les-différents-evenement",
    "title": "TP - Creer un outil de récupération de donnée",
    "section": "C’est peu ou prou la meme chose avec l’async - il faut bien penser à l’endroit où l’on va synchroniser les différents evenement",
    "text": "C’est peu ou prou la meme chose avec l’async - il faut bien penser à l’endroit où l’on va synchroniser les différents evenement\n\nPetite note : %%time empeche d’utiliser normalement await dans une cellule\n\n%%time \n\nimport asyncio\n\nasync def test(x):\n    print('enter test - waiting', x)\n    await asyncio.sleep(x)\n    return x\n\nasync def main():\n    for k in range(5):\n        await test(k)\n\nawait main()\n\nSyntaxError: 'await' outside function (&lt;timed exec&gt;, line 12)\n\n\n\n## Petit cadeau, voici un petit décorateur permettant de lancer dans un process la fonction async selectionné, permettant ainsi d'utiliser %%time de facon simple\n\n\ndef run_in_process(async_func):\n    def wrapper(*args, **kwargs):\n        def run():\n            loop = asyncio.new_event_loop()\n            asyncio.run(async_func(*args, **kwargs))\n        process = multiprocessing.Process(target=run)  \n        process.start() \n        process.join()    \n    return wrapper\n    \n\n\n%%time \n\nasync def test(x):\n    print('enter test - waiting', x)\n    await asyncio.sleep(x)\n    return x\n\n@run_in_process\nasync def main(k_max=3):\n    for k in range(k_max):\n        await test(k)\n\nmain(k_max=4)\n\nenter test - waiting 0\nenter test - waiting 1\nenter test - waiting 2\nenter test - waiting 3\nCPU times: user 8.45 ms, sys: 8.05 ms, total: 16.5 ms\nWall time: 6.03 s",
    "crumbs": [
      "Travaux Pratiques",
      "TP - Creer un outil de récupération de donnée"
    ]
  },
  {
    "objectID": "content/Cours_4/TP_OOP_n_ASYNC.html#on-voit-cependant-au-dessus-que-lon-a-attendu-123-second---pas-top",
    "href": "content/Cours_4/TP_OOP_n_ASYNC.html#on-voit-cependant-au-dessus-que-lon-a-attendu-123-second---pas-top",
    "title": "TP - Creer un outil de récupération de donnée",
    "section": "On voit cependant au dessus que l’on a attendu 1+2+3 second - pas TOP",
    "text": "On voit cependant au dessus que l’on a attendu 1+2+3 second - pas TOP\n\nIl faut en fait utiliser gather par exemple pour pouvoir executer plusieurs coroutine en meme temps et les attendre\n\n%%time \n\nasync def test(x):\n    print('enter test - waiting', x)\n    await asyncio.sleep(x)\n    return x\n\n@run_in_process\nasync def main(k_max=3):\n    coros = []\n    for k in range(k_max):\n        coros.append(test(k))\n    await asyncio.gather(*coros)\n\nmain(k_max=4)\n\nenter test - waiting 0\nenter test - waiting 1\nenter test - waiting 2\nenter test - waiting 3\nCPU times: user 0 ns, sys: 13.2 ms, total: 13.2 ms\nWall time: 3.03 s",
    "crumbs": [
      "Travaux Pratiques",
      "TP - Creer un outil de récupération de donnée"
    ]
  },
  {
    "objectID": "content/Cours_4/TP_OOP_n_ASYNC.html#enfin-regardons-pourquoi-lon-utilisait-asyncio.sleep-à-la-place-de-time.sleep",
    "href": "content/Cours_4/TP_OOP_n_ASYNC.html#enfin-regardons-pourquoi-lon-utilisait-asyncio.sleep-à-la-place-de-time.sleep",
    "title": "TP - Creer un outil de récupération de donnée",
    "section": "Enfin, regardons pourquoi l’on utilisait asyncio.sleep à la place de time.sleep",
    "text": "Enfin, regardons pourquoi l’on utilisait asyncio.sleep à la place de time.sleep\n\n%%time \n\nimport time\n\nasync def test(x):\n    print('enter test - waiting', x)\n    time.sleep(x)\n    return x\n\n@run_in_process\nasync def main(k_max=3):\n    coros = []\n    for k in range(k_max):\n        coros.append(test(k))\n    await asyncio.gather(*coros)\n\nmain(k_max=4)\n\nenter test - waiting 0\nenter test - waiting 1\nenter test - waiting 2\nenter test - waiting 3\nCPU times: user 0 ns, sys: 13.9 ms, total: 13.9 ms\nWall time: 6.02 s\n\n\n\ntime.sleep est une fonction bloquante, cela veut dire que l’on ne peux pas effectuer d’autre coroutine en attendant que time.sleep s’execute !\n\n\nC’est le cas pour toute fonction bloquante !\n\n\nCependant il est possible de deleguer une fonction bloquante à un executor (qui est simplement un autre thread qui va se charger d’executer le code de la fonction)\nAvec cette option n’importe quel code peut être rendu asynchrone Toutefois si le code est CPU bound - c’est à dire que contrairement à sleep il demande au thread d’effectuer des taches - alors cela aura peut d’interet !\n\n%%time \n\ndef test(x):\n    print('enter test - waiting', x)\n    time.sleep(x)\n    return x\n\nasync def atest(x):\n    loop = asyncio.get_event_loop()\n    f = lambda : test(x)\n    await loop.run_in_executor(None, f)\n\n@run_in_process\nasync def main(k_max=3):\n    coros = []\n    loop = asyncio.get_event_loop()\n    for k in range(k_max):\n        coros.append(atest(k))\n    await asyncio.gather(*coros)\n\nmain(k_max=4)\n\nenter test - waitingenter test - waitingenter test - waitingenter test - waiting    203\n1\n\n\nCPU times: user 1.69 ms, sys: 11.7 ms, total: 13.4 ms\nWall time: 3.02 s",
    "crumbs": [
      "Travaux Pratiques",
      "TP - Creer un outil de récupération de donnée"
    ]
  },
  {
    "objectID": "content/Cours_4/tp_option_seller_corrected.html",
    "href": "content/Cours_4/tp_option_seller_corrected.html",
    "title": "TP Python for Finance: Introduction to Option Pricing - Corrected Version",
    "section": "",
    "text": "Using the yfinance library, download daily price data for the stock “AAPL” (Apple Inc.) for the last year. Calculate and plot the daily returns of the stock.\n\n\nimport yfinance as yf\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Download the data\nticker = \"AAPL\"\nstart_date = \"2020-01-01\"\nend_date = \"2024-12-31\"\n\n# Your code here to:\n# 1. Download the data using yfinance\n# 2. Calculate daily returns\n# 3. Create a plot of the stock price and returns\n\n# Download the data\nstock_data = yf.download(ticker, start=start_date, end=end_date)\n\n# Calculate daily returns\nstock_data['Returns'] = stock_data['Close'].pct_change()\n\n# Create subplots\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8))\n\n# Plot stock price\nax1.plot(stock_data.index, stock_data['Close'])\nax1.set_title('AAPL Stock Price')\nax1.set_xlabel('Date')\nax1.set_ylabel('Price')\n\n# Plot returns\nax2.plot(stock_data.index, stock_data['Returns'])\nax2.set_title('AAPL Daily Returns')\nax2.set_xlabel('Date')\nax2.set_ylabel('Returns')\n\nplt.tight_layout()\nplt.show()\n\n[*********************100%***********************]  1 of 1 completed"
  },
  {
    "objectID": "content/Cours_4/tp_option_seller_corrected.html#question-1-data-collection",
    "href": "content/Cours_4/tp_option_seller_corrected.html#question-1-data-collection",
    "title": "TP Python for Finance: Introduction to Option Pricing - Corrected Version",
    "section": "",
    "text": "Using the yfinance library, download daily price data for the stock “AAPL” (Apple Inc.) for the last year. Calculate and plot the daily returns of the stock.\n\n\nimport yfinance as yf\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Download the data\nticker = \"AAPL\"\nstart_date = \"2020-01-01\"\nend_date = \"2024-12-31\"\n\n# Your code here to:\n# 1. Download the data using yfinance\n# 2. Calculate daily returns\n# 3. Create a plot of the stock price and returns\n\n# Download the data\nstock_data = yf.download(ticker, start=start_date, end=end_date)\n\n# Calculate daily returns\nstock_data['Returns'] = stock_data['Close'].pct_change()\n\n# Create subplots\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8))\n\n# Plot stock price\nax1.plot(stock_data.index, stock_data['Close'])\nax1.set_title('AAPL Stock Price')\nax1.set_xlabel('Date')\nax1.set_ylabel('Price')\n\n# Plot returns\nax2.plot(stock_data.index, stock_data['Returns'])\nax2.set_title('AAPL Daily Returns')\nax2.set_xlabel('Date')\nax2.set_ylabel('Returns')\n\nplt.tight_layout()\nplt.show()\n\n[*********************100%***********************]  1 of 1 completed"
  },
  {
    "objectID": "content/Cours_4/tp_option_seller_corrected.html#question-2-understanding-call-options",
    "href": "content/Cours_4/tp_option_seller_corrected.html#question-2-understanding-call-options",
    "title": "TP Python for Finance: Introduction to Option Pricing - Corrected Version",
    "section": "Question 2: Understanding Call Options",
    "text": "Question 2: Understanding Call Options\nA Call option is a financial contract that gives the buyer the right (but not the obligation) to buy a stock at a predetermined price (strike price) at a future date (expiration date). The seller of the option (writer) receives a premium for taking on the obligation to sell at the strike price if the buyer exercises their right.\nExample: If you buy a call option for AAPL with: - Strike price (K) = $180 - Current price (S) = $170 - Expiration = 1 month\nIf at expiration: - AAPL price = $190: Your profit = $190 - $180 = $10 (minus the premium paid) - AAPL price = $170: Your loss = premium paid\nCreate a function that calculates the payoff of a call option at expiration.\n\n# Your code here to:\n# Create a function that takes as input:\n# - Strike price (K)\n# - Current price (S)\n# And returns the payoff at expiration\n\n## Correction 2:\n\ndef call_payoff(S, K):\n    \"\"\"\n    Calculate the payoff of a call option at expiration\n    \n    Parameters:\n    S (float): Stock price at expiration\n    K (float): Strike price\n    \n    Returns:\n    float: Payoff of the call option\n    \"\"\"\n    return max(S - K, 0)\n\n# Test the function\ntest_prices = [160, 170, 180, 190, 200]\nstrike = 180\n\nprint(\"Testing call option payoff with strike price =\", strike)\nfor price in test_prices:\n    print(f\"Stock price: {price}, Payoff: {call_payoff(price, strike)}\")\n\nTesting call option payoff with strike price = 180\nStock price: 160, Payoff: 0\nStock price: 170, Payoff: 0\nStock price: 180, Payoff: 0\nStock price: 190, Payoff: 10\nStock price: 200, Payoff: 20"
  },
  {
    "objectID": "content/Cours_4/tp_option_seller_corrected.html#question-3-monte-carlo-simulation",
    "href": "content/Cours_4/tp_option_seller_corrected.html#question-3-monte-carlo-simulation",
    "title": "TP Python for Finance: Introduction to Option Pricing - Corrected Version",
    "section": "Question 3: Monte Carlo Simulation",
    "text": "Question 3: Monte Carlo Simulation\nCreate a function that simulates future stock prices using Monte Carlo simulation. We’ll use the following assumptions: - Stock returns are normally distributed (Note: This is a simplifying assumption that doesn’t hold well in reality) - The volatility is estimated from historical data\n\n# Your code here to:\n# 1. Create a function that simulates stock paths\n# 2. Use it to estimate option prices\n\ndef simulate_stock_price(S0, sigma, T, n_simulations):\n    \"\"\"\n    Simulate future stock prices using Monte Carlo\n    \n    Parameters:\n    S0 (float): Initial stock price\n    sigma (float): Volatility (annualized)\n    T (float): Time to expiration (in years)\n    n_simulations (int): Number of simulations\n    \n    Returns:\n    numpy.array: Array of simulated prices\n    \"\"\"\n    # Generate random returns\n    Z = np.random.normal(0, 1, n_simulations)\n    \n    # Calculate final stock prices\n    ST = S0 * np.exp(sigma * np.sqrt(T) * Z - 0.5 * sigma**2 * T)\n    \n    return ST\n\ndef estimate_call_price(S0, K, sigma, T, n_simulations):\n    \"\"\"\n    Estimate call option price using Monte Carlo simulation\n    \"\"\"\n    # Simulate final stock prices\n    ST = simulate_stock_price(S0, sigma, T, n_simulations)\n    \n    # Calculate payoffs\n    payoffs = np.maximum(ST - K, 0)\n    \n    # Calculate option price (simplified - no discounting)\n    option_price = np.mean(payoffs)\n    \n    return option_price\n\n# Test the functions\nS0 = 170  # Current stock price\nK = 180   # Strike price\nsigma = 0.2  # Volatility (20%)\nT = 1/12    # Time to expiration (1 month)\nn_simulations = 10000\n\nprice = estimate_call_price(S0, K, sigma, T, n_simulations)\nprint(f\"Estimated call option price: {price:.2f}\")\n\nEstimated call option price: 0.81"
  },
  {
    "objectID": "content/Cours_4/tp_option_seller_corrected.html#question-4-competing-option-sellers",
    "href": "content/Cours_4/tp_option_seller_corrected.html#question-4-competing-option-sellers",
    "title": "TP Python for Finance: Introduction to Option Pricing - Corrected Version",
    "section": "Question 4: Competing Option Sellers",
    "text": "Question 4: Competing Option Sellers\nTwo option sellers are competing in the market. They use different methods to estimate volatility: - Seller 1: Uses 5-day rolling standard deviation - Seller 2: Uses 10-day rolling standard deviation\nFollow these steps to simulate their competition:\n\nFirst, calculate the rolling volatility for each seller:\n\nUse rolling() function with window=5 for seller 1\nUse rolling() function with window=10 for seller 2\nDon’t forget to use .std() to get the standard deviation\n\nFor each day, calculate the option price that each seller would offer:\n\nUse the estimate_call_price function we created earlier\nYou can use apply() with a lambda function to calculate prices\nEach seller uses their own volatility estimate\n\nDetermine which seller makes the sale:\n\nThe seller with the lower price wins the trade\nUse comparison operators and astype(int) to create indicator variables\n\nCalculate the payoff of the options:\n\nRemember: payoff = max(0, future_price - strike_price)\nUse shift(-1) to get the next day’s price\nUse apply() with lambda x: max(x, 0) for the payoff\n\nCalculate the PnL for each seller:\n\nPnL = (premium received - option payoff) when seller wins the trade\nUse the indicator variables from step 3\n\nPlot the cumulative PnL:\n\nUse cumsum() to calculate cumulative sums\nUse plot() to visualize the results\n\n\n\n# Your code here:\n\n# 1. Calculate rolling volatilities\nstock_data['vol_5d'] = ...\nstock_data['vol_10d'] = ...\n\n# 2. Calculate option prices for each seller\nstock_data['seller_1_price'] = ...\nstock_data['seller_2_price'] = ...\n\n# 3. Determine who makes each sale\nstock_data['seller_1_sold'] = ...\nstock_data['seller_2_sold'] = ...\n\n# 4. Calculate option payoffs\nstock_data['Option Payoff'] = ...\n\n# 5. Calculate PnL for each seller\nstock_data['seller_1_pnl'] = ...\nstock_data['seller_2_pnl'] = ...\n\n# 6. Plot cumulative PnL\n...\n\nstock_data['vol_5d'] = stock_data['Returns'].rolling(5).std()\nstock_data['vol_10d'] = stock_data['Returns'].rolling(10).std()\nstock_data['seller_1_price'] = stock_data.apply(lambda x: estimate_call_price(x['Close']['AAPL'], x['Close']['AAPL'], x['vol_5d'].values, 1, 10000), axis=1)\nstock_data['seller_2_price'] = stock_data.apply(lambda x: estimate_call_price(x['Close']['AAPL'], x['Close']['AAPL'], x['vol_10d'].values, 1, 10000), axis=1)\nstock_data['seller_1_sold'] = (stock_data['seller_1_price'] &lt;  stock_data['seller_2_price']).astype(int)\nstock_data['seller_2_sold'] = 1 - stock_data['seller_1_sold']\nstock_data['Option Payoff'] = (stock_data['Close']['AAPL'].shift(-1) - stock_data['Close']['AAPL']).apply(lambda x: max(x, 0))\nstock_data['seller_1_pnl'] = stock_data['seller_1_sold'] * (stock_data['seller_1_price'] - stock_data['Option Payoff'])\nstock_data['seller_2_pnl'] = stock_data['seller_2_sold'] * (stock_data['seller_2_price'] - stock_data['Option Payoff'])\nstock_data['seller_1_pnl'].cumsum().plot()\nstock_data['seller_2_pnl'].cumsum().plot()\n\n\n\n\n\n\n\n\n\nQuestion 4.2:\nCreate the degenerated case with only one option seller, and see how the choice of sigma impact the obtained PnL\n\nstock_data['vol_5d'] = stock_data['Returns'].rolling(10).std() \nstock_data['seller_1_price'] = stock_data.apply(lambda x: estimate_call_price(x['Close']['AAPL'], x['Close']['AAPL'], x['vol_5d'].values, 1, 10000), axis=1)\nstock_data['seller_1_sold'] = 1\nstock_data['Option Payoff'] = (stock_data['Close']['AAPL'].shift(-1) - stock_data['Close']['AAPL']).apply(lambda x: max(x, 0))\nstock_data['seller_1_pnl'] = stock_data['seller_1_sold'] * (stock_data['seller_1_price'] - stock_data['Option Payoff'])\nstock_data['seller_1_pnl'].cumsum().plot(label = 'base sigma')\n\nstock_data['vol_5d'] = stock_data['Returns'].rolling(10).std() * 1.2\nstock_data['seller_1_price'] = stock_data.apply(lambda x: estimate_call_price(x['Close']['AAPL'], x['Close']['AAPL'], x['vol_5d'].values, 1, 10000), axis=1)\nstock_data['seller_1_sold'] = 1\nstock_data['Option Payoff'] = (stock_data['Close']['AAPL'].shift(-1) - stock_data['Close']['AAPL']).apply(lambda x: max(x, 0))\nstock_data['seller_1_pnl'] = stock_data['seller_1_sold'] * (stock_data['seller_1_price'] - stock_data['Option Payoff'])\nstock_data['seller_1_pnl'].cumsum().plot(label = 'sigma x 1.2')\nplt.legend()\nplt.show()"
  },
  {
    "objectID": "content/Cours_4/3-TournonsAutourduGIL.html",
    "href": "content/Cours_4/3-TournonsAutourduGIL.html",
    "title": "Asynchronie et Multiprocessing",
    "section": "",
    "text": "Asynchronie et Multiprocessing - Quels solutions sous le joug du GIL ?\n\nVous trouverez ici les cours sur les solutions d’asynchronie et de multiprocessing en Python: Cours sur Async, thread, process\n\n\n\n\n Back to top",
    "crumbs": [
      "Asynchronie et Multiprocessing"
    ]
  },
  {
    "objectID": "content/Cours_4/portfolio_tp_uncorrected.html",
    "href": "content/Cours_4/portfolio_tp_uncorrected.html",
    "title": "Modern Portfolio Theory - Practical Work",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport yfinance as yf\nfrom scipy.optimize import minimize\nimport seaborn as sns\n\n\n\n\n\nWe will work with a diversified portfolio of major stocks covering different sectors of the economy. Using the yfinance library, retrieve daily closing prices for the following stocks from January 1st, 2015 to January 1st, 2025:\nHint: Use yf.download() function with parameters: - tickers: list or string of tickers - start: start date - end: end date - interval: ‘d’ for daily data - Use the ‘Close’ column\n\nsector_mapping = {\n    'Technology': ['AAPL', 'MSFT', 'INTC', 'CSCO', 'ORCL'],\n    'Financial': ['JPM', 'BAC', 'GS', 'MS', 'C', 'AXP', 'WFC'],\n    'Healthcare': ['JNJ', 'PFE', 'MRK', 'ABT', 'BMY'],\n    'Energy': ['XOM', 'CVX', 'COP', 'SLB', 'OXY'],\n    'Consumer_Staples': ['WMT', 'PG', 'KO', 'PEP', 'CL', 'KMB', 'GIS'],\n    'Consumer_Discretionary': ['HD', 'MCD', 'NKE', 'SBUX', 'TJX', 'LOW', 'YUM'],\n    'Industrial': ['CAT', 'BA', 'MMM', 'HON', 'GE', 'DE', 'FDX'],\n    'Materials': ['APD', 'ECL', 'NEM', 'FCX', 'PPG', 'NUE'],\n    'Telecommunications': ['VZ', 'T', 'CMCSA'],\n    'Real_Estate': ['SPG', 'PSA']\n}\n\n\n# Download the data\nstart_date = '2010-01-01'\nend_date = '2025-01-01'\n\n[*********************100%***********************]  54 of 54 completed\n\n\nFirst few rows of the price data:\nTicker          AAPL        ABT        APD        AXP         BA        BAC  \\\nDate                                                                          \n2010-01-04  6.447412  18.665758  52.804508  32.828983  43.777561  12.451034   \n2010-01-05  6.458560  18.514959  52.366360  32.756783  45.211349  12.855753   \n2010-01-06  6.355827  18.617779  51.934586  33.286285  46.582794  13.006530   \n2010-01-07  6.344077  18.772020  51.636158  33.826145  48.468563  13.435059   \n2010-01-08  6.386254  18.867979  51.966351  33.801979  48.001026  13.316021   \n\nTicker            BMY          C        CAT         CL  ...      SBUX  \\\nDate                                                    ...             \n2010-01-04  15.436789  25.928009  39.738235  28.930437  ...  8.835545   \n2010-01-05  15.195873  26.919380  40.213326  29.164408  ...  9.042539   \n2010-01-06  15.189850  27.758226  40.335484  29.098055  ...  8.977375   \n2010-01-07  15.201899  27.834469  40.498383  28.982828  ...  8.954374   \n2010-01-08  14.948930  27.376934  40.953117  28.462532  ...  8.923708   \n\nTicker            SLB        SPG         T       TJX         VZ        WFC  \\\nDate                                                                         \n2010-01-04  47.246723  39.174126  7.038978  7.384900  14.442019  18.417709   \n2010-01-05  47.380508  38.906082  7.004502  7.583662  14.468057  18.923317   \n2010-01-06  48.436508  38.469257  6.935692  7.614400  14.052043  18.950285   \n2010-01-07  48.936378  38.970608  6.857815  8.003725  13.968397  19.637922   \n2010-01-08  49.738956  38.037426  6.807579  7.899220  13.977206  19.455894   \n\nTicker            WMT        XOM        YUM  \nDate                                         \n2010-01-04  13.084426  39.272114  18.878279  \n2010-01-05  12.954136  39.425453  18.813725  \n2010-01-06  12.925184  39.766212  18.679226  \n2010-01-07  12.932426  39.641270  18.673841  \n2010-01-08  12.867274  39.482235  18.679226  \n\n[5 rows x 54 columns]\n\n\n\n\n\nCalculate the daily returns for each asset. The daily return is defined as the percentage change in price from one day to the next.\nHint: - Use the pct_change() method from pandas - Be sure to handle any missing values that might appear\n\n\n\n\nSummary statistics of daily returns:\nTicker         AAPL          ABT          APD          AXP           BA  \\\ncount   3773.000000  3773.000000  3773.000000  3773.000000  3773.000000   \nmean       0.001124     0.000568     0.000567     0.000748     0.000625   \nstd        0.017552     0.013505     0.015242     0.018248     0.022538   \nmin       -0.128647    -0.097857    -0.155518    -0.148187    -0.238484   \n25%       -0.007398    -0.006053    -0.006462    -0.007042    -0.009198   \n50%        0.001001     0.000596     0.000751     0.000768     0.000676   \n75%        0.010355     0.007639     0.008000     0.009271     0.010452   \nmax        0.119808     0.109360     0.137233     0.218822     0.243186   \n\nTicker          BAC          BMY            C          CAT           CL  ...  \\\ncount   3773.000000  3773.000000  3773.000000  3773.000000  3773.000000  ...   \nmean       0.000559     0.000449     0.000494     0.000753     0.000365  ...   \nstd        0.021172     0.014655     0.021367     0.018295     0.011262  ...   \nmin       -0.203182    -0.159851    -0.192986    -0.142822    -0.097829  ...   \n25%       -0.009895    -0.006971    -0.009486    -0.008498    -0.005121  ...   \n50%        0.000349     0.000622     0.000294     0.000584     0.000369  ...   \n75%        0.010749     0.007588     0.010222     0.010267     0.006184  ...   \nmax        0.177962     0.114425     0.179843     0.103321     0.126082  ...   \n\nTicker         SBUX          SLB          SPG            T          TJX  \\\ncount   3773.000000  3773.000000  3773.000000  3773.000000  3773.000000   \nmean       0.000768     0.000208     0.000605     0.000392     0.000864   \nstd        0.017326     0.022881     0.020546     0.012944     0.015659   \nmin       -0.162042    -0.274214    -0.267127    -0.104061    -0.203995   \n25%       -0.007363    -0.010883    -0.007593    -0.005913    -0.006955   \n50%        0.000654    -0.000108     0.000992     0.000725     0.000714   \n75%        0.008734     0.010998     0.009068     0.006838     0.008502   \nmax        0.244970     0.199080     0.278694     0.100223     0.129033   \n\nTicker           VZ          WFC          WMT          XOM          YUM  \ncount   3773.000000  3773.000000  3773.000000  3773.000000  3773.000000  \nmean       0.000333     0.000532     0.000585     0.000391     0.000631  \nstd        0.011605     0.018845     0.012085     0.015723     0.014886  \nmin       -0.074978    -0.158676    -0.113757    -0.122248    -0.188324  \n25%       -0.005823    -0.008342    -0.005145    -0.007267    -0.006211  \n50%        0.000496     0.000341     0.000679     0.000133     0.000812  \n75%        0.006458     0.009181     0.006373     0.007995     0.007590  \nmax        0.092705     0.145346     0.117085     0.126868     0.232485  \n\n[8 rows x 54 columns]\n\n\n\n\n\nCreate a visualization of the correlation between the assets using a heatmap. Also, compute and display the covariance matrix.\nHint: - Use seaborn.heatmap() for visualization - Use returns.corr() for correlation matrix - Use returns.cov() for covariance matrix\n\n\n\n\n\n\n\n\n\n\n\nCovariance Matrix:\nTicker      AAPL       ABT       APD       AXP        BA       BAC       BMY  \\\nTicker                                                                         \nAAPL    0.000308  0.000095  0.000105  0.000131  0.000152  0.000141  0.000065   \nABT     0.000095  0.000182  0.000097  0.000101  0.000103  0.000111  0.000079   \nAPD     0.000105  0.000097  0.000232  0.000135  0.000143  0.000158  0.000073   \nAXP     0.000131  0.000101  0.000135  0.000333  0.000237  0.000260  0.000081   \nBA      0.000152  0.000103  0.000143  0.000237  0.000508  0.000236  0.000082   \nBAC     0.000141  0.000111  0.000158  0.000260  0.000236  0.000448  0.000091   \nBMY     0.000065  0.000079  0.000073  0.000081  0.000082  0.000091  0.000215   \nC       0.000147  0.000114  0.000162  0.000265  0.000263  0.000383  0.000097   \nCAT     0.000128  0.000087  0.000147  0.000187  0.000200  0.000226  0.000074   \nCL      0.000059  0.000069  0.000075  0.000064  0.000070  0.000067  0.000055   \nCMCSA   0.000103  0.000081  0.000100  0.000136  0.000133  0.000153  0.000070   \nCOP     0.000111  0.000078  0.000134  0.000193  0.000209  0.000226  0.000081   \nCSCO    0.000132  0.000096  0.000110  0.000136  0.000139  0.000163  0.000073   \nCVX     0.000100  0.000080  0.000121  0.000171  0.000187  0.000194  0.000077   \nDE      0.000120  0.000085  0.000131  0.000168  0.000198  0.000198  0.000072   \nECL     0.000110  0.000097  0.000131  0.000150  0.000153  0.000159  0.000071   \nFCX     0.000186  0.000127  0.000210  0.000263  0.000292  0.000306  0.000103   \nFDX     0.000127  0.000096  0.000130  0.000163  0.000193  0.000199  0.000071   \nGE      0.000118  0.000087  0.000128  0.000196  0.000234  0.000221  0.000074   \nGIS     0.000043  0.000053  0.000058  0.000041  0.000035  0.000051  0.000046   \nGS      0.000131  0.000099  0.000136  0.000217  0.000207  0.000297  0.000081   \nHD      0.000118  0.000091  0.000107  0.000134  0.000144  0.000147  0.000070   \nHON     0.000116  0.000094  0.000130  0.000170  0.000195  0.000188  0.000078   \nINTC    0.000161  0.000108  0.000125  0.000155  0.000181  0.000171  0.000069   \nJNJ     0.000061  0.000078  0.000072  0.000075  0.000076  0.000084  0.000071   \nJPM     0.000119  0.000100  0.000139  0.000225  0.000209  0.000316  0.000083   \nKMB     0.000050  0.000062  0.000066  0.000056  0.000055  0.000058  0.000053   \nKO      0.000064  0.000065  0.000077  0.000090  0.000098  0.000088  0.000053   \nLOW     0.000122  0.000096  0.000113  0.000146  0.000159  0.000165  0.000072   \nMCD     0.000078  0.000066  0.000077  0.000098  0.000110  0.000096  0.000052   \nMMM     0.000099  0.000085  0.000112  0.000135  0.000138  0.000157  0.000071   \nMRK     0.000064  0.000084  0.000078  0.000081  0.000077  0.000096  0.000076   \nMS      0.000151  0.000124  0.000168  0.000256  0.000237  0.000365  0.000100   \nMSFT    0.000166  0.000105  0.000112  0.000136  0.000139  0.000144  0.000066   \nNEM     0.000056  0.000040  0.000070  0.000048  0.000056  0.000044  0.000036   \nNKE     0.000127  0.000093  0.000109  0.000145  0.000164  0.000148  0.000066   \nNUE     0.000125  0.000090  0.000155  0.000192  0.000200  0.000240  0.000079   \nORCL    0.000128  0.000090  0.000115  0.000135  0.000132  0.000158  0.000066   \nOXY     0.000125  0.000083  0.000147  0.000224  0.000272  0.000269  0.000080   \nPEP     0.000071  0.000069  0.000075  0.000075  0.000079  0.000078  0.000055   \nPFE     0.000072  0.000084  0.000082  0.000090  0.000092  0.000106  0.000090   \nPG      0.000063  0.000068  0.000069  0.000066  0.000066  0.000071  0.000053   \nPPG     0.000113  0.000095  0.000143  0.000167  0.000177  0.000187  0.000076   \nPSA     0.000080  0.000070  0.000084  0.000093  0.000100  0.000104  0.000056   \nSBUX    0.000128  0.000091  0.000119  0.000156  0.000169  0.000161  0.000069   \nSLB     0.000120  0.000073  0.000145  0.000219  0.000237  0.000255  0.000077   \nSPG     0.000112  0.000070  0.000114  0.000218  0.000260  0.000215  0.000071   \nT       0.000064  0.000065  0.000076  0.000099  0.000101  0.000116  0.000055   \nTJX     0.000102  0.000081  0.000099  0.000147  0.000168  0.000153  0.000060   \nVZ      0.000049  0.000057  0.000064  0.000069  0.000066  0.000083  0.000047   \nWFC     0.000119  0.000097  0.000138  0.000237  0.000227  0.000315  0.000085   \nWMT     0.000061  0.000056  0.000058  0.000056  0.000056  0.000065  0.000043   \nXOM     0.000085  0.000065  0.000106  0.000149  0.000169  0.000174  0.000066   \nYUM     0.000098  0.000079  0.000100  0.000131  0.000144  0.000134  0.000061   \n\nTicker         C       CAT        CL  ...      SBUX       SLB       SPG  \\\nTicker                                ...                                 \nAAPL    0.000147  0.000128  0.000059  ...  0.000128  0.000120  0.000112   \nABT     0.000114  0.000087  0.000069  ...  0.000091  0.000073  0.000070   \nAPD     0.000162  0.000147  0.000075  ...  0.000119  0.000145  0.000114   \nAXP     0.000265  0.000187  0.000064  ...  0.000156  0.000219  0.000218   \nBA      0.000263  0.000200  0.000070  ...  0.000169  0.000237  0.000260   \nBAC     0.000383  0.000226  0.000067  ...  0.000161  0.000255  0.000215   \nBMY     0.000097  0.000074  0.000055  ...  0.000069  0.000077  0.000071   \nC       0.000457  0.000233  0.000072  ...  0.000169  0.000279  0.000238   \nCAT     0.000233  0.000335  0.000058  ...  0.000122  0.000248  0.000160   \nCL      0.000072  0.000058  0.000127  ...  0.000071  0.000055  0.000064   \nCMCSA   0.000160  0.000127  0.000066  ...  0.000113  0.000131  0.000129   \nCOP     0.000243  0.000216  0.000055  ...  0.000123  0.000366  0.000190   \nCSCO    0.000166  0.000139  0.000068  ...  0.000120  0.000141  0.000115   \nCVX     0.000210  0.000181  0.000058  ...  0.000111  0.000286  0.000170   \nDE      0.000204  0.000229  0.000061  ...  0.000119  0.000205  0.000155   \nECL     0.000164  0.000131  0.000072  ...  0.000127  0.000139  0.000141   \nFCX     0.000327  0.000345  0.000069  ...  0.000171  0.000379  0.000240   \nFDX     0.000213  0.000179  0.000065  ...  0.000134  0.000177  0.000157   \nGE      0.000237  0.000190  0.000061  ...  0.000131  0.000222  0.000192   \nGIS     0.000048  0.000038  0.000068  ...  0.000045  0.000036  0.000032   \nGS      0.000303  0.000194  0.000061  ...  0.000139  0.000217  0.000186   \nHD      0.000153  0.000120  0.000070  ...  0.000127  0.000111  0.000139   \nHON     0.000197  0.000172  0.000066  ...  0.000127  0.000175  0.000161   \nINTC    0.000185  0.000155  0.000062  ...  0.000123  0.000153  0.000134   \nJNJ     0.000086  0.000070  0.000060  ...  0.000063  0.000068  0.000060   \nJPM     0.000315  0.000192  0.000065  ...  0.000139  0.000221  0.000188   \nKMB     0.000059  0.000049  0.000086  ...  0.000057  0.000039  0.000054   \nKO      0.000094  0.000074  0.000071  ...  0.000075  0.000082  0.000095   \nLOW     0.000173  0.000135  0.000071  ...  0.000137  0.000133  0.000157   \nMCD     0.000107  0.000077  0.000059  ...  0.000106  0.000088  0.000104   \nMMM     0.000162  0.000154  0.000065  ...  0.000101  0.000142  0.000125   \nMRK     0.000098  0.000078  0.000059  ...  0.000068  0.000083  0.000068   \nMS      0.000367  0.000232  0.000074  ...  0.000167  0.000260  0.000204   \nMSFT    0.000152  0.000123  0.000067  ...  0.000129  0.000107  0.000105   \nNEM     0.000050  0.000078  0.000038  ...  0.000045  0.000099  0.000056   \nNKE     0.000160  0.000129  0.000065  ...  0.000153  0.000125  0.000138   \nNUE     0.000252  0.000230  0.000061  ...  0.000131  0.000243  0.000180   \nORCL    0.000163  0.000136  0.000068  ...  0.000117  0.000129  0.000104   \nOXY     0.000293  0.000244  0.000058  ...  0.000142  0.000429  0.000262   \nPEP     0.000081  0.000062  0.000079  ...  0.000077  0.000062  0.000075   \nPFE     0.000109  0.000086  0.000056  ...  0.000073  0.000084  0.000079   \nPG      0.000073  0.000056  0.000085  ...  0.000066  0.000050  0.000056   \nPPG     0.000199  0.000167  0.000068  ...  0.000129  0.000165  0.000160   \nPSA     0.000107  0.000084  0.000068  ...  0.000090  0.000076  0.000139   \nSBUX    0.000169  0.000122  0.000071  ...  0.000300  0.000134  0.000157   \nSLB     0.000279  0.000248  0.000055  ...  0.000134  0.000524  0.000229   \nSPG     0.000238  0.000160  0.000064  ...  0.000157  0.000229  0.000422   \nT       0.000122  0.000090  0.000059  ...  0.000072  0.000102  0.000099   \nTJX     0.000158  0.000120  0.000062  ...  0.000125  0.000128  0.000165   \nVZ      0.000083  0.000067  0.000056  ...  0.000059  0.000066  0.000071   \nWFC     0.000311  0.000191  0.000067  ...  0.000144  0.000229  0.000205   \nWMT     0.000063  0.000054  0.000057  ...  0.000060  0.000044  0.000051   \nXOM     0.000188  0.000166  0.000052  ...  0.000093  0.000268  0.000155   \nYUM     0.000144  0.000114  0.000058  ...  0.000141  0.000113  0.000129   \n\nTicker         T       TJX        VZ       WFC       WMT       XOM       YUM  \nTicker                                                                        \nAAPL    0.000064  0.000102  0.000049  0.000119  0.000061  0.000085  0.000098  \nABT     0.000065  0.000081  0.000057  0.000097  0.000056  0.000065  0.000079  \nAPD     0.000076  0.000099  0.000064  0.000138  0.000058  0.000106  0.000100  \nAXP     0.000099  0.000147  0.000069  0.000237  0.000056  0.000149  0.000131  \nBA      0.000101  0.000168  0.000066  0.000227  0.000056  0.000169  0.000144  \nBAC     0.000116  0.000153  0.000083  0.000315  0.000065  0.000174  0.000134  \nBMY     0.000055  0.000060  0.000047  0.000085  0.000043  0.000066  0.000061  \nC       0.000122  0.000158  0.000083  0.000311  0.000063  0.000188  0.000144  \nCAT     0.000090  0.000120  0.000067  0.000191  0.000054  0.000166  0.000114  \nCL      0.000059  0.000062  0.000056  0.000067  0.000057  0.000052  0.000058  \nCMCSA   0.000093  0.000100  0.000073  0.000139  0.000057  0.000098  0.000087  \nCOP     0.000092  0.000115  0.000065  0.000201  0.000046  0.000263  0.000111  \nCSCO    0.000079  0.000102  0.000061  0.000140  0.000067  0.000103  0.000095  \nCVX     0.000089  0.000108  0.000067  0.000174  0.000047  0.000221  0.000102  \nDE      0.000085  0.000118  0.000063  0.000173  0.000055  0.000138  0.000107  \nECL     0.000078  0.000115  0.000060  0.000142  0.000055  0.000102  0.000111  \nFCX     0.000119  0.000164  0.000083  0.000259  0.000068  0.000250  0.000165  \nFDX     0.000082  0.000122  0.000063  0.000173  0.000064  0.000120  0.000106  \nGE      0.000099  0.000133  0.000070  0.000203  0.000050  0.000153  0.000111  \nGIS     0.000052  0.000037  0.000050  0.000050  0.000051  0.000039  0.000040  \nGS      0.000097  0.000130  0.000067  0.000247  0.000056  0.000146  0.000117  \nHD      0.000072  0.000125  0.000060  0.000132  0.000070  0.000086  0.000104  \nHON     0.000085  0.000121  0.000063  0.000169  0.000055  0.000122  0.000113  \nINTC    0.000080  0.000112  0.000063  0.000153  0.000065  0.000111  0.000099  \nJNJ     0.000058  0.000058  0.000053  0.000078  0.000048  0.000062  0.000058  \nJPM     0.000102  0.000135  0.000074  0.000265  0.000058  0.000152  0.000119  \nKMB     0.000058  0.000048  0.000057  0.000055  0.000053  0.000043  0.000054  \nKO      0.000065  0.000070  0.000057  0.000087  0.000049  0.000071  0.000069  \nLOW     0.000075  0.000138  0.000060  0.000146  0.000068  0.000098  0.000112  \nMCD     0.000055  0.000083  0.000045  0.000092  0.000045  0.000068  0.000103  \nMMM     0.000076  0.000095  0.000060  0.000143  0.000052  0.000102  0.000090  \nMRK     0.000061  0.000062  0.000057  0.000084  0.000048  0.000070  0.000064  \nMS      0.000114  0.000152  0.000081  0.000293  0.000070  0.000174  0.000137  \nMSFT    0.000061  0.000101  0.000054  0.000124  0.000066  0.000083  0.000104  \nNEM     0.000047  0.000023  0.000040  0.000035  0.000029  0.000072  0.000049  \nNKE     0.000070  0.000130  0.000055  0.000136  0.000059  0.000094  0.000115  \nNUE     0.000096  0.000133  0.000077  0.000209  0.000065  0.000167  0.000115  \nORCL    0.000073  0.000099  0.000057  0.000135  0.000064  0.000090  0.000089  \nOXY     0.000111  0.000131  0.000070  0.000243  0.000044  0.000303  0.000118  \nPEP     0.000061  0.000066  0.000056  0.000076  0.000060  0.000061  0.000064  \nPFE     0.000065  0.000065  0.000058  0.000096  0.000049  0.000072  0.000063  \nPG      0.000059  0.000053  0.000056  0.000068  0.000058  0.000051  0.000054  \nPPG     0.000078  0.000122  0.000062  0.000168  0.000049  0.000113  0.000117  \nPSA     0.000061  0.000080  0.000057  0.000092  0.000051  0.000064  0.000080  \nSBUX    0.000072  0.000125  0.000059  0.000144  0.000060  0.000093  0.000141  \nSLB     0.000102  0.000128  0.000066  0.000229  0.000044  0.000268  0.000113  \nSPG     0.000099  0.000165  0.000071  0.000205  0.000051  0.000155  0.000129  \nT       0.000168  0.000074  0.000101  0.000110  0.000048  0.000085  0.000063  \nTJX     0.000074  0.000245  0.000056  0.000143  0.000061  0.000097  0.000109  \nVZ      0.000101  0.000056  0.000135  0.000078  0.000046  0.000063  0.000048  \nWFC     0.000110  0.000143  0.000078  0.000355  0.000060  0.000162  0.000118  \nWMT     0.000048  0.000061  0.000046  0.000060  0.000146  0.000044  0.000045  \nXOM     0.000085  0.000097  0.000063  0.000162  0.000044  0.000247  0.000087  \nYUM     0.000063  0.000109  0.000048  0.000118  0.000045  0.000087  0.000222  \n\n[54 rows x 54 columns]\n\n\n\n\n\nCreate a plot showing the evolution of prices for all assets on the same graph. Make sure to normalize the prices to start at 100 to make them comparable.\nHint: - Normalize prices by dividing by the initial price and multiplying by 100 - Use matplotlib’s plot function - Add a legend to distinguish between assets\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreate an equally-weighted portfolio from our five assets. Calculate its daily returns and analyze its performance metrics (mean return, volatility, Sharpe ratio assuming risk-free rate = 0).\nHint: - Equal weights means 1/N for each asset - Portfolio return is the weighted sum of individual returns - Portfolio volatility requires using the covariance matrix\n\n\n\nEqual-weighted Portfolio Metrics (daily):\nMean Return: 0.0556%\nVolatility: 1.0755%\nSharpe Ratio: 0.0517\n\n\n\n\n\nWrite a function that computes the mean return and volatility of a portfolio given: - A set of weights - The mean returns of individual assets - The covariance matrix of returns\nHint: - Portfolio return = weighted sum of individual returns - Portfolio variance = w^T * Σ * w (where Σ is the covariance matrix)\n\n\n\n\nTest with equal weights:\nPortfolio Return: 0.0556%\nPortfolio Volatility: 1.0755%\n\n\n\n\n\nSplit your data into two periods: training (2020-2021) and testing (2022-2023). Calculate the mean returns and covariance matrix for the training period.\nHint: - Use datetime index to split the data - Recalculate all metrics on the training set\n\n\n\nTraining Period Statistics:\n\nMean Returns:\nTicker\nAAPL     0.001087\nABT      0.000644\nAPD      0.000630\nAXP      0.000605\nBA       0.000918\nBAC      0.000574\nBMY      0.000599\nC        0.000563\nCAT      0.000624\nCL       0.000349\nCMCSA    0.000832\nCOP      0.000472\nCSCO     0.000489\nCVX      0.000404\nDE       0.000664\nECL      0.000692\nFCX      0.000109\nFDX      0.000395\nGE       0.000142\nGIS      0.000354\nGS       0.000303\nHD       0.000980\nHON      0.000778\nINTC     0.000661\nJNJ      0.000488\nJPM      0.000689\nKMB      0.000510\nKO       0.000430\nLOW      0.000846\nMCD      0.000623\nMMM      0.000477\nMRK      0.000569\nMS       0.000478\nMSFT     0.000845\nNEM      0.000262\nNKE      0.000887\nNUE      0.000329\nORCL     0.000459\nOXY      0.000020\nPEP      0.000477\nPFE      0.000502\nPG       0.000453\nPPG      0.000765\nPSA      0.000599\nSBUX     0.000982\nSLB      0.000046\nSPG      0.000505\nT        0.000470\nTJX      0.000900\nVZ       0.000514\nWFC      0.000488\nWMT      0.000470\nXOM      0.000200\nYUM      0.000729\ndtype: float64\n\nCovariance Matrix:\nTicker      AAPL       ABT       APD       AXP        BA       BAC       BMY  \\\nTicker                                                                         \nAAPL    0.000263  0.000065  0.000078  0.000089  0.000099  0.000119  0.000058   \nABT     0.000065  0.000138  0.000072  0.000077  0.000080  0.000091  0.000072   \nAPD     0.000078  0.000072  0.000167  0.000095  0.000103  0.000129  0.000062   \nAXP     0.000089  0.000077  0.000095  0.000205  0.000112  0.000177  0.000066   \nBA      0.000099  0.000080  0.000103  0.000112  0.000244  0.000152  0.000069   \nBAC     0.000119  0.000091  0.000129  0.000177  0.000152  0.000419  0.000081   \nBMY     0.000058  0.000072  0.000062  0.000066  0.000069  0.000081  0.000211   \nC       0.000118  0.000099  0.000135  0.000171  0.000153  0.000332  0.000088   \nCAT     0.000120  0.000078  0.000127  0.000130  0.000144  0.000189  0.000068   \nCL      0.000042  0.000047  0.000056  0.000053  0.000058  0.000051  0.000045   \nCMCSA   0.000075  0.000061  0.000080  0.000092  0.000087  0.000123  0.000059   \nCOP     0.000088  0.000068  0.000097  0.000100  0.000104  0.000153  0.000061   \nCSCO    0.000105  0.000075  0.000091  0.000098  0.000103  0.000142  0.000062   \nCVX     0.000076  0.000066  0.000089  0.000089  0.000094  0.000131  0.000059   \nDE      0.000101  0.000070  0.000105  0.000107  0.000123  0.000159  0.000061   \nECL     0.000067  0.000065  0.000089  0.000079  0.000085  0.000111  0.000058   \nFCX     0.000149  0.000111  0.000167  0.000176  0.000178  0.000255  0.000091   \nFDX     0.000094  0.000078  0.000106  0.000114  0.000125  0.000171  0.000067   \nGE      0.000086  0.000069  0.000095  0.000109  0.000107  0.000161  0.000063   \nGIS     0.000034  0.000038  0.000044  0.000040  0.000041  0.000047  0.000034   \nGS      0.000100  0.000080  0.000110  0.000138  0.000122  0.000251  0.000071   \nHD      0.000076  0.000063  0.000076  0.000090  0.000088  0.000115  0.000059   \nHON     0.000093  0.000076  0.000106  0.000110  0.000124  0.000152  0.000068   \nINTC    0.000107  0.000077  0.000086  0.000097  0.000102  0.000129  0.000063   \nJNJ     0.000045  0.000057  0.000055  0.000059  0.000062  0.000069  0.000059   \nJPM     0.000095  0.000081  0.000111  0.000144  0.000125  0.000268  0.000075   \nKMB     0.000032  0.000044  0.000050  0.000042  0.000047  0.000046  0.000045   \nKO      0.000039  0.000043  0.000051  0.000051  0.000052  0.000057  0.000039   \nLOW     0.000077  0.000066  0.000082  0.000096  0.000094  0.000133  0.000061   \nMCD     0.000047  0.000043  0.000050  0.000050  0.000052  0.000060  0.000038   \nMMM     0.000082  0.000069  0.000089  0.000094  0.000101  0.000127  0.000060   \nMRK     0.000052  0.000074  0.000066  0.000072  0.000067  0.000090  0.000062   \nMS      0.000119  0.000105  0.000142  0.000178  0.000156  0.000338  0.000090   \nMSFT    0.000106  0.000076  0.000086  0.000097  0.000096  0.000125  0.000060   \nNEM     0.000043  0.000022  0.000046  0.000035  0.000035  0.000029  0.000029   \nNKE     0.000082  0.000066  0.000082  0.000093  0.000094  0.000114  0.000057   \nNUE     0.000097  0.000077  0.000119  0.000118  0.000124  0.000188  0.000070   \nORCL    0.000095  0.000073  0.000094  0.000100  0.000101  0.000140  0.000064   \nOXY     0.000088  0.000069  0.000103  0.000097  0.000108  0.000159  0.000062   \nPEP     0.000038  0.000041  0.000046  0.000046  0.000048  0.000049  0.000040   \nPFE     0.000059  0.000069  0.000065  0.000074  0.000068  0.000096  0.000077   \nPG      0.000039  0.000041  0.000044  0.000047  0.000047  0.000050  0.000041   \nPPG     0.000085  0.000078  0.000115  0.000106  0.000110  0.000149  0.000067   \nPSA     0.000051  0.000045  0.000062  0.000068  0.000069  0.000089  0.000044   \nSBUX    0.000087  0.000063  0.000087  0.000093  0.000090  0.000116  0.000058   \nSLB     0.000102  0.000068  0.000111  0.000109  0.000116  0.000177  0.000061   \nSPG     0.000066  0.000053  0.000070  0.000084  0.000081  0.000114  0.000050   \nT       0.000046  0.000044  0.000051  0.000057  0.000056  0.000075  0.000041   \nTJX     0.000067  0.000060  0.000064  0.000075  0.000078  0.000099  0.000049   \nVZ      0.000037  0.000044  0.000048  0.000052  0.000049  0.000063  0.000038   \nWFC     0.000090  0.000077  0.000103  0.000137  0.000122  0.000234  0.000069   \nWMT     0.000040  0.000044  0.000041  0.000047  0.000049  0.000057  0.000039   \nXOM     0.000067  0.000059  0.000080  0.000078  0.000086  0.000116  0.000053   \nYUM     0.000075  0.000060  0.000079  0.000084  0.000086  0.000109  0.000055   \n\nTicker         C       CAT        CL  ...      SBUX       SLB       SPG  \\\nTicker                                ...                                 \nAAPL    0.000118  0.000120  0.000042  ...  0.000087  0.000102  0.000066   \nABT     0.000099  0.000078  0.000047  ...  0.000063  0.000068  0.000053   \nAPD     0.000135  0.000127  0.000056  ...  0.000087  0.000111  0.000070   \nAXP     0.000171  0.000130  0.000053  ...  0.000093  0.000109  0.000084   \nBA      0.000153  0.000144  0.000058  ...  0.000090  0.000116  0.000081   \nBAC     0.000332  0.000189  0.000051  ...  0.000116  0.000177  0.000114   \nBMY     0.000088  0.000068  0.000045  ...  0.000058  0.000061  0.000050   \nC       0.000381  0.000192  0.000059  ...  0.000117  0.000181  0.000114   \nCAT     0.000192  0.000293  0.000052  ...  0.000095  0.000179  0.000092   \nCL      0.000059  0.000052  0.000105  ...  0.000058  0.000050  0.000053   \nCMCSA   0.000125  0.000109  0.000052  ...  0.000080  0.000096  0.000077   \nCOP     0.000153  0.000162  0.000047  ...  0.000072  0.000199  0.000073   \nCSCO    0.000141  0.000126  0.000054  ...  0.000089  0.000112  0.000076   \nCVX     0.000135  0.000135  0.000049  ...  0.000069  0.000158  0.000074   \nDE      0.000159  0.000190  0.000050  ...  0.000083  0.000140  0.000081   \nECL     0.000112  0.000103  0.000052  ...  0.000077  0.000096  0.000061   \nFCX     0.000260  0.000310  0.000063  ...  0.000110  0.000279  0.000120   \nFDX     0.000173  0.000158  0.000053  ...  0.000095  0.000135  0.000088   \nGE      0.000165  0.000138  0.000050  ...  0.000083  0.000135  0.000082   \nGIS     0.000047  0.000040  0.000051  ...  0.000042  0.000042  0.000046   \nGS      0.000243  0.000154  0.000047  ...  0.000089  0.000142  0.000086   \nHD      0.000116  0.000097  0.000050  ...  0.000087  0.000082  0.000075   \nHON     0.000154  0.000149  0.000058  ...  0.000094  0.000126  0.000084   \nINTC    0.000134  0.000128  0.000046  ...  0.000077  0.000106  0.000072   \nJNJ     0.000074  0.000061  0.000045  ...  0.000051  0.000059  0.000047   \nJPM     0.000257  0.000155  0.000052  ...  0.000094  0.000148  0.000093   \nKMB     0.000049  0.000046  0.000069  ...  0.000047  0.000038  0.000050   \nKO      0.000061  0.000054  0.000052  ...  0.000049  0.000051  0.000050   \nLOW     0.000131  0.000111  0.000051  ...  0.000093  0.000098  0.000081   \nMCD     0.000064  0.000055  0.000042  ...  0.000068  0.000048  0.000046   \nMMM     0.000128  0.000130  0.000052  ...  0.000073  0.000113  0.000073   \nMRK     0.000092  0.000074  0.000046  ...  0.000060  0.000067  0.000058   \nMS      0.000328  0.000198  0.000063  ...  0.000120  0.000192  0.000114   \nMSFT    0.000129  0.000116  0.000050  ...  0.000091  0.000091  0.000066   \nNEM     0.000037  0.000075  0.000027  ...  0.000025  0.000086  0.000044   \nNKE     0.000120  0.000103  0.000051  ...  0.000099  0.000092  0.000075   \nNUE     0.000188  0.000179  0.000052  ...  0.000093  0.000163  0.000091   \nORCL    0.000146  0.000125  0.000053  ...  0.000090  0.000117  0.000076   \nOXY     0.000164  0.000161  0.000049  ...  0.000082  0.000202  0.000087   \nPEP     0.000055  0.000046  0.000053  ...  0.000046  0.000044  0.000046   \nPFE     0.000099  0.000079  0.000041  ...  0.000061  0.000075  0.000061   \nPG      0.000056  0.000047  0.000063  ...  0.000047  0.000044  0.000046   \nPPG     0.000153  0.000143  0.000059  ...  0.000088  0.000121  0.000084   \nPSA     0.000090  0.000073  0.000050  ...  0.000068  0.000068  0.000111   \nSBUX    0.000117  0.000095  0.000058  ...  0.000221  0.000088  0.000079   \nSLB     0.000181  0.000179  0.000050  ...  0.000088  0.000309  0.000091   \nSPG     0.000114  0.000092  0.000053  ...  0.000079  0.000091  0.000174   \nT       0.000080  0.000069  0.000043  ...  0.000047  0.000066  0.000052   \nTJX     0.000101  0.000082  0.000046  ...  0.000079  0.000071  0.000070   \nVZ      0.000067  0.000056  0.000044  ...  0.000047  0.000053  0.000055   \nWFC     0.000221  0.000139  0.000051  ...  0.000097  0.000136  0.000094   \nWMT     0.000060  0.000049  0.000042  ...  0.000049  0.000041  0.000048   \nXOM     0.000121  0.000118  0.000047  ...  0.000061  0.000137  0.000066   \nYUM     0.000114  0.000098  0.000050  ...  0.000102  0.000078  0.000069   \n\nTicker         T       TJX        VZ       WFC       WMT       XOM       YUM  \nTicker                                                                        \nAAPL    0.000046  0.000067  0.000037  0.000090  0.000040  0.000067  0.000075  \nABT     0.000044  0.000060  0.000044  0.000077  0.000044  0.000059  0.000060  \nAPD     0.000051  0.000064  0.000048  0.000103  0.000041  0.000080  0.000079  \nAXP     0.000057  0.000075  0.000052  0.000137  0.000047  0.000078  0.000084  \nBA      0.000056  0.000078  0.000049  0.000122  0.000049  0.000086  0.000086  \nBAC     0.000075  0.000099  0.000063  0.000234  0.000057  0.000116  0.000109  \nBMY     0.000041  0.000049  0.000038  0.000069  0.000039  0.000053  0.000055  \nC       0.000080  0.000101  0.000067  0.000221  0.000060  0.000121  0.000114  \nCAT     0.000069  0.000082  0.000056  0.000139  0.000049  0.000118  0.000098  \nCL      0.000043  0.000046  0.000044  0.000051  0.000042  0.000047  0.000050  \nCMCSA   0.000064  0.000069  0.000058  0.000104  0.000048  0.000076  0.000072  \nCOP     0.000056  0.000063  0.000050  0.000117  0.000040  0.000139  0.000076  \nCSCO    0.000057  0.000074  0.000048  0.000110  0.000051  0.000082  0.000078  \nCVX     0.000058  0.000060  0.000054  0.000106  0.000041  0.000124  0.000066  \nDE      0.000061  0.000072  0.000052  0.000121  0.000043  0.000091  0.000082  \nECL     0.000046  0.000063  0.000044  0.000088  0.000039  0.000071  0.000072  \nFCX     0.000089  0.000105  0.000075  0.000187  0.000061  0.000176  0.000119  \nFDX     0.000062  0.000085  0.000052  0.000132  0.000053  0.000091  0.000091  \nGE      0.000066  0.000074  0.000058  0.000125  0.000044  0.000092  0.000074  \nGIS     0.000039  0.000038  0.000040  0.000044  0.000037  0.000038  0.000039  \nGS      0.000064  0.000078  0.000052  0.000172  0.000047  0.000097  0.000086  \nHD      0.000050  0.000086  0.000046  0.000094  0.000053  0.000064  0.000075  \nHON     0.000059  0.000078  0.000053  0.000122  0.000050  0.000087  0.000086  \nINTC    0.000054  0.000072  0.000048  0.000101  0.000045  0.000082  0.000077  \nJNJ     0.000041  0.000042  0.000043  0.000063  0.000037  0.000053  0.000048  \nJPM     0.000068  0.000083  0.000060  0.000189  0.000051  0.000103  0.000092  \nKMB     0.000043  0.000039  0.000048  0.000045  0.000041  0.000042  0.000046  \nKO      0.000040  0.000038  0.000043  0.000054  0.000037  0.000046  0.000046  \nLOW     0.000052  0.000092  0.000047  0.000106  0.000055  0.000073  0.000079  \nMCD     0.000033  0.000046  0.000035  0.000053  0.000035  0.000042  0.000067  \nMMM     0.000053  0.000063  0.000050  0.000102  0.000045  0.000080  0.000070  \nMRK     0.000049  0.000050  0.000050  0.000074  0.000042  0.000061  0.000058  \nMS      0.000082  0.000102  0.000069  0.000227  0.000062  0.000125  0.000108  \nMSFT    0.000051  0.000066  0.000049  0.000099  0.000048  0.000074  0.000086  \nNEM     0.000031  0.000011  0.000027  0.000022  0.000015  0.000057  0.000026  \nNKE     0.000048  0.000089  0.000044  0.000096  0.000049  0.000065  0.000083  \nNUE     0.000068  0.000080  0.000060  0.000139  0.000054  0.000111  0.000087  \nORCL    0.000056  0.000071  0.000048  0.000106  0.000046  0.000083  0.000079  \nOXY     0.000060  0.000068  0.000052  0.000123  0.000039  0.000132  0.000078  \nPEP     0.000037  0.000038  0.000042  0.000047  0.000038  0.000042  0.000042  \nPFE     0.000047  0.000051  0.000046  0.000081  0.000041  0.000063  0.000055  \nPG      0.000039  0.000036  0.000042  0.000047  0.000040  0.000044  0.000041  \nPPG     0.000057  0.000079  0.000055  0.000118  0.000046  0.000086  0.000086  \nPSA     0.000042  0.000056  0.000046  0.000076  0.000040  0.000050  0.000065  \nSBUX    0.000047  0.000079  0.000047  0.000097  0.000049  0.000061  0.000102  \nSLB     0.000066  0.000071  0.000053  0.000136  0.000041  0.000137  0.000078  \nSPG     0.000052  0.000070  0.000055  0.000094  0.000048  0.000066  0.000069  \nT       0.000111  0.000045  0.000073  0.000066  0.000039  0.000056  0.000044  \nTJX     0.000045  0.000172  0.000043  0.000082  0.000050  0.000056  0.000070  \nVZ      0.000073  0.000043  0.000111  0.000059  0.000040  0.000048  0.000043  \nWFC     0.000066  0.000082  0.000059  0.000229  0.000050  0.000097  0.000088  \nWMT     0.000039  0.000050  0.000040  0.000050  0.000118  0.000039  0.000041  \nXOM     0.000056  0.000056  0.000048  0.000097  0.000039  0.000136  0.000061  \nYUM     0.000044  0.000070  0.000043  0.000088  0.000041  0.000061  0.000198  \n\n[54 rows x 54 columns]\n\n\n\n\n\nCreate a function to generate random portfolio weights and use it to create the efficient frontier visualization. Generate 1000 random portfolios and plot them on a risk-return graph.\nHint: - Use np.random.random() to generate weights - Normalize weights to sum to 1 - Store results in arrays for plotting - Highlight the minimum variance and maximum Sharpe ratio portfolios\n\n\n\n\n\n\n\n\n\n\n\n\n\nUse scipy’s optimize function to find the minimum variance portfolio and the maximum Sharpe ratio portfolio. Make sure to include the constraint that weights must sum to 1 and be non-negative.\nHint: - Use scipy.optimize.minimize - Define objective functions for minimum variance and maximum Sharpe ratio - Use SLSQP optimizer - Check the optimization success flag\n\n\n\n\nMinimum Variance Portfolio:\nAAPL: 0.0134\nMSFT: 0.0049\nINTC: 0.0000\nCSCO: 0.0000\nORCL: 0.0000\nJPM: 0.0000\nBAC: 0.0103\nGS: 0.0000\nMS: 0.0000\nC: 0.0000\nAXP: 0.0000\nWFC: 0.0000\nJNJ: 0.0000\nPFE: 0.0000\nMRK: 0.0000\nABT: 0.0000\nBMY: 0.0000\nXOM: 0.0000\nCVX: 0.0000\nCOP: 0.0846\nSLB: 0.0000\nOXY: 0.0000\nWMT: 0.0000\nPG: 0.0000\nKO: 0.0952\nPEP: 0.0000\nCL: 0.0342\nKMB: 0.0841\nGIS: 0.0000\nHD: 0.1474\nMCD: 0.0000\nNKE: 0.0015\nSBUX: 0.0000\nTJX: 0.0000\nLOW: 0.0445\nYUM: 0.0000\nCAT: 0.0000\nBA: 0.0000\nMMM: 0.0000\nHON: 0.1014\nGE: 0.0133\nDE: 0.0877\nFDX: 0.0000\nAPD: 0.0061\nECL: 0.0000\nNEM: 0.0000\nFCX: 0.0000\nPPG: 0.0696\nNUE: 0.0297\nVZ: 0.0575\nT: 0.0000\nCMCSA: 0.1146\nSPG: 0.0000\nPSA: 0.0000\nExpected Return: 0.0499%\nVolatility: 0.6731%\n\nMaximum Sharpe Ratio Portfolio:\nAAPL: 0.1639\nMSFT: 0.0000\nINTC: 0.0000\nCSCO: 0.0000\nORCL: 0.0310\nJPM: 0.0000\nBAC: 0.0101\nGS: 0.0000\nMS: 0.0000\nC: 0.0000\nAXP: 0.0556\nWFC: 0.0000\nJNJ: 0.0000\nPFE: 0.0000\nMRK: 0.0000\nABT: 0.0000\nBMY: 0.0000\nXOM: 0.0000\nCVX: 0.0000\nCOP: 0.0000\nSLB: 0.0000\nOXY: 0.2121\nWMT: 0.0000\nPG: 0.0000\nKO: 0.0000\nPEP: 0.0000\nCL: 0.0647\nKMB: 0.0000\nGIS: 0.0000\nHD: 0.1537\nMCD: 0.0000\nNKE: 0.0000\nSBUX: 0.0000\nTJX: 0.0015\nLOW: 0.0009\nYUM: 0.0187\nCAT: 0.0000\nBA: 0.0000\nMMM: 0.0000\nHON: 0.0285\nGE: 0.0000\nDE: 0.0000\nFDX: 0.0000\nAPD: 0.0000\nECL: 0.0780\nNEM: 0.0000\nFCX: 0.0000\nPPG: 0.0000\nNUE: 0.1387\nVZ: 0.0425\nT: 0.0000\nCMCSA: 0.0000\nSPG: 0.0000\nPSA: 0.0000\nExpected Return: 0.0850%\nVolatility: 0.8703%\n\n\n\n\n\nBacktest your optimized portfolios (minimum variance and maximum Sharpe ratio) on the test period. Compare their performance with the equally-weighted portfolio.\nHint: - Use the weights found in the training period - Calculate cumulative returns for each portfolio - Plot the evolution of portfolio values - Calculate key performance metrics (return, volatility, Sharpe ratio, maximum drawdown)\n\n\n\n\n\n\n\n\n\n\n\nTrain Period Performance:\n\nEqual Weight:\nMean Return: 0.0553%\nVolatility: 0.9158%\nSharpe Ratio: 6.0422%\nCumulative Return: 261.7286%\n\nMin Variance:\nMean Return: 0.0499%\nVolatility: 0.6731%\nSharpe Ratio: 7.4197%\nCumulative Return: 231.6049%\n\nMax Sharpe:\nMean Return: 0.0850%\nVolatility: 0.8703%\nSharpe Ratio: 9.7722%\nCumulative Return: 671.2589%\n\nTest Period Performance:\n\nEqual Weight:\nMean Return: 0.0563%\nVolatility: 1.3392%\nSharpe Ratio: 4.2020%\nCumulative Return: 81.2116%\n\nMin Variance:\nMean Return: 0.0390%\nVolatility: 1.0081%\nSharpe Ratio: 3.8640%\nCumulative Return: 53.1191%\n\nMax Sharpe:\nMean Return: 0.0595%\nVolatility: 1.3445%\nSharpe Ratio: 4.4278%\nCumulative Return: 88.5475%",
    "crumbs": [
      "Travaux Pratiques",
      "Modern Portfolio Theory - Practical Work"
    ]
  },
  {
    "objectID": "content/Cours_4/portfolio_tp_uncorrected.html#l3-finance",
    "href": "content/Cours_4/portfolio_tp_uncorrected.html#l3-finance",
    "title": "Modern Portfolio Theory - Practical Work",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport yfinance as yf\nfrom scipy.optimize import minimize\nimport seaborn as sns\n\n\n\n\n\nWe will work with a diversified portfolio of major stocks covering different sectors of the economy. Using the yfinance library, retrieve daily closing prices for the following stocks from January 1st, 2015 to January 1st, 2025:\nHint: Use yf.download() function with parameters: - tickers: list or string of tickers - start: start date - end: end date - interval: ‘d’ for daily data - Use the ‘Close’ column\n\nsector_mapping = {\n    'Technology': ['AAPL', 'MSFT', 'INTC', 'CSCO', 'ORCL'],\n    'Financial': ['JPM', 'BAC', 'GS', 'MS', 'C', 'AXP', 'WFC'],\n    'Healthcare': ['JNJ', 'PFE', 'MRK', 'ABT', 'BMY'],\n    'Energy': ['XOM', 'CVX', 'COP', 'SLB', 'OXY'],\n    'Consumer_Staples': ['WMT', 'PG', 'KO', 'PEP', 'CL', 'KMB', 'GIS'],\n    'Consumer_Discretionary': ['HD', 'MCD', 'NKE', 'SBUX', 'TJX', 'LOW', 'YUM'],\n    'Industrial': ['CAT', 'BA', 'MMM', 'HON', 'GE', 'DE', 'FDX'],\n    'Materials': ['APD', 'ECL', 'NEM', 'FCX', 'PPG', 'NUE'],\n    'Telecommunications': ['VZ', 'T', 'CMCSA'],\n    'Real_Estate': ['SPG', 'PSA']\n}\n\n\n# Download the data\nstart_date = '2010-01-01'\nend_date = '2025-01-01'\n\n[*********************100%***********************]  54 of 54 completed\n\n\nFirst few rows of the price data:\nTicker          AAPL        ABT        APD        AXP         BA        BAC  \\\nDate                                                                          \n2010-01-04  6.447412  18.665758  52.804508  32.828983  43.777561  12.451034   \n2010-01-05  6.458560  18.514959  52.366360  32.756783  45.211349  12.855753   \n2010-01-06  6.355827  18.617779  51.934586  33.286285  46.582794  13.006530   \n2010-01-07  6.344077  18.772020  51.636158  33.826145  48.468563  13.435059   \n2010-01-08  6.386254  18.867979  51.966351  33.801979  48.001026  13.316021   \n\nTicker            BMY          C        CAT         CL  ...      SBUX  \\\nDate                                                    ...             \n2010-01-04  15.436789  25.928009  39.738235  28.930437  ...  8.835545   \n2010-01-05  15.195873  26.919380  40.213326  29.164408  ...  9.042539   \n2010-01-06  15.189850  27.758226  40.335484  29.098055  ...  8.977375   \n2010-01-07  15.201899  27.834469  40.498383  28.982828  ...  8.954374   \n2010-01-08  14.948930  27.376934  40.953117  28.462532  ...  8.923708   \n\nTicker            SLB        SPG         T       TJX         VZ        WFC  \\\nDate                                                                         \n2010-01-04  47.246723  39.174126  7.038978  7.384900  14.442019  18.417709   \n2010-01-05  47.380508  38.906082  7.004502  7.583662  14.468057  18.923317   \n2010-01-06  48.436508  38.469257  6.935692  7.614400  14.052043  18.950285   \n2010-01-07  48.936378  38.970608  6.857815  8.003725  13.968397  19.637922   \n2010-01-08  49.738956  38.037426  6.807579  7.899220  13.977206  19.455894   \n\nTicker            WMT        XOM        YUM  \nDate                                         \n2010-01-04  13.084426  39.272114  18.878279  \n2010-01-05  12.954136  39.425453  18.813725  \n2010-01-06  12.925184  39.766212  18.679226  \n2010-01-07  12.932426  39.641270  18.673841  \n2010-01-08  12.867274  39.482235  18.679226  \n\n[5 rows x 54 columns]\n\n\n\n\n\nCalculate the daily returns for each asset. The daily return is defined as the percentage change in price from one day to the next.\nHint: - Use the pct_change() method from pandas - Be sure to handle any missing values that might appear\n\n\n\n\nSummary statistics of daily returns:\nTicker         AAPL          ABT          APD          AXP           BA  \\\ncount   3773.000000  3773.000000  3773.000000  3773.000000  3773.000000   \nmean       0.001124     0.000568     0.000567     0.000748     0.000625   \nstd        0.017552     0.013505     0.015242     0.018248     0.022538   \nmin       -0.128647    -0.097857    -0.155518    -0.148187    -0.238484   \n25%       -0.007398    -0.006053    -0.006462    -0.007042    -0.009198   \n50%        0.001001     0.000596     0.000751     0.000768     0.000676   \n75%        0.010355     0.007639     0.008000     0.009271     0.010452   \nmax        0.119808     0.109360     0.137233     0.218822     0.243186   \n\nTicker          BAC          BMY            C          CAT           CL  ...  \\\ncount   3773.000000  3773.000000  3773.000000  3773.000000  3773.000000  ...   \nmean       0.000559     0.000449     0.000494     0.000753     0.000365  ...   \nstd        0.021172     0.014655     0.021367     0.018295     0.011262  ...   \nmin       -0.203182    -0.159851    -0.192986    -0.142822    -0.097829  ...   \n25%       -0.009895    -0.006971    -0.009486    -0.008498    -0.005121  ...   \n50%        0.000349     0.000622     0.000294     0.000584     0.000369  ...   \n75%        0.010749     0.007588     0.010222     0.010267     0.006184  ...   \nmax        0.177962     0.114425     0.179843     0.103321     0.126082  ...   \n\nTicker         SBUX          SLB          SPG            T          TJX  \\\ncount   3773.000000  3773.000000  3773.000000  3773.000000  3773.000000   \nmean       0.000768     0.000208     0.000605     0.000392     0.000864   \nstd        0.017326     0.022881     0.020546     0.012944     0.015659   \nmin       -0.162042    -0.274214    -0.267127    -0.104061    -0.203995   \n25%       -0.007363    -0.010883    -0.007593    -0.005913    -0.006955   \n50%        0.000654    -0.000108     0.000992     0.000725     0.000714   \n75%        0.008734     0.010998     0.009068     0.006838     0.008502   \nmax        0.244970     0.199080     0.278694     0.100223     0.129033   \n\nTicker           VZ          WFC          WMT          XOM          YUM  \ncount   3773.000000  3773.000000  3773.000000  3773.000000  3773.000000  \nmean       0.000333     0.000532     0.000585     0.000391     0.000631  \nstd        0.011605     0.018845     0.012085     0.015723     0.014886  \nmin       -0.074978    -0.158676    -0.113757    -0.122248    -0.188324  \n25%       -0.005823    -0.008342    -0.005145    -0.007267    -0.006211  \n50%        0.000496     0.000341     0.000679     0.000133     0.000812  \n75%        0.006458     0.009181     0.006373     0.007995     0.007590  \nmax        0.092705     0.145346     0.117085     0.126868     0.232485  \n\n[8 rows x 54 columns]\n\n\n\n\n\nCreate a visualization of the correlation between the assets using a heatmap. Also, compute and display the covariance matrix.\nHint: - Use seaborn.heatmap() for visualization - Use returns.corr() for correlation matrix - Use returns.cov() for covariance matrix\n\n\n\n\n\n\n\n\n\n\n\nCovariance Matrix:\nTicker      AAPL       ABT       APD       AXP        BA       BAC       BMY  \\\nTicker                                                                         \nAAPL    0.000308  0.000095  0.000105  0.000131  0.000152  0.000141  0.000065   \nABT     0.000095  0.000182  0.000097  0.000101  0.000103  0.000111  0.000079   \nAPD     0.000105  0.000097  0.000232  0.000135  0.000143  0.000158  0.000073   \nAXP     0.000131  0.000101  0.000135  0.000333  0.000237  0.000260  0.000081   \nBA      0.000152  0.000103  0.000143  0.000237  0.000508  0.000236  0.000082   \nBAC     0.000141  0.000111  0.000158  0.000260  0.000236  0.000448  0.000091   \nBMY     0.000065  0.000079  0.000073  0.000081  0.000082  0.000091  0.000215   \nC       0.000147  0.000114  0.000162  0.000265  0.000263  0.000383  0.000097   \nCAT     0.000128  0.000087  0.000147  0.000187  0.000200  0.000226  0.000074   \nCL      0.000059  0.000069  0.000075  0.000064  0.000070  0.000067  0.000055   \nCMCSA   0.000103  0.000081  0.000100  0.000136  0.000133  0.000153  0.000070   \nCOP     0.000111  0.000078  0.000134  0.000193  0.000209  0.000226  0.000081   \nCSCO    0.000132  0.000096  0.000110  0.000136  0.000139  0.000163  0.000073   \nCVX     0.000100  0.000080  0.000121  0.000171  0.000187  0.000194  0.000077   \nDE      0.000120  0.000085  0.000131  0.000168  0.000198  0.000198  0.000072   \nECL     0.000110  0.000097  0.000131  0.000150  0.000153  0.000159  0.000071   \nFCX     0.000186  0.000127  0.000210  0.000263  0.000292  0.000306  0.000103   \nFDX     0.000127  0.000096  0.000130  0.000163  0.000193  0.000199  0.000071   \nGE      0.000118  0.000087  0.000128  0.000196  0.000234  0.000221  0.000074   \nGIS     0.000043  0.000053  0.000058  0.000041  0.000035  0.000051  0.000046   \nGS      0.000131  0.000099  0.000136  0.000217  0.000207  0.000297  0.000081   \nHD      0.000118  0.000091  0.000107  0.000134  0.000144  0.000147  0.000070   \nHON     0.000116  0.000094  0.000130  0.000170  0.000195  0.000188  0.000078   \nINTC    0.000161  0.000108  0.000125  0.000155  0.000181  0.000171  0.000069   \nJNJ     0.000061  0.000078  0.000072  0.000075  0.000076  0.000084  0.000071   \nJPM     0.000119  0.000100  0.000139  0.000225  0.000209  0.000316  0.000083   \nKMB     0.000050  0.000062  0.000066  0.000056  0.000055  0.000058  0.000053   \nKO      0.000064  0.000065  0.000077  0.000090  0.000098  0.000088  0.000053   \nLOW     0.000122  0.000096  0.000113  0.000146  0.000159  0.000165  0.000072   \nMCD     0.000078  0.000066  0.000077  0.000098  0.000110  0.000096  0.000052   \nMMM     0.000099  0.000085  0.000112  0.000135  0.000138  0.000157  0.000071   \nMRK     0.000064  0.000084  0.000078  0.000081  0.000077  0.000096  0.000076   \nMS      0.000151  0.000124  0.000168  0.000256  0.000237  0.000365  0.000100   \nMSFT    0.000166  0.000105  0.000112  0.000136  0.000139  0.000144  0.000066   \nNEM     0.000056  0.000040  0.000070  0.000048  0.000056  0.000044  0.000036   \nNKE     0.000127  0.000093  0.000109  0.000145  0.000164  0.000148  0.000066   \nNUE     0.000125  0.000090  0.000155  0.000192  0.000200  0.000240  0.000079   \nORCL    0.000128  0.000090  0.000115  0.000135  0.000132  0.000158  0.000066   \nOXY     0.000125  0.000083  0.000147  0.000224  0.000272  0.000269  0.000080   \nPEP     0.000071  0.000069  0.000075  0.000075  0.000079  0.000078  0.000055   \nPFE     0.000072  0.000084  0.000082  0.000090  0.000092  0.000106  0.000090   \nPG      0.000063  0.000068  0.000069  0.000066  0.000066  0.000071  0.000053   \nPPG     0.000113  0.000095  0.000143  0.000167  0.000177  0.000187  0.000076   \nPSA     0.000080  0.000070  0.000084  0.000093  0.000100  0.000104  0.000056   \nSBUX    0.000128  0.000091  0.000119  0.000156  0.000169  0.000161  0.000069   \nSLB     0.000120  0.000073  0.000145  0.000219  0.000237  0.000255  0.000077   \nSPG     0.000112  0.000070  0.000114  0.000218  0.000260  0.000215  0.000071   \nT       0.000064  0.000065  0.000076  0.000099  0.000101  0.000116  0.000055   \nTJX     0.000102  0.000081  0.000099  0.000147  0.000168  0.000153  0.000060   \nVZ      0.000049  0.000057  0.000064  0.000069  0.000066  0.000083  0.000047   \nWFC     0.000119  0.000097  0.000138  0.000237  0.000227  0.000315  0.000085   \nWMT     0.000061  0.000056  0.000058  0.000056  0.000056  0.000065  0.000043   \nXOM     0.000085  0.000065  0.000106  0.000149  0.000169  0.000174  0.000066   \nYUM     0.000098  0.000079  0.000100  0.000131  0.000144  0.000134  0.000061   \n\nTicker         C       CAT        CL  ...      SBUX       SLB       SPG  \\\nTicker                                ...                                 \nAAPL    0.000147  0.000128  0.000059  ...  0.000128  0.000120  0.000112   \nABT     0.000114  0.000087  0.000069  ...  0.000091  0.000073  0.000070   \nAPD     0.000162  0.000147  0.000075  ...  0.000119  0.000145  0.000114   \nAXP     0.000265  0.000187  0.000064  ...  0.000156  0.000219  0.000218   \nBA      0.000263  0.000200  0.000070  ...  0.000169  0.000237  0.000260   \nBAC     0.000383  0.000226  0.000067  ...  0.000161  0.000255  0.000215   \nBMY     0.000097  0.000074  0.000055  ...  0.000069  0.000077  0.000071   \nC       0.000457  0.000233  0.000072  ...  0.000169  0.000279  0.000238   \nCAT     0.000233  0.000335  0.000058  ...  0.000122  0.000248  0.000160   \nCL      0.000072  0.000058  0.000127  ...  0.000071  0.000055  0.000064   \nCMCSA   0.000160  0.000127  0.000066  ...  0.000113  0.000131  0.000129   \nCOP     0.000243  0.000216  0.000055  ...  0.000123  0.000366  0.000190   \nCSCO    0.000166  0.000139  0.000068  ...  0.000120  0.000141  0.000115   \nCVX     0.000210  0.000181  0.000058  ...  0.000111  0.000286  0.000170   \nDE      0.000204  0.000229  0.000061  ...  0.000119  0.000205  0.000155   \nECL     0.000164  0.000131  0.000072  ...  0.000127  0.000139  0.000141   \nFCX     0.000327  0.000345  0.000069  ...  0.000171  0.000379  0.000240   \nFDX     0.000213  0.000179  0.000065  ...  0.000134  0.000177  0.000157   \nGE      0.000237  0.000190  0.000061  ...  0.000131  0.000222  0.000192   \nGIS     0.000048  0.000038  0.000068  ...  0.000045  0.000036  0.000032   \nGS      0.000303  0.000194  0.000061  ...  0.000139  0.000217  0.000186   \nHD      0.000153  0.000120  0.000070  ...  0.000127  0.000111  0.000139   \nHON     0.000197  0.000172  0.000066  ...  0.000127  0.000175  0.000161   \nINTC    0.000185  0.000155  0.000062  ...  0.000123  0.000153  0.000134   \nJNJ     0.000086  0.000070  0.000060  ...  0.000063  0.000068  0.000060   \nJPM     0.000315  0.000192  0.000065  ...  0.000139  0.000221  0.000188   \nKMB     0.000059  0.000049  0.000086  ...  0.000057  0.000039  0.000054   \nKO      0.000094  0.000074  0.000071  ...  0.000075  0.000082  0.000095   \nLOW     0.000173  0.000135  0.000071  ...  0.000137  0.000133  0.000157   \nMCD     0.000107  0.000077  0.000059  ...  0.000106  0.000088  0.000104   \nMMM     0.000162  0.000154  0.000065  ...  0.000101  0.000142  0.000125   \nMRK     0.000098  0.000078  0.000059  ...  0.000068  0.000083  0.000068   \nMS      0.000367  0.000232  0.000074  ...  0.000167  0.000260  0.000204   \nMSFT    0.000152  0.000123  0.000067  ...  0.000129  0.000107  0.000105   \nNEM     0.000050  0.000078  0.000038  ...  0.000045  0.000099  0.000056   \nNKE     0.000160  0.000129  0.000065  ...  0.000153  0.000125  0.000138   \nNUE     0.000252  0.000230  0.000061  ...  0.000131  0.000243  0.000180   \nORCL    0.000163  0.000136  0.000068  ...  0.000117  0.000129  0.000104   \nOXY     0.000293  0.000244  0.000058  ...  0.000142  0.000429  0.000262   \nPEP     0.000081  0.000062  0.000079  ...  0.000077  0.000062  0.000075   \nPFE     0.000109  0.000086  0.000056  ...  0.000073  0.000084  0.000079   \nPG      0.000073  0.000056  0.000085  ...  0.000066  0.000050  0.000056   \nPPG     0.000199  0.000167  0.000068  ...  0.000129  0.000165  0.000160   \nPSA     0.000107  0.000084  0.000068  ...  0.000090  0.000076  0.000139   \nSBUX    0.000169  0.000122  0.000071  ...  0.000300  0.000134  0.000157   \nSLB     0.000279  0.000248  0.000055  ...  0.000134  0.000524  0.000229   \nSPG     0.000238  0.000160  0.000064  ...  0.000157  0.000229  0.000422   \nT       0.000122  0.000090  0.000059  ...  0.000072  0.000102  0.000099   \nTJX     0.000158  0.000120  0.000062  ...  0.000125  0.000128  0.000165   \nVZ      0.000083  0.000067  0.000056  ...  0.000059  0.000066  0.000071   \nWFC     0.000311  0.000191  0.000067  ...  0.000144  0.000229  0.000205   \nWMT     0.000063  0.000054  0.000057  ...  0.000060  0.000044  0.000051   \nXOM     0.000188  0.000166  0.000052  ...  0.000093  0.000268  0.000155   \nYUM     0.000144  0.000114  0.000058  ...  0.000141  0.000113  0.000129   \n\nTicker         T       TJX        VZ       WFC       WMT       XOM       YUM  \nTicker                                                                        \nAAPL    0.000064  0.000102  0.000049  0.000119  0.000061  0.000085  0.000098  \nABT     0.000065  0.000081  0.000057  0.000097  0.000056  0.000065  0.000079  \nAPD     0.000076  0.000099  0.000064  0.000138  0.000058  0.000106  0.000100  \nAXP     0.000099  0.000147  0.000069  0.000237  0.000056  0.000149  0.000131  \nBA      0.000101  0.000168  0.000066  0.000227  0.000056  0.000169  0.000144  \nBAC     0.000116  0.000153  0.000083  0.000315  0.000065  0.000174  0.000134  \nBMY     0.000055  0.000060  0.000047  0.000085  0.000043  0.000066  0.000061  \nC       0.000122  0.000158  0.000083  0.000311  0.000063  0.000188  0.000144  \nCAT     0.000090  0.000120  0.000067  0.000191  0.000054  0.000166  0.000114  \nCL      0.000059  0.000062  0.000056  0.000067  0.000057  0.000052  0.000058  \nCMCSA   0.000093  0.000100  0.000073  0.000139  0.000057  0.000098  0.000087  \nCOP     0.000092  0.000115  0.000065  0.000201  0.000046  0.000263  0.000111  \nCSCO    0.000079  0.000102  0.000061  0.000140  0.000067  0.000103  0.000095  \nCVX     0.000089  0.000108  0.000067  0.000174  0.000047  0.000221  0.000102  \nDE      0.000085  0.000118  0.000063  0.000173  0.000055  0.000138  0.000107  \nECL     0.000078  0.000115  0.000060  0.000142  0.000055  0.000102  0.000111  \nFCX     0.000119  0.000164  0.000083  0.000259  0.000068  0.000250  0.000165  \nFDX     0.000082  0.000122  0.000063  0.000173  0.000064  0.000120  0.000106  \nGE      0.000099  0.000133  0.000070  0.000203  0.000050  0.000153  0.000111  \nGIS     0.000052  0.000037  0.000050  0.000050  0.000051  0.000039  0.000040  \nGS      0.000097  0.000130  0.000067  0.000247  0.000056  0.000146  0.000117  \nHD      0.000072  0.000125  0.000060  0.000132  0.000070  0.000086  0.000104  \nHON     0.000085  0.000121  0.000063  0.000169  0.000055  0.000122  0.000113  \nINTC    0.000080  0.000112  0.000063  0.000153  0.000065  0.000111  0.000099  \nJNJ     0.000058  0.000058  0.000053  0.000078  0.000048  0.000062  0.000058  \nJPM     0.000102  0.000135  0.000074  0.000265  0.000058  0.000152  0.000119  \nKMB     0.000058  0.000048  0.000057  0.000055  0.000053  0.000043  0.000054  \nKO      0.000065  0.000070  0.000057  0.000087  0.000049  0.000071  0.000069  \nLOW     0.000075  0.000138  0.000060  0.000146  0.000068  0.000098  0.000112  \nMCD     0.000055  0.000083  0.000045  0.000092  0.000045  0.000068  0.000103  \nMMM     0.000076  0.000095  0.000060  0.000143  0.000052  0.000102  0.000090  \nMRK     0.000061  0.000062  0.000057  0.000084  0.000048  0.000070  0.000064  \nMS      0.000114  0.000152  0.000081  0.000293  0.000070  0.000174  0.000137  \nMSFT    0.000061  0.000101  0.000054  0.000124  0.000066  0.000083  0.000104  \nNEM     0.000047  0.000023  0.000040  0.000035  0.000029  0.000072  0.000049  \nNKE     0.000070  0.000130  0.000055  0.000136  0.000059  0.000094  0.000115  \nNUE     0.000096  0.000133  0.000077  0.000209  0.000065  0.000167  0.000115  \nORCL    0.000073  0.000099  0.000057  0.000135  0.000064  0.000090  0.000089  \nOXY     0.000111  0.000131  0.000070  0.000243  0.000044  0.000303  0.000118  \nPEP     0.000061  0.000066  0.000056  0.000076  0.000060  0.000061  0.000064  \nPFE     0.000065  0.000065  0.000058  0.000096  0.000049  0.000072  0.000063  \nPG      0.000059  0.000053  0.000056  0.000068  0.000058  0.000051  0.000054  \nPPG     0.000078  0.000122  0.000062  0.000168  0.000049  0.000113  0.000117  \nPSA     0.000061  0.000080  0.000057  0.000092  0.000051  0.000064  0.000080  \nSBUX    0.000072  0.000125  0.000059  0.000144  0.000060  0.000093  0.000141  \nSLB     0.000102  0.000128  0.000066  0.000229  0.000044  0.000268  0.000113  \nSPG     0.000099  0.000165  0.000071  0.000205  0.000051  0.000155  0.000129  \nT       0.000168  0.000074  0.000101  0.000110  0.000048  0.000085  0.000063  \nTJX     0.000074  0.000245  0.000056  0.000143  0.000061  0.000097  0.000109  \nVZ      0.000101  0.000056  0.000135  0.000078  0.000046  0.000063  0.000048  \nWFC     0.000110  0.000143  0.000078  0.000355  0.000060  0.000162  0.000118  \nWMT     0.000048  0.000061  0.000046  0.000060  0.000146  0.000044  0.000045  \nXOM     0.000085  0.000097  0.000063  0.000162  0.000044  0.000247  0.000087  \nYUM     0.000063  0.000109  0.000048  0.000118  0.000045  0.000087  0.000222  \n\n[54 rows x 54 columns]\n\n\n\n\n\nCreate a plot showing the evolution of prices for all assets on the same graph. Make sure to normalize the prices to start at 100 to make them comparable.\nHint: - Normalize prices by dividing by the initial price and multiplying by 100 - Use matplotlib’s plot function - Add a legend to distinguish between assets\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreate an equally-weighted portfolio from our five assets. Calculate its daily returns and analyze its performance metrics (mean return, volatility, Sharpe ratio assuming risk-free rate = 0).\nHint: - Equal weights means 1/N for each asset - Portfolio return is the weighted sum of individual returns - Portfolio volatility requires using the covariance matrix\n\n\n\nEqual-weighted Portfolio Metrics (daily):\nMean Return: 0.0556%\nVolatility: 1.0755%\nSharpe Ratio: 0.0517\n\n\n\n\n\nWrite a function that computes the mean return and volatility of a portfolio given: - A set of weights - The mean returns of individual assets - The covariance matrix of returns\nHint: - Portfolio return = weighted sum of individual returns - Portfolio variance = w^T * Σ * w (where Σ is the covariance matrix)\n\n\n\n\nTest with equal weights:\nPortfolio Return: 0.0556%\nPortfolio Volatility: 1.0755%\n\n\n\n\n\nSplit your data into two periods: training (2020-2021) and testing (2022-2023). Calculate the mean returns and covariance matrix for the training period.\nHint: - Use datetime index to split the data - Recalculate all metrics on the training set\n\n\n\nTraining Period Statistics:\n\nMean Returns:\nTicker\nAAPL     0.001087\nABT      0.000644\nAPD      0.000630\nAXP      0.000605\nBA       0.000918\nBAC      0.000574\nBMY      0.000599\nC        0.000563\nCAT      0.000624\nCL       0.000349\nCMCSA    0.000832\nCOP      0.000472\nCSCO     0.000489\nCVX      0.000404\nDE       0.000664\nECL      0.000692\nFCX      0.000109\nFDX      0.000395\nGE       0.000142\nGIS      0.000354\nGS       0.000303\nHD       0.000980\nHON      0.000778\nINTC     0.000661\nJNJ      0.000488\nJPM      0.000689\nKMB      0.000510\nKO       0.000430\nLOW      0.000846\nMCD      0.000623\nMMM      0.000477\nMRK      0.000569\nMS       0.000478\nMSFT     0.000845\nNEM      0.000262\nNKE      0.000887\nNUE      0.000329\nORCL     0.000459\nOXY      0.000020\nPEP      0.000477\nPFE      0.000502\nPG       0.000453\nPPG      0.000765\nPSA      0.000599\nSBUX     0.000982\nSLB      0.000046\nSPG      0.000505\nT        0.000470\nTJX      0.000900\nVZ       0.000514\nWFC      0.000488\nWMT      0.000470\nXOM      0.000200\nYUM      0.000729\ndtype: float64\n\nCovariance Matrix:\nTicker      AAPL       ABT       APD       AXP        BA       BAC       BMY  \\\nTicker                                                                         \nAAPL    0.000263  0.000065  0.000078  0.000089  0.000099  0.000119  0.000058   \nABT     0.000065  0.000138  0.000072  0.000077  0.000080  0.000091  0.000072   \nAPD     0.000078  0.000072  0.000167  0.000095  0.000103  0.000129  0.000062   \nAXP     0.000089  0.000077  0.000095  0.000205  0.000112  0.000177  0.000066   \nBA      0.000099  0.000080  0.000103  0.000112  0.000244  0.000152  0.000069   \nBAC     0.000119  0.000091  0.000129  0.000177  0.000152  0.000419  0.000081   \nBMY     0.000058  0.000072  0.000062  0.000066  0.000069  0.000081  0.000211   \nC       0.000118  0.000099  0.000135  0.000171  0.000153  0.000332  0.000088   \nCAT     0.000120  0.000078  0.000127  0.000130  0.000144  0.000189  0.000068   \nCL      0.000042  0.000047  0.000056  0.000053  0.000058  0.000051  0.000045   \nCMCSA   0.000075  0.000061  0.000080  0.000092  0.000087  0.000123  0.000059   \nCOP     0.000088  0.000068  0.000097  0.000100  0.000104  0.000153  0.000061   \nCSCO    0.000105  0.000075  0.000091  0.000098  0.000103  0.000142  0.000062   \nCVX     0.000076  0.000066  0.000089  0.000089  0.000094  0.000131  0.000059   \nDE      0.000101  0.000070  0.000105  0.000107  0.000123  0.000159  0.000061   \nECL     0.000067  0.000065  0.000089  0.000079  0.000085  0.000111  0.000058   \nFCX     0.000149  0.000111  0.000167  0.000176  0.000178  0.000255  0.000091   \nFDX     0.000094  0.000078  0.000106  0.000114  0.000125  0.000171  0.000067   \nGE      0.000086  0.000069  0.000095  0.000109  0.000107  0.000161  0.000063   \nGIS     0.000034  0.000038  0.000044  0.000040  0.000041  0.000047  0.000034   \nGS      0.000100  0.000080  0.000110  0.000138  0.000122  0.000251  0.000071   \nHD      0.000076  0.000063  0.000076  0.000090  0.000088  0.000115  0.000059   \nHON     0.000093  0.000076  0.000106  0.000110  0.000124  0.000152  0.000068   \nINTC    0.000107  0.000077  0.000086  0.000097  0.000102  0.000129  0.000063   \nJNJ     0.000045  0.000057  0.000055  0.000059  0.000062  0.000069  0.000059   \nJPM     0.000095  0.000081  0.000111  0.000144  0.000125  0.000268  0.000075   \nKMB     0.000032  0.000044  0.000050  0.000042  0.000047  0.000046  0.000045   \nKO      0.000039  0.000043  0.000051  0.000051  0.000052  0.000057  0.000039   \nLOW     0.000077  0.000066  0.000082  0.000096  0.000094  0.000133  0.000061   \nMCD     0.000047  0.000043  0.000050  0.000050  0.000052  0.000060  0.000038   \nMMM     0.000082  0.000069  0.000089  0.000094  0.000101  0.000127  0.000060   \nMRK     0.000052  0.000074  0.000066  0.000072  0.000067  0.000090  0.000062   \nMS      0.000119  0.000105  0.000142  0.000178  0.000156  0.000338  0.000090   \nMSFT    0.000106  0.000076  0.000086  0.000097  0.000096  0.000125  0.000060   \nNEM     0.000043  0.000022  0.000046  0.000035  0.000035  0.000029  0.000029   \nNKE     0.000082  0.000066  0.000082  0.000093  0.000094  0.000114  0.000057   \nNUE     0.000097  0.000077  0.000119  0.000118  0.000124  0.000188  0.000070   \nORCL    0.000095  0.000073  0.000094  0.000100  0.000101  0.000140  0.000064   \nOXY     0.000088  0.000069  0.000103  0.000097  0.000108  0.000159  0.000062   \nPEP     0.000038  0.000041  0.000046  0.000046  0.000048  0.000049  0.000040   \nPFE     0.000059  0.000069  0.000065  0.000074  0.000068  0.000096  0.000077   \nPG      0.000039  0.000041  0.000044  0.000047  0.000047  0.000050  0.000041   \nPPG     0.000085  0.000078  0.000115  0.000106  0.000110  0.000149  0.000067   \nPSA     0.000051  0.000045  0.000062  0.000068  0.000069  0.000089  0.000044   \nSBUX    0.000087  0.000063  0.000087  0.000093  0.000090  0.000116  0.000058   \nSLB     0.000102  0.000068  0.000111  0.000109  0.000116  0.000177  0.000061   \nSPG     0.000066  0.000053  0.000070  0.000084  0.000081  0.000114  0.000050   \nT       0.000046  0.000044  0.000051  0.000057  0.000056  0.000075  0.000041   \nTJX     0.000067  0.000060  0.000064  0.000075  0.000078  0.000099  0.000049   \nVZ      0.000037  0.000044  0.000048  0.000052  0.000049  0.000063  0.000038   \nWFC     0.000090  0.000077  0.000103  0.000137  0.000122  0.000234  0.000069   \nWMT     0.000040  0.000044  0.000041  0.000047  0.000049  0.000057  0.000039   \nXOM     0.000067  0.000059  0.000080  0.000078  0.000086  0.000116  0.000053   \nYUM     0.000075  0.000060  0.000079  0.000084  0.000086  0.000109  0.000055   \n\nTicker         C       CAT        CL  ...      SBUX       SLB       SPG  \\\nTicker                                ...                                 \nAAPL    0.000118  0.000120  0.000042  ...  0.000087  0.000102  0.000066   \nABT     0.000099  0.000078  0.000047  ...  0.000063  0.000068  0.000053   \nAPD     0.000135  0.000127  0.000056  ...  0.000087  0.000111  0.000070   \nAXP     0.000171  0.000130  0.000053  ...  0.000093  0.000109  0.000084   \nBA      0.000153  0.000144  0.000058  ...  0.000090  0.000116  0.000081   \nBAC     0.000332  0.000189  0.000051  ...  0.000116  0.000177  0.000114   \nBMY     0.000088  0.000068  0.000045  ...  0.000058  0.000061  0.000050   \nC       0.000381  0.000192  0.000059  ...  0.000117  0.000181  0.000114   \nCAT     0.000192  0.000293  0.000052  ...  0.000095  0.000179  0.000092   \nCL      0.000059  0.000052  0.000105  ...  0.000058  0.000050  0.000053   \nCMCSA   0.000125  0.000109  0.000052  ...  0.000080  0.000096  0.000077   \nCOP     0.000153  0.000162  0.000047  ...  0.000072  0.000199  0.000073   \nCSCO    0.000141  0.000126  0.000054  ...  0.000089  0.000112  0.000076   \nCVX     0.000135  0.000135  0.000049  ...  0.000069  0.000158  0.000074   \nDE      0.000159  0.000190  0.000050  ...  0.000083  0.000140  0.000081   \nECL     0.000112  0.000103  0.000052  ...  0.000077  0.000096  0.000061   \nFCX     0.000260  0.000310  0.000063  ...  0.000110  0.000279  0.000120   \nFDX     0.000173  0.000158  0.000053  ...  0.000095  0.000135  0.000088   \nGE      0.000165  0.000138  0.000050  ...  0.000083  0.000135  0.000082   \nGIS     0.000047  0.000040  0.000051  ...  0.000042  0.000042  0.000046   \nGS      0.000243  0.000154  0.000047  ...  0.000089  0.000142  0.000086   \nHD      0.000116  0.000097  0.000050  ...  0.000087  0.000082  0.000075   \nHON     0.000154  0.000149  0.000058  ...  0.000094  0.000126  0.000084   \nINTC    0.000134  0.000128  0.000046  ...  0.000077  0.000106  0.000072   \nJNJ     0.000074  0.000061  0.000045  ...  0.000051  0.000059  0.000047   \nJPM     0.000257  0.000155  0.000052  ...  0.000094  0.000148  0.000093   \nKMB     0.000049  0.000046  0.000069  ...  0.000047  0.000038  0.000050   \nKO      0.000061  0.000054  0.000052  ...  0.000049  0.000051  0.000050   \nLOW     0.000131  0.000111  0.000051  ...  0.000093  0.000098  0.000081   \nMCD     0.000064  0.000055  0.000042  ...  0.000068  0.000048  0.000046   \nMMM     0.000128  0.000130  0.000052  ...  0.000073  0.000113  0.000073   \nMRK     0.000092  0.000074  0.000046  ...  0.000060  0.000067  0.000058   \nMS      0.000328  0.000198  0.000063  ...  0.000120  0.000192  0.000114   \nMSFT    0.000129  0.000116  0.000050  ...  0.000091  0.000091  0.000066   \nNEM     0.000037  0.000075  0.000027  ...  0.000025  0.000086  0.000044   \nNKE     0.000120  0.000103  0.000051  ...  0.000099  0.000092  0.000075   \nNUE     0.000188  0.000179  0.000052  ...  0.000093  0.000163  0.000091   \nORCL    0.000146  0.000125  0.000053  ...  0.000090  0.000117  0.000076   \nOXY     0.000164  0.000161  0.000049  ...  0.000082  0.000202  0.000087   \nPEP     0.000055  0.000046  0.000053  ...  0.000046  0.000044  0.000046   \nPFE     0.000099  0.000079  0.000041  ...  0.000061  0.000075  0.000061   \nPG      0.000056  0.000047  0.000063  ...  0.000047  0.000044  0.000046   \nPPG     0.000153  0.000143  0.000059  ...  0.000088  0.000121  0.000084   \nPSA     0.000090  0.000073  0.000050  ...  0.000068  0.000068  0.000111   \nSBUX    0.000117  0.000095  0.000058  ...  0.000221  0.000088  0.000079   \nSLB     0.000181  0.000179  0.000050  ...  0.000088  0.000309  0.000091   \nSPG     0.000114  0.000092  0.000053  ...  0.000079  0.000091  0.000174   \nT       0.000080  0.000069  0.000043  ...  0.000047  0.000066  0.000052   \nTJX     0.000101  0.000082  0.000046  ...  0.000079  0.000071  0.000070   \nVZ      0.000067  0.000056  0.000044  ...  0.000047  0.000053  0.000055   \nWFC     0.000221  0.000139  0.000051  ...  0.000097  0.000136  0.000094   \nWMT     0.000060  0.000049  0.000042  ...  0.000049  0.000041  0.000048   \nXOM     0.000121  0.000118  0.000047  ...  0.000061  0.000137  0.000066   \nYUM     0.000114  0.000098  0.000050  ...  0.000102  0.000078  0.000069   \n\nTicker         T       TJX        VZ       WFC       WMT       XOM       YUM  \nTicker                                                                        \nAAPL    0.000046  0.000067  0.000037  0.000090  0.000040  0.000067  0.000075  \nABT     0.000044  0.000060  0.000044  0.000077  0.000044  0.000059  0.000060  \nAPD     0.000051  0.000064  0.000048  0.000103  0.000041  0.000080  0.000079  \nAXP     0.000057  0.000075  0.000052  0.000137  0.000047  0.000078  0.000084  \nBA      0.000056  0.000078  0.000049  0.000122  0.000049  0.000086  0.000086  \nBAC     0.000075  0.000099  0.000063  0.000234  0.000057  0.000116  0.000109  \nBMY     0.000041  0.000049  0.000038  0.000069  0.000039  0.000053  0.000055  \nC       0.000080  0.000101  0.000067  0.000221  0.000060  0.000121  0.000114  \nCAT     0.000069  0.000082  0.000056  0.000139  0.000049  0.000118  0.000098  \nCL      0.000043  0.000046  0.000044  0.000051  0.000042  0.000047  0.000050  \nCMCSA   0.000064  0.000069  0.000058  0.000104  0.000048  0.000076  0.000072  \nCOP     0.000056  0.000063  0.000050  0.000117  0.000040  0.000139  0.000076  \nCSCO    0.000057  0.000074  0.000048  0.000110  0.000051  0.000082  0.000078  \nCVX     0.000058  0.000060  0.000054  0.000106  0.000041  0.000124  0.000066  \nDE      0.000061  0.000072  0.000052  0.000121  0.000043  0.000091  0.000082  \nECL     0.000046  0.000063  0.000044  0.000088  0.000039  0.000071  0.000072  \nFCX     0.000089  0.000105  0.000075  0.000187  0.000061  0.000176  0.000119  \nFDX     0.000062  0.000085  0.000052  0.000132  0.000053  0.000091  0.000091  \nGE      0.000066  0.000074  0.000058  0.000125  0.000044  0.000092  0.000074  \nGIS     0.000039  0.000038  0.000040  0.000044  0.000037  0.000038  0.000039  \nGS      0.000064  0.000078  0.000052  0.000172  0.000047  0.000097  0.000086  \nHD      0.000050  0.000086  0.000046  0.000094  0.000053  0.000064  0.000075  \nHON     0.000059  0.000078  0.000053  0.000122  0.000050  0.000087  0.000086  \nINTC    0.000054  0.000072  0.000048  0.000101  0.000045  0.000082  0.000077  \nJNJ     0.000041  0.000042  0.000043  0.000063  0.000037  0.000053  0.000048  \nJPM     0.000068  0.000083  0.000060  0.000189  0.000051  0.000103  0.000092  \nKMB     0.000043  0.000039  0.000048  0.000045  0.000041  0.000042  0.000046  \nKO      0.000040  0.000038  0.000043  0.000054  0.000037  0.000046  0.000046  \nLOW     0.000052  0.000092  0.000047  0.000106  0.000055  0.000073  0.000079  \nMCD     0.000033  0.000046  0.000035  0.000053  0.000035  0.000042  0.000067  \nMMM     0.000053  0.000063  0.000050  0.000102  0.000045  0.000080  0.000070  \nMRK     0.000049  0.000050  0.000050  0.000074  0.000042  0.000061  0.000058  \nMS      0.000082  0.000102  0.000069  0.000227  0.000062  0.000125  0.000108  \nMSFT    0.000051  0.000066  0.000049  0.000099  0.000048  0.000074  0.000086  \nNEM     0.000031  0.000011  0.000027  0.000022  0.000015  0.000057  0.000026  \nNKE     0.000048  0.000089  0.000044  0.000096  0.000049  0.000065  0.000083  \nNUE     0.000068  0.000080  0.000060  0.000139  0.000054  0.000111  0.000087  \nORCL    0.000056  0.000071  0.000048  0.000106  0.000046  0.000083  0.000079  \nOXY     0.000060  0.000068  0.000052  0.000123  0.000039  0.000132  0.000078  \nPEP     0.000037  0.000038  0.000042  0.000047  0.000038  0.000042  0.000042  \nPFE     0.000047  0.000051  0.000046  0.000081  0.000041  0.000063  0.000055  \nPG      0.000039  0.000036  0.000042  0.000047  0.000040  0.000044  0.000041  \nPPG     0.000057  0.000079  0.000055  0.000118  0.000046  0.000086  0.000086  \nPSA     0.000042  0.000056  0.000046  0.000076  0.000040  0.000050  0.000065  \nSBUX    0.000047  0.000079  0.000047  0.000097  0.000049  0.000061  0.000102  \nSLB     0.000066  0.000071  0.000053  0.000136  0.000041  0.000137  0.000078  \nSPG     0.000052  0.000070  0.000055  0.000094  0.000048  0.000066  0.000069  \nT       0.000111  0.000045  0.000073  0.000066  0.000039  0.000056  0.000044  \nTJX     0.000045  0.000172  0.000043  0.000082  0.000050  0.000056  0.000070  \nVZ      0.000073  0.000043  0.000111  0.000059  0.000040  0.000048  0.000043  \nWFC     0.000066  0.000082  0.000059  0.000229  0.000050  0.000097  0.000088  \nWMT     0.000039  0.000050  0.000040  0.000050  0.000118  0.000039  0.000041  \nXOM     0.000056  0.000056  0.000048  0.000097  0.000039  0.000136  0.000061  \nYUM     0.000044  0.000070  0.000043  0.000088  0.000041  0.000061  0.000198  \n\n[54 rows x 54 columns]\n\n\n\n\n\nCreate a function to generate random portfolio weights and use it to create the efficient frontier visualization. Generate 1000 random portfolios and plot them on a risk-return graph.\nHint: - Use np.random.random() to generate weights - Normalize weights to sum to 1 - Store results in arrays for plotting - Highlight the minimum variance and maximum Sharpe ratio portfolios\n\n\n\n\n\n\n\n\n\n\n\n\n\nUse scipy’s optimize function to find the minimum variance portfolio and the maximum Sharpe ratio portfolio. Make sure to include the constraint that weights must sum to 1 and be non-negative.\nHint: - Use scipy.optimize.minimize - Define objective functions for minimum variance and maximum Sharpe ratio - Use SLSQP optimizer - Check the optimization success flag\n\n\n\n\nMinimum Variance Portfolio:\nAAPL: 0.0134\nMSFT: 0.0049\nINTC: 0.0000\nCSCO: 0.0000\nORCL: 0.0000\nJPM: 0.0000\nBAC: 0.0103\nGS: 0.0000\nMS: 0.0000\nC: 0.0000\nAXP: 0.0000\nWFC: 0.0000\nJNJ: 0.0000\nPFE: 0.0000\nMRK: 0.0000\nABT: 0.0000\nBMY: 0.0000\nXOM: 0.0000\nCVX: 0.0000\nCOP: 0.0846\nSLB: 0.0000\nOXY: 0.0000\nWMT: 0.0000\nPG: 0.0000\nKO: 0.0952\nPEP: 0.0000\nCL: 0.0342\nKMB: 0.0841\nGIS: 0.0000\nHD: 0.1474\nMCD: 0.0000\nNKE: 0.0015\nSBUX: 0.0000\nTJX: 0.0000\nLOW: 0.0445\nYUM: 0.0000\nCAT: 0.0000\nBA: 0.0000\nMMM: 0.0000\nHON: 0.1014\nGE: 0.0133\nDE: 0.0877\nFDX: 0.0000\nAPD: 0.0061\nECL: 0.0000\nNEM: 0.0000\nFCX: 0.0000\nPPG: 0.0696\nNUE: 0.0297\nVZ: 0.0575\nT: 0.0000\nCMCSA: 0.1146\nSPG: 0.0000\nPSA: 0.0000\nExpected Return: 0.0499%\nVolatility: 0.6731%\n\nMaximum Sharpe Ratio Portfolio:\nAAPL: 0.1639\nMSFT: 0.0000\nINTC: 0.0000\nCSCO: 0.0000\nORCL: 0.0310\nJPM: 0.0000\nBAC: 0.0101\nGS: 0.0000\nMS: 0.0000\nC: 0.0000\nAXP: 0.0556\nWFC: 0.0000\nJNJ: 0.0000\nPFE: 0.0000\nMRK: 0.0000\nABT: 0.0000\nBMY: 0.0000\nXOM: 0.0000\nCVX: 0.0000\nCOP: 0.0000\nSLB: 0.0000\nOXY: 0.2121\nWMT: 0.0000\nPG: 0.0000\nKO: 0.0000\nPEP: 0.0000\nCL: 0.0647\nKMB: 0.0000\nGIS: 0.0000\nHD: 0.1537\nMCD: 0.0000\nNKE: 0.0000\nSBUX: 0.0000\nTJX: 0.0015\nLOW: 0.0009\nYUM: 0.0187\nCAT: 0.0000\nBA: 0.0000\nMMM: 0.0000\nHON: 0.0285\nGE: 0.0000\nDE: 0.0000\nFDX: 0.0000\nAPD: 0.0000\nECL: 0.0780\nNEM: 0.0000\nFCX: 0.0000\nPPG: 0.0000\nNUE: 0.1387\nVZ: 0.0425\nT: 0.0000\nCMCSA: 0.0000\nSPG: 0.0000\nPSA: 0.0000\nExpected Return: 0.0850%\nVolatility: 0.8703%\n\n\n\n\n\nBacktest your optimized portfolios (minimum variance and maximum Sharpe ratio) on the test period. Compare their performance with the equally-weighted portfolio.\nHint: - Use the weights found in the training period - Calculate cumulative returns for each portfolio - Plot the evolution of portfolio values - Calculate key performance metrics (return, volatility, Sharpe ratio, maximum drawdown)\n\n\n\n\n\n\n\n\n\n\n\nTrain Period Performance:\n\nEqual Weight:\nMean Return: 0.0553%\nVolatility: 0.9158%\nSharpe Ratio: 6.0422%\nCumulative Return: 261.7286%\n\nMin Variance:\nMean Return: 0.0499%\nVolatility: 0.6731%\nSharpe Ratio: 7.4197%\nCumulative Return: 231.6049%\n\nMax Sharpe:\nMean Return: 0.0850%\nVolatility: 0.8703%\nSharpe Ratio: 9.7722%\nCumulative Return: 671.2589%\n\nTest Period Performance:\n\nEqual Weight:\nMean Return: 0.0563%\nVolatility: 1.3392%\nSharpe Ratio: 4.2020%\nCumulative Return: 81.2116%\n\nMin Variance:\nMean Return: 0.0390%\nVolatility: 1.0081%\nSharpe Ratio: 3.8640%\nCumulative Return: 53.1191%\n\nMax Sharpe:\nMean Return: 0.0595%\nVolatility: 1.3445%\nSharpe Ratio: 4.4278%\nCumulative Return: 88.5475%",
    "crumbs": [
      "Travaux Pratiques",
      "Modern Portfolio Theory - Practical Work"
    ]
  },
  {
    "objectID": "content/Cours_4/portfolio_tp_uncorrected.html#question-3.1-creating-sector-returns",
    "href": "content/Cours_4/portfolio_tp_uncorrected.html#question-3.1-creating-sector-returns",
    "title": "Modern Portfolio Theory - Practical Work",
    "section": "Question 3.1: Creating Sector Returns",
    "text": "Question 3.1: Creating Sector Returns\nCreate sector-based returns by averaging returns of stocks within the same sector. First, define sector mappings, then compute their historical returns using our existing returns data.\nHint: - Define a dictionary mapping sectors to their constituent stocks - Use pandas mean() function to compute average returns - Remember to handle the train/test split consistently with previous analysis\n\n\n\nSector Returns Summary (Training Period):\n        Technology    Financial   Healthcare       Energy  Consumer_Staples  \\\ncount  2515.000000  2515.000000  2515.000000  2515.000000       2515.000000   \nmean      0.000708     0.000529     0.000561     0.000228          0.000435   \nstd       0.011622     0.015460     0.009070     0.013255          0.007475   \nmin      -0.056637    -0.120743    -0.048842    -0.080151         -0.039052   \n25%      -0.004963    -0.006888    -0.004165    -0.006827         -0.003661   \n50%       0.000966     0.000601     0.000699     0.000480          0.000543   \n75%       0.006897     0.008406     0.005836     0.007352          0.004696   \nmax       0.063131     0.090448     0.049754     0.058274          0.035414   \n\n       Consumer_Discretionary   Industrial    Materials  Telecommunications  \\\ncount             2515.000000  2515.000000  2515.000000         2515.000000   \nmean                 0.000850     0.000571     0.000464            0.000605   \nstd                  0.009784     0.011905     0.013003            0.009453   \nmin                 -0.055153    -0.069274    -0.058961           -0.054617   \n25%                 -0.004366    -0.005423    -0.006640           -0.004637   \n50%                  0.001120     0.000822     0.000835            0.001034   \n75%                  0.006386     0.006830     0.007747            0.006185   \nmax                  0.058083     0.059283     0.075934            0.038374   \n\n       Real_Estate  \ncount  2515.000000  \nmean      0.000552  \nstd       0.011736  \nmin      -0.079154  \n25%      -0.005862  \n50%       0.000981  \n75%       0.007002  \nmax       0.109263  \n\nSector Return Correlations (Training Period):\n                        Technology  Financial  Healthcare    Energy  \\\nTechnology                1.000000   0.652064    0.603375  0.597924   \nFinancial                 0.652064   1.000000    0.572227  0.634610   \nHealthcare                0.603375   0.572227    1.000000  0.527469   \nEnergy                    0.597924   0.634610    0.527469  1.000000   \nConsumer_Staples          0.515071   0.434815    0.616829  0.436855   \nConsumer_Discretionary    0.673522   0.631643    0.607782  0.538476   \nIndustrial                0.739289   0.762015    0.628253  0.719753   \nMaterials                 0.619829   0.639049    0.543687  0.716903   \nTelecommunications        0.553905   0.557995    0.584180  0.523741   \nReal_Estate               0.473704   0.491617    0.476236  0.440345   \n\n                        Consumer_Staples  Consumer_Discretionary  Industrial  \\\nTechnology                      0.515071                0.673522    0.739289   \nFinancial                       0.434815                0.631643    0.762015   \nHealthcare                      0.616829                0.607782    0.628253   \nEnergy                          0.436855                0.538476    0.719753   \nConsumer_Staples                1.000000                0.603731    0.535556   \nConsumer_Discretionary          0.603731                1.000000    0.704662   \nIndustrial                      0.535556                0.704662    1.000000   \nMaterials                       0.466227                0.579457    0.751812   \nTelecommunications              0.613324                0.583881    0.610452   \nReal_Estate                     0.532315                0.572199    0.537836   \n\n                        Materials  Telecommunications  Real_Estate  \nTechnology               0.619829            0.553905     0.473704  \nFinancial                0.639049            0.557995     0.491617  \nHealthcare               0.543687            0.584180     0.476236  \nEnergy                   0.716903            0.523741     0.440345  \nConsumer_Staples         0.466227            0.613324     0.532315  \nConsumer_Discretionary   0.579457            0.583881     0.572199  \nIndustrial               0.751812            0.610452     0.537836  \nMaterials                1.000000            0.529148     0.465546  \nTelecommunications       0.529148            1.000000     0.499715  \nReal_Estate              0.465546            0.499715     1.000000",
    "crumbs": [
      "Travaux Pratiques",
      "Modern Portfolio Theory - Practical Work"
    ]
  },
  {
    "objectID": "content/Cours_4/portfolio_tp_uncorrected.html#question-3.2-weight-conversion-function",
    "href": "content/Cours_4/portfolio_tp_uncorrected.html#question-3.2-weight-conversion-function",
    "title": "Modern Portfolio Theory - Practical Work",
    "section": "Question 3.2: Weight Conversion Function",
    "text": "Question 3.2: Weight Conversion Function\nCreate and test a function that converts sector-level portfolio weights into individual stock weights, assuming equal weighting within each sector.\nHint: - Each stock within a sector should have equal weight - The sum of all stock weights should equal 1 - Test the function with simple cases\n\n\n\nTest 1: Equal sector weights\n\nSector weights:\nTechnology: 0.1000\nFinancial: 0.1000\nHealthcare: 0.1000\nEnergy: 0.1000\nConsumer_Staples: 0.1000\nConsumer_Discretionary: 0.1000\nIndustrial: 0.1000\nMaterials: 0.1000\nTelecommunications: 0.1000\nReal_Estate: 0.1000\n\nResulting stock weights:\nAAPL: 0.0200\nMSFT: 0.0200\nINTC: 0.0200\nCSCO: 0.0200\nORCL: 0.0200\nJPM: 0.0143\nBAC: 0.0143\nGS: 0.0143\nMS: 0.0143\nC: 0.0143\nAXP: 0.0143\nWFC: 0.0143\nJNJ: 0.0200\nPFE: 0.0200\nMRK: 0.0200\nABT: 0.0200\nBMY: 0.0200\nXOM: 0.0200\nCVX: 0.0200\nCOP: 0.0200\nSLB: 0.0200\nOXY: 0.0200\nWMT: 0.0143\nPG: 0.0143\nKO: 0.0143\nPEP: 0.0143\nCL: 0.0143\nKMB: 0.0143\nGIS: 0.0143\nHD: 0.0143\nMCD: 0.0143\nNKE: 0.0143\nSBUX: 0.0143\nTJX: 0.0143\nLOW: 0.0143\nYUM: 0.0143\nCAT: 0.0143\nBA: 0.0143\nMMM: 0.0143\nHON: 0.0143\nGE: 0.0143\nDE: 0.0143\nFDX: 0.0143\nAPD: 0.0167\nECL: 0.0167\nNEM: 0.0167\nFCX: 0.0167\nPPG: 0.0167\nNUE: 0.0167\nVZ: 0.0333\nT: 0.0333\nCMCSA: 0.0333\nSPG: 0.0500\nPSA: 0.0500\n\nTest 2: Custom sector weights\n\nSector weights:\nTechnology: 0.3000\nFinancial: 0.2000\nHealthcare: 0.2000\nEnergy: 0.1000\nConsumer_Staples: 0.1000\nConsumer_Discretionary: 0.1000\n\nResulting stock weights:\nAAPL: 0.0600\nMSFT: 0.0600\nINTC: 0.0600\nCSCO: 0.0600\nORCL: 0.0600\nJPM: 0.0286\nBAC: 0.0286\nGS: 0.0286\nMS: 0.0286\nC: 0.0286\nAXP: 0.0286\nWFC: 0.0286\nJNJ: 0.0400\nPFE: 0.0400\nMRK: 0.0400\nABT: 0.0400\nBMY: 0.0400\nXOM: 0.0200\nCVX: 0.0200\nCOP: 0.0200\nSLB: 0.0200\nOXY: 0.0200\nWMT: 0.0143\nPG: 0.0143\nKO: 0.0143\nPEP: 0.0143\nCL: 0.0143\nKMB: 0.0143\nGIS: 0.0143\nHD: 0.0143\nMCD: 0.0143\nNKE: 0.0143\nSBUX: 0.0143\nTJX: 0.0143\nLOW: 0.0143\nYUM: 0.0143\n\nVerification - sum of weights: 1.000000",
    "crumbs": [
      "Travaux Pratiques",
      "Modern Portfolio Theory - Practical Work"
    ]
  },
  {
    "objectID": "content/Cours_4/portfolio_tp_uncorrected.html#question-3.3-sector-portfolio-optimization",
    "href": "content/Cours_4/portfolio_tp_uncorrected.html#question-3.3-sector-portfolio-optimization",
    "title": "Modern Portfolio Theory - Practical Work",
    "section": "Question 3.3: Sector Portfolio Optimization",
    "text": "Question 3.3: Sector Portfolio Optimization\nUsing the training period data, optimize sector-based portfolios for minimum variance and maximum Sharpe ratio. Compare with an equal-weight sector allocation.\nHint: - Use the same optimization approach as in Part 2 - Remember to create new constraints for the number of sectors - Use only training period data for optimization\n\n\n\nMinimum Variance Portfolio Weights:\nTechnology: 0.0000\nFinancial: 0.0000\nHealthcare: 0.2300\nEnergy: 0.0000\nConsumer_Staples: 0.4999\nConsumer_Discretionary: 0.0869\nIndustrial: 0.0000\nMaterials: 0.0000\nTelecommunications: 0.1832\nReal_Estate: 0.0000\n\nMaximum Sharpe Ratio Portfolio Weights:\nTechnology: 0.0000\nFinancial: 0.0000\nHealthcare: 0.0861\nEnergy: 0.0000\nConsumer_Staples: 0.0000\nConsumer_Discretionary: 0.7308\nIndustrial: 0.0000\nMaterials: 0.0000\nTelecommunications: 0.1831\nReal_Estate: 0.0000",
    "crumbs": [
      "Travaux Pratiques",
      "Modern Portfolio Theory - Practical Work"
    ]
  },
  {
    "objectID": "content/Cours_4/portfolio_tp_uncorrected.html#question-3.4-portfolio-visualization",
    "href": "content/Cours_4/portfolio_tp_uncorrected.html#question-3.4-portfolio-visualization",
    "title": "Modern Portfolio Theory - Practical Work",
    "section": "Question 3.4: Portfolio Visualization",
    "text": "Question 3.4: Portfolio Visualization\nCreate visualizations to compare the sector allocations and corresponding stock allocations for each portfolio strategy.\nHint: - Use pie charts to show both sector and stock level allocations - Use the sector_to_stock_weights function from Question 3.2 - Consider using subplots for clear comparison",
    "crumbs": [
      "Travaux Pratiques",
      "Modern Portfolio Theory - Practical Work"
    ]
  },
  {
    "objectID": "content/Cours_4/portfolio_tp_uncorrected.html#question-4.1-risk-metrics-function",
    "href": "content/Cours_4/portfolio_tp_uncorrected.html#question-4.1-risk-metrics-function",
    "title": "Modern Portfolio Theory - Practical Work",
    "section": "Question 4.1: Risk Metrics Function",
    "text": "Question 4.1: Risk Metrics Function\nCreate a function to calculate various risk metrics for a return series: - Maximum Drawdown - Sortino Ratio - Value at Risk (VaR) - Conditional Value at Risk (CVaR)\nHint: - Use cumulative returns for drawdown calculation - Consider using numpy percentile for VaR - Remember to annualize metrics where appropriate\n\n\n\nRisk Metrics for Equal-Weight Sector Portfolio (Training Period):\nMaximum Drawdown: -0.1618\nSortino Ratio: 1.0901\nVaR (95%): -0.0144\nCVaR (95%): -0.0216",
    "crumbs": [
      "Travaux Pratiques",
      "Modern Portfolio Theory - Practical Work"
    ]
  },
  {
    "objectID": "content/Cours_4/portfolio_tp_uncorrected.html#question-4.2-capm-analysis",
    "href": "content/Cours_4/portfolio_tp_uncorrected.html#question-4.2-capm-analysis",
    "title": "Modern Portfolio Theory - Practical Work",
    "section": "Question 4.2: CAPM Analysis",
    "text": "Question 4.2: CAPM Analysis\nCalculate CAPM metrics (alpha and beta) for sector portfolios. Compare the risk-adjusted performance across different portfolio strategies.\nHint: - Download market data (S&P 500) for the same period - Use linear regression to calculate beta - Remember to annualize alpha\n\n\n\n[*********************100%***********************]  1 of 1 completed\n/var/folders/dr/3gd86y8j4w19p8jdnqy5s65m0000gp/T/ipykernel_70455/2328182781.py:25: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n  alpha = model.params[0] * 252\n/var/folders/dr/3gd86y8j4w19p8jdnqy5s65m0000gp/T/ipykernel_70455/2328182781.py:26: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n  beta = model.params[1]\n/var/folders/dr/3gd86y8j4w19p8jdnqy5s65m0000gp/T/ipykernel_70455/2328182781.py:25: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n  alpha = model.params[0] * 252\n/var/folders/dr/3gd86y8j4w19p8jdnqy5s65m0000gp/T/ipykernel_70455/2328182781.py:26: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n  beta = model.params[1]\n/var/folders/dr/3gd86y8j4w19p8jdnqy5s65m0000gp/T/ipykernel_70455/2328182781.py:25: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n  alpha = model.params[0] * 252\n/var/folders/dr/3gd86y8j4w19p8jdnqy5s65m0000gp/T/ipykernel_70455/2328182781.py:26: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n  beta = model.params[1]\n/var/folders/dr/3gd86y8j4w19p8jdnqy5s65m0000gp/T/ipykernel_70455/2328182781.py:25: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n  alpha = model.params[0] * 252\n/var/folders/dr/3gd86y8j4w19p8jdnqy5s65m0000gp/T/ipykernel_70455/2328182781.py:26: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n  beta = model.params[1]\n/var/folders/dr/3gd86y8j4w19p8jdnqy5s65m0000gp/T/ipykernel_70455/2328182781.py:25: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n  alpha = model.params[0] * 252\n/var/folders/dr/3gd86y8j4w19p8jdnqy5s65m0000gp/T/ipykernel_70455/2328182781.py:26: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n  beta = model.params[1]\n/var/folders/dr/3gd86y8j4w19p8jdnqy5s65m0000gp/T/ipykernel_70455/2328182781.py:25: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n  alpha = model.params[0] * 252\n/var/folders/dr/3gd86y8j4w19p8jdnqy5s65m0000gp/T/ipykernel_70455/2328182781.py:26: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n  beta = model.params[1]\n\n\n\nEqual-Weight Portfolio CAPM Metrics:\nTraining Period - Alpha: 2.8582%, Beta: 0.9390\nTesting Period - Alpha: 0.6888%, Beta: 0.9013\n\nMin Variance Portfolio CAPM Metrics:\nTraining Period - Alpha: 5.2233%, Beta: 0.6415\nTesting Period - Alpha: -1.0409%, Beta: 0.5726\n\nMax Sharpe Portfolio CAPM Metrics:\nTraining Period - Alpha: 9.7843%, Beta: 0.8203\nTesting Period - Alpha: -1.7344%, Beta: 0.8535",
    "crumbs": [
      "Travaux Pratiques",
      "Modern Portfolio Theory - Practical Work"
    ]
  },
  {
    "objectID": "content/Cours_4/portfolio_tp_uncorrected.html#question-4.3-performance-comparison",
    "href": "content/Cours_4/portfolio_tp_uncorrected.html#question-4.3-performance-comparison",
    "title": "Modern Portfolio Theory - Practical Work",
    "section": "Question 4.3: Performance Comparison",
    "text": "Question 4.3: Performance Comparison\nCompare the performance of sector-based portfolios with the individual stock portfolios from Part 2. Create visualizations showing the cumulative returns and risk metrics for both approaches.\nHint: - Use the optimal portfolios from both Parts 2 and 3 - Plot cumulative returns on the same graph - Create a summary table of risk metrics\n\n\n\n\n\n\n\n\n\n\n\nRisk Metrics Comparison (Testing Period):\n\nSector Equal-Weight:\nMaximum Drawdown: -0.3801\nSortino Ratio: 0.6716\nVaR (95%): -0.0170\nCVaR (95%): -0.0311\n\nSector Min Variance:\nMaximum Drawdown: -0.2407\nSortino Ratio: 0.4855\nVaR (95%): -0.0136\nCVaR (95%): -0.0229\n\nSector Max Sharpe:\nMaximum Drawdown: -0.3563\nSortino Ratio: 0.5206\nVaR (95%): -0.0174\nCVaR (95%): -0.0301\n\nStock Min Variance:\nMaximum Drawdown: -0.2395\nSortino Ratio: 0.6236\nVaR (95%): -0.0134\nCVaR (95%): -0.0226\n\nStock Max Sharpe:\nMaximum Drawdown: -0.3405\nSortino Ratio: 0.7347\nVaR (95%): -0.0177\nCVaR (95%): -0.0309\n\n\n\n\n\n\n\n\n\n\n\n\n\nRisk Metrics Comparison (Testing Period):\n\nSector Equal-Weight:\nMaximum Drawdown: -0.3801\nSortino Ratio: 0.6716\nVaR (95%): -0.0170\nCVaR (95%): -0.0311\n\nSector Min Variance:\nMaximum Drawdown: -0.2407\nSortino Ratio: 0.4855\nVaR (95%): -0.0136\nCVaR (95%): -0.0229\n\nSector Max Sharpe:\nMaximum Drawdown: -0.3563\nSortino Ratio: 0.5206\nVaR (95%): -0.0174\nCVaR (95%): -0.0301\n\nStock Min Variance:\nMaximum Drawdown: -0.2395\nSortino Ratio: 0.6236\nVaR (95%): -0.0134\nCVaR (95%): -0.0226\n\nStock Max Sharpe:\nMaximum Drawdown: -0.3405\nSortino Ratio: 0.7347\nVaR (95%): -0.0177\nCVaR (95%): -0.0309",
    "crumbs": [
      "Travaux Pratiques",
      "Modern Portfolio Theory - Practical Work"
    ]
  },
  {
    "objectID": "content/Cours_4/portfolio_tp_corrected.html",
    "href": "content/Cours_4/portfolio_tp_corrected.html",
    "title": "Modern Portfolio Theory - Practical Work - Corrected version",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport yfinance as yf\nfrom scipy.optimize import minimize\nimport seaborn as sns\n\n\n\n\n\nWe will work with a diversified portfolio of major stocks covering different sectors of the economy. Using the yfinance library, retrieve daily closing prices for the following stocks from January 1st, 2015 to January 1st, 2025:\nHint: Use yf.download() function with parameters: - tickers: list or string of tickers - start: start date - end: end date - interval: ‘d’ for daily data - Use the ‘Close’ column\n\n# Define the tickers\ntickers = [\n    # Technology\n    'AAPL', 'MSFT', 'INTC', 'CSCO', 'ORCL',\n    # Financial Services\n    'JPM', 'BAC', 'GS', 'MS', 'C', 'AXP', 'WFC',\n    # Healthcare\n    'JNJ', 'PFE', 'MRK', 'ABT', 'BMY',\n    # Energy\n    'XOM', 'CVX', 'COP', 'SLB', 'OXY',\n    # Consumer Staples\n    'WMT', 'PG', 'KO', 'PEP', 'CL', 'KMB', 'GIS',\n    # Consumer Discretionary\n    'HD', 'MCD', 'NKE', 'SBUX', 'TJX', 'LOW', 'YUM',\n    # Industrial\n    'CAT', 'BA', 'MMM', 'HON', 'GE', 'DE', 'FDX',\n    # Materials\n    'APD', 'ECL', 'NEM', 'FCX', 'PPG', 'NUE',\n    # Telecommunications\n    'VZ', 'T', 'CMCSA',\n    # Real Estate\n    'SPG', 'PSA'\n]\n\n\n# Download the data\nstart_date = '2010-01-01'\nend_date = '2025-01-01'\n\nprices = yf.download(tickers, \n                    start=start_date,\n                    end=end_date,\n                    interval='1d')['Close']\n\n# Check the first few rows of the data\nprint(\"First few rows of the price data:\")\nprint(prices.head())\n\n[*********************100%***********************]  54 of 54 completed\n\n\nFirst few rows of the price data:\nTicker          AAPL        ABT        APD        AXP         BA        BAC  \\\nDate                                                                          \n2010-01-04  6.447412  18.665758  52.804508  32.828983  43.777561  12.451034   \n2010-01-05  6.458560  18.514959  52.366360  32.756783  45.211349  12.855753   \n2010-01-06  6.355827  18.617779  51.934586  33.286285  46.582794  13.006530   \n2010-01-07  6.344077  18.772020  51.636158  33.826145  48.468563  13.435059   \n2010-01-08  6.386254  18.867979  51.966351  33.801979  48.001026  13.316021   \n\nTicker            BMY          C        CAT         CL  ...      SBUX  \\\nDate                                                    ...             \n2010-01-04  15.436789  25.928009  39.738235  28.930437  ...  8.835545   \n2010-01-05  15.195873  26.919380  40.213326  29.164408  ...  9.042539   \n2010-01-06  15.189850  27.758226  40.335484  29.098055  ...  8.977375   \n2010-01-07  15.201899  27.834469  40.498383  28.982828  ...  8.954374   \n2010-01-08  14.948930  27.376934  40.953117  28.462532  ...  8.923708   \n\nTicker            SLB        SPG         T       TJX         VZ        WFC  \\\nDate                                                                         \n2010-01-04  47.246723  39.174126  7.038978  7.384900  14.442019  18.417709   \n2010-01-05  47.380508  38.906082  7.004502  7.583662  14.468057  18.923317   \n2010-01-06  48.436508  38.469257  6.935692  7.614400  14.052043  18.950285   \n2010-01-07  48.936378  38.970608  6.857815  8.003725  13.968397  19.637922   \n2010-01-08  49.738956  38.037426  6.807579  7.899220  13.977206  19.455894   \n\nTicker            WMT        XOM        YUM  \nDate                                         \n2010-01-04  13.084426  39.272114  18.878279  \n2010-01-05  12.954136  39.425453  18.813725  \n2010-01-06  12.925184  39.766212  18.679226  \n2010-01-07  12.932426  39.641270  18.673841  \n2010-01-08  12.867274  39.482235  18.679226  \n\n[5 rows x 54 columns]\n\n\n\n\n\nCalculate the daily returns for each asset. The daily return is defined as the percentage change in price from one day to the next.\nHint: - Use the pct_change() method from pandas - Be sure to handle any missing values that might appear\n\n# Calculate daily returns\nreturns = prices.pct_change()\n\n# Drop any missing values\nreturns = returns.dropna()\n\n# Display summary statistics of the returns\nprint(\"\\nSummary statistics of daily returns:\")\nprint(returns.describe())\n\n\nSummary statistics of daily returns:\nTicker         AAPL          ABT          APD          AXP           BA  \\\ncount   3773.000000  3773.000000  3773.000000  3773.000000  3773.000000   \nmean       0.001124     0.000568     0.000567     0.000748     0.000625   \nstd        0.017552     0.013505     0.015242     0.018248     0.022538   \nmin       -0.128647    -0.097857    -0.155518    -0.148187    -0.238484   \n25%       -0.007398    -0.006053    -0.006462    -0.007042    -0.009198   \n50%        0.001001     0.000596     0.000751     0.000768     0.000676   \n75%        0.010355     0.007639     0.008000     0.009271     0.010452   \nmax        0.119808     0.109360     0.137233     0.218822     0.243186   \n\nTicker          BAC          BMY            C          CAT           CL  ...  \\\ncount   3773.000000  3773.000000  3773.000000  3773.000000  3773.000000  ...   \nmean       0.000559     0.000449     0.000494     0.000753     0.000365  ...   \nstd        0.021172     0.014655     0.021367     0.018295     0.011262  ...   \nmin       -0.203182    -0.159851    -0.192986    -0.142822    -0.097829  ...   \n25%       -0.009895    -0.006971    -0.009486    -0.008498    -0.005121  ...   \n50%        0.000349     0.000622     0.000294     0.000584     0.000369  ...   \n75%        0.010749     0.007588     0.010222     0.010267     0.006184  ...   \nmax        0.177962     0.114425     0.179843     0.103321     0.126082  ...   \n\nTicker         SBUX          SLB          SPG            T          TJX  \\\ncount   3773.000000  3773.000000  3773.000000  3773.000000  3773.000000   \nmean       0.000768     0.000208     0.000605     0.000392     0.000864   \nstd        0.017326     0.022881     0.020546     0.012944     0.015659   \nmin       -0.162042    -0.274214    -0.267127    -0.104061    -0.203995   \n25%       -0.007363    -0.010883    -0.007593    -0.005913    -0.006955   \n50%        0.000654    -0.000108     0.000992     0.000725     0.000714   \n75%        0.008734     0.010998     0.009068     0.006838     0.008502   \nmax        0.244970     0.199080     0.278694     0.100223     0.129033   \n\nTicker           VZ          WFC          WMT          XOM          YUM  \ncount   3773.000000  3773.000000  3773.000000  3773.000000  3773.000000  \nmean       0.000333     0.000532     0.000585     0.000391     0.000631  \nstd        0.011605     0.018845     0.012085     0.015723     0.014886  \nmin       -0.074978    -0.158676    -0.113757    -0.122248    -0.188324  \n25%       -0.005823    -0.008342    -0.005145    -0.007267    -0.006211  \n50%        0.000496     0.000341     0.000679     0.000133     0.000812  \n75%        0.006458     0.009181     0.006373     0.007995     0.007590  \nmax        0.092705     0.145346     0.117085     0.126868     0.232485  \n\n[8 rows x 54 columns]\n\n\n\n\n\nCreate a visualization of the correlation between the assets using a heatmap. Also, compute and display the covariance matrix.\nHint: - Use seaborn.heatmap() for visualization - Use returns.corr() for correlation matrix - Use returns.cov() for covariance matrix\n\n# Compute correlation matrix\ncorrelation_matrix = returns.corr()\n\n# Create a heatmap\nplt.figure(figsize=(10, 8))\nsns.heatmap(correlation_matrix, \n            annot=False,\n            cmap='coolwarm', \n            vmin=-1, \n            vmax=1,\n            center=0)\nplt.title('Correlation Matrix of Asset Returns')\nplt.show()\n\n# Compute and display covariance matrix\ncovariance_matrix = returns.cov()\nprint(\"\\nCovariance Matrix:\")\nprint(covariance_matrix)\n\n\n\n\n\n\n\n\n\nCovariance Matrix:\nTicker      AAPL       ABT       APD       AXP        BA       BAC       BMY  \\\nTicker                                                                         \nAAPL    0.000308  0.000095  0.000105  0.000131  0.000152  0.000141  0.000065   \nABT     0.000095  0.000182  0.000097  0.000101  0.000103  0.000111  0.000079   \nAPD     0.000105  0.000097  0.000232  0.000135  0.000143  0.000158  0.000073   \nAXP     0.000131  0.000101  0.000135  0.000333  0.000237  0.000260  0.000081   \nBA      0.000152  0.000103  0.000143  0.000237  0.000508  0.000236  0.000082   \nBAC     0.000141  0.000111  0.000158  0.000260  0.000236  0.000448  0.000091   \nBMY     0.000065  0.000079  0.000073  0.000081  0.000082  0.000091  0.000215   \nC       0.000147  0.000114  0.000162  0.000265  0.000263  0.000383  0.000097   \nCAT     0.000128  0.000087  0.000147  0.000187  0.000200  0.000226  0.000074   \nCL      0.000059  0.000069  0.000075  0.000064  0.000070  0.000067  0.000055   \nCMCSA   0.000103  0.000081  0.000100  0.000136  0.000133  0.000153  0.000070   \nCOP     0.000111  0.000078  0.000134  0.000193  0.000209  0.000226  0.000081   \nCSCO    0.000132  0.000096  0.000110  0.000136  0.000139  0.000163  0.000073   \nCVX     0.000100  0.000080  0.000121  0.000171  0.000187  0.000194  0.000077   \nDE      0.000120  0.000085  0.000131  0.000168  0.000198  0.000198  0.000072   \nECL     0.000110  0.000097  0.000131  0.000150  0.000153  0.000159  0.000071   \nFCX     0.000186  0.000127  0.000210  0.000263  0.000292  0.000306  0.000103   \nFDX     0.000127  0.000096  0.000130  0.000163  0.000193  0.000199  0.000071   \nGE      0.000118  0.000087  0.000128  0.000196  0.000234  0.000221  0.000074   \nGIS     0.000043  0.000053  0.000058  0.000041  0.000035  0.000051  0.000046   \nGS      0.000131  0.000099  0.000136  0.000217  0.000207  0.000297  0.000081   \nHD      0.000118  0.000091  0.000107  0.000134  0.000144  0.000147  0.000070   \nHON     0.000116  0.000094  0.000130  0.000170  0.000195  0.000188  0.000078   \nINTC    0.000161  0.000108  0.000125  0.000155  0.000181  0.000171  0.000069   \nJNJ     0.000061  0.000078  0.000072  0.000075  0.000076  0.000084  0.000071   \nJPM     0.000119  0.000100  0.000139  0.000225  0.000209  0.000316  0.000083   \nKMB     0.000050  0.000062  0.000066  0.000056  0.000055  0.000058  0.000053   \nKO      0.000064  0.000065  0.000077  0.000090  0.000098  0.000088  0.000053   \nLOW     0.000122  0.000096  0.000113  0.000146  0.000159  0.000165  0.000072   \nMCD     0.000078  0.000066  0.000077  0.000098  0.000110  0.000096  0.000052   \nMMM     0.000099  0.000085  0.000112  0.000135  0.000138  0.000157  0.000071   \nMRK     0.000064  0.000084  0.000078  0.000081  0.000077  0.000096  0.000076   \nMS      0.000151  0.000124  0.000168  0.000256  0.000237  0.000365  0.000100   \nMSFT    0.000166  0.000105  0.000112  0.000136  0.000139  0.000144  0.000066   \nNEM     0.000056  0.000040  0.000070  0.000048  0.000056  0.000044  0.000036   \nNKE     0.000127  0.000093  0.000109  0.000145  0.000164  0.000148  0.000066   \nNUE     0.000125  0.000090  0.000155  0.000192  0.000200  0.000240  0.000079   \nORCL    0.000128  0.000090  0.000115  0.000135  0.000132  0.000158  0.000066   \nOXY     0.000125  0.000083  0.000147  0.000224  0.000272  0.000269  0.000080   \nPEP     0.000071  0.000069  0.000075  0.000075  0.000079  0.000078  0.000055   \nPFE     0.000072  0.000084  0.000082  0.000090  0.000092  0.000106  0.000090   \nPG      0.000063  0.000068  0.000069  0.000066  0.000066  0.000071  0.000053   \nPPG     0.000113  0.000095  0.000143  0.000167  0.000177  0.000187  0.000076   \nPSA     0.000080  0.000070  0.000084  0.000093  0.000100  0.000104  0.000056   \nSBUX    0.000128  0.000091  0.000119  0.000156  0.000169  0.000161  0.000069   \nSLB     0.000120  0.000073  0.000145  0.000219  0.000237  0.000255  0.000077   \nSPG     0.000112  0.000070  0.000114  0.000218  0.000260  0.000215  0.000071   \nT       0.000064  0.000065  0.000076  0.000099  0.000101  0.000116  0.000055   \nTJX     0.000102  0.000081  0.000099  0.000147  0.000168  0.000153  0.000060   \nVZ      0.000049  0.000057  0.000064  0.000069  0.000066  0.000083  0.000047   \nWFC     0.000119  0.000097  0.000138  0.000237  0.000227  0.000315  0.000085   \nWMT     0.000061  0.000056  0.000058  0.000056  0.000056  0.000065  0.000043   \nXOM     0.000085  0.000065  0.000106  0.000149  0.000169  0.000174  0.000066   \nYUM     0.000098  0.000079  0.000100  0.000131  0.000144  0.000134  0.000061   \n\nTicker         C       CAT        CL  ...      SBUX       SLB       SPG  \\\nTicker                                ...                                 \nAAPL    0.000147  0.000128  0.000059  ...  0.000128  0.000120  0.000112   \nABT     0.000114  0.000087  0.000069  ...  0.000091  0.000073  0.000070   \nAPD     0.000162  0.000147  0.000075  ...  0.000119  0.000145  0.000114   \nAXP     0.000265  0.000187  0.000064  ...  0.000156  0.000219  0.000218   \nBA      0.000263  0.000200  0.000070  ...  0.000169  0.000237  0.000260   \nBAC     0.000383  0.000226  0.000067  ...  0.000161  0.000255  0.000215   \nBMY     0.000097  0.000074  0.000055  ...  0.000069  0.000077  0.000071   \nC       0.000457  0.000233  0.000072  ...  0.000169  0.000279  0.000238   \nCAT     0.000233  0.000335  0.000058  ...  0.000122  0.000248  0.000160   \nCL      0.000072  0.000058  0.000127  ...  0.000071  0.000055  0.000064   \nCMCSA   0.000160  0.000127  0.000066  ...  0.000113  0.000131  0.000129   \nCOP     0.000243  0.000216  0.000055  ...  0.000123  0.000366  0.000190   \nCSCO    0.000166  0.000139  0.000068  ...  0.000120  0.000141  0.000115   \nCVX     0.000210  0.000181  0.000058  ...  0.000111  0.000286  0.000170   \nDE      0.000204  0.000229  0.000061  ...  0.000119  0.000205  0.000155   \nECL     0.000164  0.000131  0.000072  ...  0.000127  0.000139  0.000141   \nFCX     0.000327  0.000345  0.000069  ...  0.000171  0.000379  0.000240   \nFDX     0.000213  0.000179  0.000065  ...  0.000134  0.000177  0.000157   \nGE      0.000237  0.000190  0.000061  ...  0.000131  0.000222  0.000192   \nGIS     0.000048  0.000038  0.000068  ...  0.000045  0.000036  0.000032   \nGS      0.000303  0.000194  0.000061  ...  0.000139  0.000217  0.000186   \nHD      0.000153  0.000120  0.000070  ...  0.000127  0.000111  0.000139   \nHON     0.000197  0.000172  0.000066  ...  0.000127  0.000175  0.000161   \nINTC    0.000185  0.000155  0.000062  ...  0.000123  0.000153  0.000134   \nJNJ     0.000086  0.000070  0.000060  ...  0.000063  0.000068  0.000060   \nJPM     0.000315  0.000192  0.000065  ...  0.000139  0.000221  0.000188   \nKMB     0.000059  0.000049  0.000086  ...  0.000057  0.000039  0.000054   \nKO      0.000094  0.000074  0.000071  ...  0.000075  0.000082  0.000095   \nLOW     0.000173  0.000135  0.000071  ...  0.000137  0.000133  0.000157   \nMCD     0.000107  0.000077  0.000059  ...  0.000106  0.000088  0.000104   \nMMM     0.000162  0.000154  0.000065  ...  0.000101  0.000142  0.000125   \nMRK     0.000098  0.000078  0.000059  ...  0.000068  0.000083  0.000068   \nMS      0.000367  0.000232  0.000074  ...  0.000167  0.000260  0.000204   \nMSFT    0.000152  0.000123  0.000067  ...  0.000129  0.000107  0.000105   \nNEM     0.000050  0.000078  0.000038  ...  0.000045  0.000099  0.000056   \nNKE     0.000160  0.000129  0.000065  ...  0.000153  0.000125  0.000138   \nNUE     0.000252  0.000230  0.000061  ...  0.000131  0.000243  0.000180   \nORCL    0.000163  0.000136  0.000068  ...  0.000117  0.000129  0.000104   \nOXY     0.000293  0.000244  0.000058  ...  0.000142  0.000429  0.000262   \nPEP     0.000081  0.000062  0.000079  ...  0.000077  0.000062  0.000075   \nPFE     0.000109  0.000086  0.000056  ...  0.000073  0.000084  0.000079   \nPG      0.000073  0.000056  0.000085  ...  0.000066  0.000050  0.000056   \nPPG     0.000199  0.000167  0.000068  ...  0.000129  0.000165  0.000160   \nPSA     0.000107  0.000084  0.000068  ...  0.000090  0.000076  0.000139   \nSBUX    0.000169  0.000122  0.000071  ...  0.000300  0.000134  0.000157   \nSLB     0.000279  0.000248  0.000055  ...  0.000134  0.000524  0.000229   \nSPG     0.000238  0.000160  0.000064  ...  0.000157  0.000229  0.000422   \nT       0.000122  0.000090  0.000059  ...  0.000072  0.000102  0.000099   \nTJX     0.000158  0.000120  0.000062  ...  0.000125  0.000128  0.000165   \nVZ      0.000083  0.000067  0.000056  ...  0.000059  0.000066  0.000071   \nWFC     0.000311  0.000191  0.000067  ...  0.000144  0.000229  0.000205   \nWMT     0.000063  0.000054  0.000057  ...  0.000060  0.000044  0.000051   \nXOM     0.000188  0.000166  0.000052  ...  0.000093  0.000268  0.000155   \nYUM     0.000144  0.000114  0.000058  ...  0.000141  0.000113  0.000129   \n\nTicker         T       TJX        VZ       WFC       WMT       XOM       YUM  \nTicker                                                                        \nAAPL    0.000064  0.000102  0.000049  0.000119  0.000061  0.000085  0.000098  \nABT     0.000065  0.000081  0.000057  0.000097  0.000056  0.000065  0.000079  \nAPD     0.000076  0.000099  0.000064  0.000138  0.000058  0.000106  0.000100  \nAXP     0.000099  0.000147  0.000069  0.000237  0.000056  0.000149  0.000131  \nBA      0.000101  0.000168  0.000066  0.000227  0.000056  0.000169  0.000144  \nBAC     0.000116  0.000153  0.000083  0.000315  0.000065  0.000174  0.000134  \nBMY     0.000055  0.000060  0.000047  0.000085  0.000043  0.000066  0.000061  \nC       0.000122  0.000158  0.000083  0.000311  0.000063  0.000188  0.000144  \nCAT     0.000090  0.000120  0.000067  0.000191  0.000054  0.000166  0.000114  \nCL      0.000059  0.000062  0.000056  0.000067  0.000057  0.000052  0.000058  \nCMCSA   0.000093  0.000100  0.000073  0.000139  0.000057  0.000098  0.000087  \nCOP     0.000092  0.000115  0.000065  0.000201  0.000046  0.000263  0.000111  \nCSCO    0.000079  0.000102  0.000061  0.000140  0.000067  0.000103  0.000095  \nCVX     0.000089  0.000108  0.000067  0.000174  0.000047  0.000221  0.000102  \nDE      0.000085  0.000118  0.000063  0.000173  0.000055  0.000138  0.000107  \nECL     0.000078  0.000115  0.000060  0.000142  0.000055  0.000102  0.000111  \nFCX     0.000119  0.000164  0.000083  0.000259  0.000068  0.000250  0.000165  \nFDX     0.000082  0.000122  0.000063  0.000173  0.000064  0.000120  0.000106  \nGE      0.000099  0.000133  0.000070  0.000203  0.000050  0.000153  0.000111  \nGIS     0.000052  0.000037  0.000050  0.000050  0.000051  0.000039  0.000040  \nGS      0.000097  0.000130  0.000067  0.000247  0.000056  0.000146  0.000117  \nHD      0.000072  0.000125  0.000060  0.000132  0.000070  0.000086  0.000104  \nHON     0.000085  0.000121  0.000063  0.000169  0.000055  0.000122  0.000113  \nINTC    0.000080  0.000112  0.000063  0.000153  0.000065  0.000111  0.000099  \nJNJ     0.000058  0.000058  0.000053  0.000078  0.000048  0.000062  0.000058  \nJPM     0.000102  0.000135  0.000074  0.000265  0.000058  0.000152  0.000119  \nKMB     0.000058  0.000048  0.000057  0.000055  0.000053  0.000043  0.000054  \nKO      0.000065  0.000070  0.000057  0.000087  0.000049  0.000071  0.000069  \nLOW     0.000075  0.000138  0.000060  0.000146  0.000068  0.000098  0.000112  \nMCD     0.000055  0.000083  0.000045  0.000092  0.000045  0.000068  0.000103  \nMMM     0.000076  0.000095  0.000060  0.000143  0.000052  0.000102  0.000090  \nMRK     0.000061  0.000062  0.000057  0.000084  0.000048  0.000070  0.000064  \nMS      0.000114  0.000152  0.000081  0.000293  0.000070  0.000174  0.000137  \nMSFT    0.000061  0.000101  0.000054  0.000124  0.000066  0.000083  0.000104  \nNEM     0.000047  0.000023  0.000040  0.000035  0.000029  0.000072  0.000049  \nNKE     0.000070  0.000130  0.000055  0.000136  0.000059  0.000094  0.000115  \nNUE     0.000096  0.000133  0.000077  0.000209  0.000065  0.000167  0.000115  \nORCL    0.000073  0.000099  0.000057  0.000135  0.000064  0.000090  0.000089  \nOXY     0.000111  0.000131  0.000070  0.000243  0.000044  0.000303  0.000118  \nPEP     0.000061  0.000066  0.000056  0.000076  0.000060  0.000061  0.000064  \nPFE     0.000065  0.000065  0.000058  0.000096  0.000049  0.000072  0.000063  \nPG      0.000059  0.000053  0.000056  0.000068  0.000058  0.000051  0.000054  \nPPG     0.000078  0.000122  0.000062  0.000168  0.000049  0.000113  0.000117  \nPSA     0.000061  0.000080  0.000057  0.000092  0.000051  0.000064  0.000080  \nSBUX    0.000072  0.000125  0.000059  0.000144  0.000060  0.000093  0.000141  \nSLB     0.000102  0.000128  0.000066  0.000229  0.000044  0.000268  0.000113  \nSPG     0.000099  0.000165  0.000071  0.000205  0.000051  0.000155  0.000129  \nT       0.000168  0.000074  0.000101  0.000110  0.000048  0.000085  0.000063  \nTJX     0.000074  0.000245  0.000056  0.000143  0.000061  0.000097  0.000109  \nVZ      0.000101  0.000056  0.000135  0.000078  0.000046  0.000063  0.000048  \nWFC     0.000110  0.000143  0.000078  0.000355  0.000060  0.000162  0.000118  \nWMT     0.000048  0.000061  0.000046  0.000060  0.000146  0.000044  0.000045  \nXOM     0.000085  0.000097  0.000063  0.000162  0.000044  0.000247  0.000087  \nYUM     0.000063  0.000109  0.000048  0.000118  0.000045  0.000087  0.000222  \n\n[54 rows x 54 columns]\n\n\n\n\n\nCreate a plot showing the evolution of prices for all assets on the same graph. Make sure to normalize the prices to start at 100 to make them comparable.\nHint: - Normalize prices by dividing by the initial price and multiplying by 100 - Use matplotlib’s plot function - Add a legend to distinguish between assets\n\n# Normalize prices\nnormalized_prices = prices / prices.iloc[0] * 100\n\n# Create the plot\nplt.figure(figsize=(12, 6))\nfor column in normalized_prices.columns:\n    plt.plot(normalized_prices.index, normalized_prices[column], label=column)\n\nplt.title('Normalized Price Evolution (Base 100)')\nplt.xlabel('Date')\nplt.ylabel('Normalized Price')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreate an equally-weighted portfolio from our five assets. Calculate its daily returns and analyze its performance metrics (mean return, volatility, Sharpe ratio assuming risk-free rate = 0).\nHint: - Equal weights means 1/N for each asset - Portfolio return is the weighted sum of individual returns - Portfolio volatility requires using the covariance matrix\n\n# Create equal weights\nn_assets = len(tickers)\nweights_equal = np.array([1/n_assets] * n_assets)\n\n# Calculate portfolio returns\nportfolio_returns = returns @ weights_equal\n\n# Calculate portfolio metrics\nportfolio_mean_return = portfolio_returns.mean()\nportfolio_volatility = np.sqrt(weights_equal.T @ covariance_matrix @ weights_equal)\nsharpe_ratio = portfolio_mean_return / portfolio_volatility\n\nprint(f\"Equal-weighted Portfolio Metrics (daily):\")\nprint(f\"Mean Return: {portfolio_mean_return:.4%}\")\nprint(f\"Volatility: {portfolio_volatility:.4%}\")\nprint(f\"Sharpe Ratio: {sharpe_ratio:.4f}\")\n\nEqual-weighted Portfolio Metrics (daily):\nMean Return: 0.0556%\nVolatility: 1.0755%\nSharpe Ratio: 0.0517\n\n\n\n\n\nWrite a function that computes the mean return and volatility of a portfolio given: - A set of weights - The mean returns of individual assets - The covariance matrix of returns\nHint: - Portfolio return = weighted sum of individual returns - Portfolio variance = w^T * Σ * w (where Σ is the covariance matrix)\n\ndef portfolio_metrics(weights, mean_returns, cov_matrix):\n    \"\"\"\n    Calculate portfolio metrics\n    \n    Parameters:\n    weights: array of asset weights\n    mean_returns: array of asset mean returns\n    cov_matrix: covariance matrix of returns\n    \n    Returns:\n    tuple: (portfolio return, portfolio volatility)\n    \"\"\"\n    portfolio_return = np.sum(mean_returns * weights)\n    portfolio_volatility = np.sqrt(weights.T @ cov_matrix @ weights)\n    \n    return portfolio_return, portfolio_volatility\n\n# Test the function with equal weights\nmean_returns = returns.mean()\ntest_metrics = portfolio_metrics(weights_equal, mean_returns, covariance_matrix)\nprint(\"\\nTest with equal weights:\")\nprint(f\"Portfolio Return: {test_metrics[0]:.4%}\")\nprint(f\"Portfolio Volatility: {test_metrics[1]:.4%}\")\n\n\nTest with equal weights:\nPortfolio Return: 0.0556%\nPortfolio Volatility: 1.0755%\n\n\n\n\n\nSplit your data into two periods: training (2020-2021) and testing (2022-2023). Calculate the mean returns and covariance matrix for the training period.\nHint: - Use datetime index to split the data - Recalculate all metrics on the training set\n\n# Split the data\nsplit_date = '2020-01-01'\ntrain_returns = returns[returns.index &lt; split_date]\ntest_returns = returns[returns.index &gt;= split_date]\n\n# Calculate metrics for training period\ntrain_mean_returns = train_returns.mean()\ntrain_cov_matrix = train_returns.cov()\n\nprint(\"Training Period Statistics:\")\nprint(\"\\nMean Returns:\")\nprint(train_mean_returns)\nprint(\"\\nCovariance Matrix:\")\nprint(train_cov_matrix)\n\n\nTraining Period Statistics:\n\nMean Returns:\nTicker\nAAPL     0.001087\nABT      0.000644\nAPD      0.000630\nAXP      0.000605\nBA       0.000918\nBAC      0.000574\nBMY      0.000599\nC        0.000563\nCAT      0.000624\nCL       0.000349\nCMCSA    0.000832\nCOP      0.000472\nCSCO     0.000489\nCVX      0.000404\nDE       0.000664\nECL      0.000692\nFCX      0.000109\nFDX      0.000395\nGE       0.000142\nGIS      0.000354\nGS       0.000303\nHD       0.000980\nHON      0.000778\nINTC     0.000661\nJNJ      0.000488\nJPM      0.000689\nKMB      0.000510\nKO       0.000430\nLOW      0.000846\nMCD      0.000623\nMMM      0.000477\nMRK      0.000569\nMS       0.000478\nMSFT     0.000845\nNEM      0.000262\nNKE      0.000887\nNUE      0.000329\nORCL     0.000459\nOXY      0.000020\nPEP      0.000477\nPFE      0.000502\nPG       0.000453\nPPG      0.000765\nPSA      0.000599\nSBUX     0.000982\nSLB      0.000046\nSPG      0.000505\nT        0.000470\nTJX      0.000900\nVZ       0.000514\nWFC      0.000488\nWMT      0.000470\nXOM      0.000200\nYUM      0.000729\ndtype: float64\n\nCovariance Matrix:\nTicker      AAPL       ABT       APD       AXP        BA       BAC       BMY  \\\nTicker                                                                         \nAAPL    0.000263  0.000065  0.000078  0.000089  0.000099  0.000119  0.000058   \nABT     0.000065  0.000138  0.000072  0.000077  0.000080  0.000091  0.000072   \nAPD     0.000078  0.000072  0.000167  0.000095  0.000103  0.000129  0.000062   \nAXP     0.000089  0.000077  0.000095  0.000205  0.000112  0.000177  0.000066   \nBA      0.000099  0.000080  0.000103  0.000112  0.000244  0.000152  0.000069   \nBAC     0.000119  0.000091  0.000129  0.000177  0.000152  0.000419  0.000081   \nBMY     0.000058  0.000072  0.000062  0.000066  0.000069  0.000081  0.000211   \nC       0.000118  0.000099  0.000135  0.000171  0.000153  0.000332  0.000088   \nCAT     0.000120  0.000078  0.000127  0.000130  0.000144  0.000189  0.000068   \nCL      0.000042  0.000047  0.000056  0.000053  0.000058  0.000051  0.000045   \nCMCSA   0.000075  0.000061  0.000080  0.000092  0.000087  0.000123  0.000059   \nCOP     0.000088  0.000068  0.000097  0.000100  0.000104  0.000153  0.000061   \nCSCO    0.000105  0.000075  0.000091  0.000098  0.000103  0.000142  0.000062   \nCVX     0.000076  0.000066  0.000089  0.000089  0.000094  0.000131  0.000059   \nDE      0.000101  0.000070  0.000105  0.000107  0.000123  0.000159  0.000061   \nECL     0.000067  0.000065  0.000089  0.000079  0.000085  0.000111  0.000058   \nFCX     0.000149  0.000111  0.000167  0.000176  0.000178  0.000255  0.000091   \nFDX     0.000094  0.000078  0.000106  0.000114  0.000125  0.000171  0.000067   \nGE      0.000086  0.000069  0.000095  0.000109  0.000107  0.000161  0.000063   \nGIS     0.000034  0.000038  0.000044  0.000040  0.000041  0.000047  0.000034   \nGS      0.000100  0.000080  0.000110  0.000138  0.000122  0.000251  0.000071   \nHD      0.000076  0.000063  0.000076  0.000090  0.000088  0.000115  0.000059   \nHON     0.000093  0.000076  0.000106  0.000110  0.000124  0.000152  0.000068   \nINTC    0.000107  0.000077  0.000086  0.000097  0.000102  0.000129  0.000063   \nJNJ     0.000045  0.000057  0.000055  0.000059  0.000062  0.000069  0.000059   \nJPM     0.000095  0.000081  0.000111  0.000144  0.000125  0.000268  0.000075   \nKMB     0.000032  0.000044  0.000050  0.000042  0.000047  0.000046  0.000045   \nKO      0.000039  0.000043  0.000051  0.000051  0.000052  0.000057  0.000039   \nLOW     0.000077  0.000066  0.000082  0.000096  0.000094  0.000133  0.000061   \nMCD     0.000047  0.000043  0.000050  0.000050  0.000052  0.000060  0.000038   \nMMM     0.000082  0.000069  0.000089  0.000094  0.000101  0.000127  0.000060   \nMRK     0.000052  0.000074  0.000066  0.000072  0.000067  0.000090  0.000062   \nMS      0.000119  0.000105  0.000142  0.000178  0.000156  0.000338  0.000090   \nMSFT    0.000106  0.000076  0.000086  0.000097  0.000096  0.000125  0.000060   \nNEM     0.000043  0.000022  0.000046  0.000035  0.000035  0.000029  0.000029   \nNKE     0.000082  0.000066  0.000082  0.000093  0.000094  0.000114  0.000057   \nNUE     0.000097  0.000077  0.000119  0.000118  0.000124  0.000188  0.000070   \nORCL    0.000095  0.000073  0.000094  0.000100  0.000101  0.000140  0.000064   \nOXY     0.000088  0.000069  0.000103  0.000097  0.000108  0.000159  0.000062   \nPEP     0.000038  0.000041  0.000046  0.000046  0.000048  0.000049  0.000040   \nPFE     0.000059  0.000069  0.000065  0.000074  0.000068  0.000096  0.000077   \nPG      0.000039  0.000041  0.000044  0.000047  0.000047  0.000050  0.000041   \nPPG     0.000085  0.000078  0.000115  0.000106  0.000110  0.000149  0.000067   \nPSA     0.000051  0.000045  0.000062  0.000068  0.000069  0.000089  0.000044   \nSBUX    0.000087  0.000063  0.000087  0.000093  0.000090  0.000116  0.000058   \nSLB     0.000102  0.000068  0.000111  0.000109  0.000116  0.000177  0.000061   \nSPG     0.000066  0.000053  0.000070  0.000084  0.000081  0.000114  0.000050   \nT       0.000046  0.000044  0.000051  0.000057  0.000056  0.000075  0.000041   \nTJX     0.000067  0.000060  0.000064  0.000075  0.000078  0.000099  0.000049   \nVZ      0.000037  0.000044  0.000048  0.000052  0.000049  0.000063  0.000038   \nWFC     0.000090  0.000077  0.000103  0.000137  0.000122  0.000234  0.000069   \nWMT     0.000040  0.000044  0.000041  0.000047  0.000049  0.000057  0.000039   \nXOM     0.000067  0.000059  0.000080  0.000078  0.000086  0.000116  0.000053   \nYUM     0.000075  0.000060  0.000079  0.000084  0.000086  0.000109  0.000055   \n\nTicker         C       CAT        CL  ...      SBUX       SLB       SPG  \\\nTicker                                ...                                 \nAAPL    0.000118  0.000120  0.000042  ...  0.000087  0.000102  0.000066   \nABT     0.000099  0.000078  0.000047  ...  0.000063  0.000068  0.000053   \nAPD     0.000135  0.000127  0.000056  ...  0.000087  0.000111  0.000070   \nAXP     0.000171  0.000130  0.000053  ...  0.000093  0.000109  0.000084   \nBA      0.000153  0.000144  0.000058  ...  0.000090  0.000116  0.000081   \nBAC     0.000332  0.000189  0.000051  ...  0.000116  0.000177  0.000114   \nBMY     0.000088  0.000068  0.000045  ...  0.000058  0.000061  0.000050   \nC       0.000381  0.000192  0.000059  ...  0.000117  0.000181  0.000114   \nCAT     0.000192  0.000293  0.000052  ...  0.000095  0.000179  0.000092   \nCL      0.000059  0.000052  0.000105  ...  0.000058  0.000050  0.000053   \nCMCSA   0.000125  0.000109  0.000052  ...  0.000080  0.000096  0.000077   \nCOP     0.000153  0.000162  0.000047  ...  0.000072  0.000199  0.000073   \nCSCO    0.000141  0.000126  0.000054  ...  0.000089  0.000112  0.000076   \nCVX     0.000135  0.000135  0.000049  ...  0.000069  0.000158  0.000074   \nDE      0.000159  0.000190  0.000050  ...  0.000083  0.000140  0.000081   \nECL     0.000112  0.000103  0.000052  ...  0.000077  0.000096  0.000061   \nFCX     0.000260  0.000310  0.000063  ...  0.000110  0.000279  0.000120   \nFDX     0.000173  0.000158  0.000053  ...  0.000095  0.000135  0.000088   \nGE      0.000165  0.000138  0.000050  ...  0.000083  0.000135  0.000082   \nGIS     0.000047  0.000040  0.000051  ...  0.000042  0.000042  0.000046   \nGS      0.000243  0.000154  0.000047  ...  0.000089  0.000142  0.000086   \nHD      0.000116  0.000097  0.000050  ...  0.000087  0.000082  0.000075   \nHON     0.000154  0.000149  0.000058  ...  0.000094  0.000126  0.000084   \nINTC    0.000134  0.000128  0.000046  ...  0.000077  0.000106  0.000072   \nJNJ     0.000074  0.000061  0.000045  ...  0.000051  0.000059  0.000047   \nJPM     0.000257  0.000155  0.000052  ...  0.000094  0.000148  0.000093   \nKMB     0.000049  0.000046  0.000069  ...  0.000047  0.000038  0.000050   \nKO      0.000061  0.000054  0.000052  ...  0.000049  0.000051  0.000050   \nLOW     0.000131  0.000111  0.000051  ...  0.000093  0.000098  0.000081   \nMCD     0.000064  0.000055  0.000042  ...  0.000068  0.000048  0.000046   \nMMM     0.000128  0.000130  0.000052  ...  0.000073  0.000113  0.000073   \nMRK     0.000092  0.000074  0.000046  ...  0.000060  0.000067  0.000058   \nMS      0.000328  0.000198  0.000063  ...  0.000120  0.000192  0.000114   \nMSFT    0.000129  0.000116  0.000050  ...  0.000091  0.000091  0.000066   \nNEM     0.000037  0.000075  0.000027  ...  0.000025  0.000086  0.000044   \nNKE     0.000120  0.000103  0.000051  ...  0.000099  0.000092  0.000075   \nNUE     0.000188  0.000179  0.000052  ...  0.000093  0.000163  0.000091   \nORCL    0.000146  0.000125  0.000053  ...  0.000090  0.000117  0.000076   \nOXY     0.000164  0.000161  0.000049  ...  0.000082  0.000202  0.000087   \nPEP     0.000055  0.000046  0.000053  ...  0.000046  0.000044  0.000046   \nPFE     0.000099  0.000079  0.000041  ...  0.000061  0.000075  0.000061   \nPG      0.000056  0.000047  0.000063  ...  0.000047  0.000044  0.000046   \nPPG     0.000153  0.000143  0.000059  ...  0.000088  0.000121  0.000084   \nPSA     0.000090  0.000073  0.000050  ...  0.000068  0.000068  0.000111   \nSBUX    0.000117  0.000095  0.000058  ...  0.000221  0.000088  0.000079   \nSLB     0.000181  0.000179  0.000050  ...  0.000088  0.000309  0.000091   \nSPG     0.000114  0.000092  0.000053  ...  0.000079  0.000091  0.000174   \nT       0.000080  0.000069  0.000043  ...  0.000047  0.000066  0.000052   \nTJX     0.000101  0.000082  0.000046  ...  0.000079  0.000071  0.000070   \nVZ      0.000067  0.000056  0.000044  ...  0.000047  0.000053  0.000055   \nWFC     0.000221  0.000139  0.000051  ...  0.000097  0.000136  0.000094   \nWMT     0.000060  0.000049  0.000042  ...  0.000049  0.000041  0.000048   \nXOM     0.000121  0.000118  0.000047  ...  0.000061  0.000137  0.000066   \nYUM     0.000114  0.000098  0.000050  ...  0.000102  0.000078  0.000069   \n\nTicker         T       TJX        VZ       WFC       WMT       XOM       YUM  \nTicker                                                                        \nAAPL    0.000046  0.000067  0.000037  0.000090  0.000040  0.000067  0.000075  \nABT     0.000044  0.000060  0.000044  0.000077  0.000044  0.000059  0.000060  \nAPD     0.000051  0.000064  0.000048  0.000103  0.000041  0.000080  0.000079  \nAXP     0.000057  0.000075  0.000052  0.000137  0.000047  0.000078  0.000084  \nBA      0.000056  0.000078  0.000049  0.000122  0.000049  0.000086  0.000086  \nBAC     0.000075  0.000099  0.000063  0.000234  0.000057  0.000116  0.000109  \nBMY     0.000041  0.000049  0.000038  0.000069  0.000039  0.000053  0.000055  \nC       0.000080  0.000101  0.000067  0.000221  0.000060  0.000121  0.000114  \nCAT     0.000069  0.000082  0.000056  0.000139  0.000049  0.000118  0.000098  \nCL      0.000043  0.000046  0.000044  0.000051  0.000042  0.000047  0.000050  \nCMCSA   0.000064  0.000069  0.000058  0.000104  0.000048  0.000076  0.000072  \nCOP     0.000056  0.000063  0.000050  0.000117  0.000040  0.000139  0.000076  \nCSCO    0.000057  0.000074  0.000048  0.000110  0.000051  0.000082  0.000078  \nCVX     0.000058  0.000060  0.000054  0.000106  0.000041  0.000124  0.000066  \nDE      0.000061  0.000072  0.000052  0.000121  0.000043  0.000091  0.000082  \nECL     0.000046  0.000063  0.000044  0.000088  0.000039  0.000071  0.000072  \nFCX     0.000089  0.000105  0.000075  0.000187  0.000061  0.000176  0.000119  \nFDX     0.000062  0.000085  0.000052  0.000132  0.000053  0.000091  0.000091  \nGE      0.000066  0.000074  0.000058  0.000125  0.000044  0.000092  0.000074  \nGIS     0.000039  0.000038  0.000040  0.000044  0.000037  0.000038  0.000039  \nGS      0.000064  0.000078  0.000052  0.000172  0.000047  0.000097  0.000086  \nHD      0.000050  0.000086  0.000046  0.000094  0.000053  0.000064  0.000075  \nHON     0.000059  0.000078  0.000053  0.000122  0.000050  0.000087  0.000086  \nINTC    0.000054  0.000072  0.000048  0.000101  0.000045  0.000082  0.000077  \nJNJ     0.000041  0.000042  0.000043  0.000063  0.000037  0.000053  0.000048  \nJPM     0.000068  0.000083  0.000060  0.000189  0.000051  0.000103  0.000092  \nKMB     0.000043  0.000039  0.000048  0.000045  0.000041  0.000042  0.000046  \nKO      0.000040  0.000038  0.000043  0.000054  0.000037  0.000046  0.000046  \nLOW     0.000052  0.000092  0.000047  0.000106  0.000055  0.000073  0.000079  \nMCD     0.000033  0.000046  0.000035  0.000053  0.000035  0.000042  0.000067  \nMMM     0.000053  0.000063  0.000050  0.000102  0.000045  0.000080  0.000070  \nMRK     0.000049  0.000050  0.000050  0.000074  0.000042  0.000061  0.000058  \nMS      0.000082  0.000102  0.000069  0.000227  0.000062  0.000125  0.000108  \nMSFT    0.000051  0.000066  0.000049  0.000099  0.000048  0.000074  0.000086  \nNEM     0.000031  0.000011  0.000027  0.000022  0.000015  0.000057  0.000026  \nNKE     0.000048  0.000089  0.000044  0.000096  0.000049  0.000065  0.000083  \nNUE     0.000068  0.000080  0.000060  0.000139  0.000054  0.000111  0.000087  \nORCL    0.000056  0.000071  0.000048  0.000106  0.000046  0.000083  0.000079  \nOXY     0.000060  0.000068  0.000052  0.000123  0.000039  0.000132  0.000078  \nPEP     0.000037  0.000038  0.000042  0.000047  0.000038  0.000042  0.000042  \nPFE     0.000047  0.000051  0.000046  0.000081  0.000041  0.000063  0.000055  \nPG      0.000039  0.000036  0.000042  0.000047  0.000040  0.000044  0.000041  \nPPG     0.000057  0.000079  0.000055  0.000118  0.000046  0.000086  0.000086  \nPSA     0.000042  0.000056  0.000046  0.000076  0.000040  0.000050  0.000065  \nSBUX    0.000047  0.000079  0.000047  0.000097  0.000049  0.000061  0.000102  \nSLB     0.000066  0.000071  0.000053  0.000136  0.000041  0.000137  0.000078  \nSPG     0.000052  0.000070  0.000055  0.000094  0.000048  0.000066  0.000069  \nT       0.000111  0.000045  0.000073  0.000066  0.000039  0.000056  0.000044  \nTJX     0.000045  0.000172  0.000043  0.000082  0.000050  0.000056  0.000070  \nVZ      0.000073  0.000043  0.000111  0.000059  0.000040  0.000048  0.000043  \nWFC     0.000066  0.000082  0.000059  0.000229  0.000050  0.000097  0.000088  \nWMT     0.000039  0.000050  0.000040  0.000050  0.000118  0.000039  0.000041  \nXOM     0.000056  0.000056  0.000048  0.000097  0.000039  0.000136  0.000061  \nYUM     0.000044  0.000070  0.000043  0.000088  0.000041  0.000061  0.000198  \n\n[54 rows x 54 columns]\n\n\n\n\n\nCreate a function to generate random portfolio weights and use it to create the efficient frontier visualization. Generate 1000 random portfolios and plot them on a risk-return graph.\nHint: - Use np.random.random() to generate weights - Normalize weights to sum to 1 - Store results in arrays for plotting - Highlight the minimum variance and maximum Sharpe ratio portfolios\n\ndef generate_random_weights(n_assets):\n    \"\"\"Generate random weights that sum to 1\"\"\"\n    weights = np.random.random(n_assets)\n    return weights / np.sum(weights)\n\n# Generate random portfolios\nn_portfolios = 100000\nresults = np.zeros((n_portfolios, 3))  # To store return, volatility, Sharpe ratio\n\nfor i in range(n_portfolios):\n    weights = generate_random_weights(n_assets)\n    ret, vol = portfolio_metrics(weights, train_mean_returns, train_cov_matrix)\n    sharpe = ret / vol\n    results[i] = [ret, vol, sharpe]\n\n# Plot results\nplt.figure(figsize=(10, 6))\nplt.scatter(results[:, 1], results[:, 0], \n           c=results[:, 2], cmap='viridis', \n           marker='o', s=10, alpha=0.3)\n\nplt.colorbar(label='Sharpe ratio')\nplt.xlabel('Volatility')\nplt.ylabel('Expected Return')\nplt.title('Efficient Frontier of Random Portfolios')\n\n# Plot equal weight portfolio\nequal_ret, equal_vol = portfolio_metrics(weights_equal, \n                                       train_mean_returns, \n                                       train_cov_matrix)\nplt.scatter(equal_vol, equal_ret, \n           color='red', marker='*', s=200, \n           label='Equal Weight Portfolio')\n\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nUse scipy’s optimize function to find the minimum variance portfolio and the maximum Sharpe ratio portfolio. Make sure to include the constraint that weights must sum to 1 and be non-negative.\nHint: - Use scipy.optimize.minimize - Define objective functions for minimum variance and maximum Sharpe ratio - Use SLSQP optimizer - Check the optimization success flag\n\ndef objective_variance(weights):\n    return portfolio_metrics(weights, train_mean_returns, train_cov_matrix)[1]\n\ndef objective_sharpe(weights):\n    ret, vol = portfolio_metrics(weights, train_mean_returns, train_cov_matrix)\n    return -ret/vol  # Negative because we minimize\n\n# Constraints\nconstraints = (\n    {'type': 'eq', 'fun': lambda x: np.sum(x) - 1}  # weights sum to 1\n)\nbounds = tuple((0, 1) for _ in range(n_assets))  # weights between 0 and 1\n\n# Find minimum variance portfolio\nmin_var_result = minimize(objective_variance, weights_equal,\n                         method='SLSQP',\n                         bounds=bounds,\n                         constraints=constraints)\n\nif not min_var_result.success:\n    print(\"Warning: Minimum variance optimization did not converge!\")\n\n# Find maximum Sharpe ratio portfolio\nmax_sharpe_result = minimize(objective_sharpe, weights_equal,\n                           method='SLSQP',\n                           bounds=bounds,\n                           constraints=constraints)\n\nif not max_sharpe_result.success:\n    print(\"Warning: Maximum Sharpe optimization did not converge!\")\n\n# Print results\nprint(\"\\nMinimum Variance Portfolio:\")\nfor ticker, weight in zip(tickers, min_var_result.x):\n    print(f\"{ticker}: {weight:.4f}\")\nret, vol = portfolio_metrics(min_var_result.x, train_mean_returns, train_cov_matrix)\nprint(f\"Expected Return: {ret:.4%}\")\nprint(f\"Volatility: {vol:.4%}\")\n\nprint(\"\\nMaximum Sharpe Ratio Portfolio:\")\nfor ticker, weight in zip(tickers, max_sharpe_result.x):\n    print(f\"{ticker}: {weight:.4f}\")\nret, vol = portfolio_metrics(max_sharpe_result.x, train_mean_returns, train_cov_matrix)\nprint(f\"Expected Return: {ret:.4%}\")\nprint(f\"Volatility: {vol:.4%}\")\n\n\nMinimum Variance Portfolio:\nAAPL: 0.0134\nMSFT: 0.0049\nINTC: 0.0000\nCSCO: 0.0000\nORCL: 0.0000\nJPM: 0.0000\nBAC: 0.0103\nGS: 0.0000\nMS: 0.0000\nC: 0.0000\nAXP: 0.0000\nWFC: 0.0000\nJNJ: 0.0000\nPFE: 0.0000\nMRK: 0.0000\nABT: 0.0000\nBMY: 0.0000\nXOM: 0.0000\nCVX: 0.0000\nCOP: 0.0846\nSLB: 0.0000\nOXY: 0.0000\nWMT: 0.0000\nPG: 0.0000\nKO: 0.0952\nPEP: 0.0000\nCL: 0.0342\nKMB: 0.0841\nGIS: 0.0000\nHD: 0.1474\nMCD: 0.0000\nNKE: 0.0015\nSBUX: 0.0000\nTJX: 0.0000\nLOW: 0.0445\nYUM: 0.0000\nCAT: 0.0000\nBA: 0.0000\nMMM: 0.0000\nHON: 0.1014\nGE: 0.0133\nDE: 0.0877\nFDX: 0.0000\nAPD: 0.0061\nECL: 0.0000\nNEM: 0.0000\nFCX: 0.0000\nPPG: 0.0696\nNUE: 0.0297\nVZ: 0.0575\nT: 0.0000\nCMCSA: 0.1146\nSPG: 0.0000\nPSA: 0.0000\nExpected Return: 0.0499%\nVolatility: 0.6731%\n\nMaximum Sharpe Ratio Portfolio:\nAAPL: 0.1639\nMSFT: 0.0000\nINTC: 0.0000\nCSCO: 0.0000\nORCL: 0.0310\nJPM: 0.0000\nBAC: 0.0101\nGS: 0.0000\nMS: 0.0000\nC: 0.0000\nAXP: 0.0556\nWFC: 0.0000\nJNJ: 0.0000\nPFE: 0.0000\nMRK: 0.0000\nABT: 0.0000\nBMY: 0.0000\nXOM: 0.0000\nCVX: 0.0000\nCOP: 0.0000\nSLB: 0.0000\nOXY: 0.2121\nWMT: 0.0000\nPG: 0.0000\nKO: 0.0000\nPEP: 0.0000\nCL: 0.0647\nKMB: 0.0000\nGIS: 0.0000\nHD: 0.1537\nMCD: 0.0000\nNKE: 0.0000\nSBUX: 0.0000\nTJX: 0.0015\nLOW: 0.0009\nYUM: 0.0187\nCAT: 0.0000\nBA: 0.0000\nMMM: 0.0000\nHON: 0.0285\nGE: 0.0000\nDE: 0.0000\nFDX: 0.0000\nAPD: 0.0000\nECL: 0.0780\nNEM: 0.0000\nFCX: 0.0000\nPPG: 0.0000\nNUE: 0.1387\nVZ: 0.0425\nT: 0.0000\nCMCSA: 0.0000\nSPG: 0.0000\nPSA: 0.0000\nExpected Return: 0.0850%\nVolatility: 0.8703%\n\n\n\n\n\nBacktest your optimized portfolios (minimum variance and maximum Sharpe ratio) on the test period. Compare their performance with the equally-weighted portfolio.\nHint: - Use the weights found in the training period - Calculate cumulative returns for each portfolio - Plot the evolution of portfolio values - Calculate key performance metrics (return, volatility, Sharpe ratio, maximum drawdown)\n\ndef calculate_portfolio_value(weights, returns):\n    \"\"\"Calculate portfolio value evolution starting at 100\"\"\"\n    portfolio_returns = returns @ weights\n    return 100 * (1 + portfolio_returns).cumprod()\n\n\n# Calculate performance metrics for test period\ndef calculate_metrics(returns):\n    mean_ret = returns.mean()\n    vol = returns.std()\n    sharpe = mean_ret / vol\n    cum_ret = (1 + returns).prod() - 1\n    return {'Mean Return': mean_ret,\n            'Volatility': vol,\n            'Sharpe Ratio': sharpe,\n            'Cumulative Return': cum_ret}\n\n# Calculate portfolio values for each strategy\ntrain_equal = calculate_portfolio_value(weights_equal, train_returns)\ntrain_min_var = calculate_portfolio_value(min_var_result.x, train_returns)\ntrain_max_sharpe = calculate_portfolio_value(max_sharpe_result.x, train_returns)\n\n# Plot results\nplt.figure(figsize=(12, 6))\nplt.plot(train_equal.index, train_equal, label='Equal Weight')\nplt.plot(train_min_var.index, train_min_var, label='Min Variance')\nplt.plot(train_max_sharpe.index, train_max_sharpe, label='Max Sharpe')\n\nplt.title('Portfolio Value Evolution - Train Period')\nplt.xlabel('Date')\nplt.ylabel('Portfolio Value')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n# Calculate and display metrics for each portfolio\nportfolios = {\n    'Equal Weight': weights_equal,\n    'Min Variance': min_var_result.x,\n    'Max Sharpe': max_sharpe_result.x\n}\n\nprint(\"\\nTrain Period Performance:\")\nfor name, weights in portfolios.items():\n    portfolio_returns = train_returns @ weights\n    metrics = calculate_metrics(portfolio_returns)\n    print(f\"\\n{name}:\")\n    for metric, value in metrics.items():\n        print(f\"{metric}: {value:.4%}\")\n\n\n# Calculate portfolio values for each strategy\ntest_equal = calculate_portfolio_value(weights_equal, test_returns)\ntest_min_var = calculate_portfolio_value(min_var_result.x, test_returns)\ntest_max_sharpe = calculate_portfolio_value(max_sharpe_result.x, test_returns)\n\n# Plot results\nplt.figure(figsize=(12, 6))\nplt.plot(test_equal.index, test_equal, label='Equal Weight')\nplt.plot(test_min_var.index, test_min_var, label='Min Variance')\nplt.plot(test_max_sharpe.index, test_max_sharpe, label='Max Sharpe')\n\nplt.title('Portfolio Value Evolution - Test Period')\nplt.xlabel('Date')\nplt.ylabel('Portfolio Value')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n# Calculate and display metrics for each portfolio\nportfolios = {\n    'Equal Weight': weights_equal,\n    'Min Variance': min_var_result.x,\n    'Max Sharpe': max_sharpe_result.x\n}\n\nprint(\"\\nTest Period Performance:\")\nfor name, weights in portfolios.items():\n    portfolio_returns = test_returns @ weights\n    metrics = calculate_metrics(portfolio_returns)\n    print(f\"\\n{name}:\")\n    for metric, value in metrics.items():\n        print(f\"{metric}: {value:.4%}\")\n\n\n\n\n\n\n\n\n\nTrain Period Performance:\n\nEqual Weight:\nMean Return: 0.0553%\nVolatility: 0.9158%\nSharpe Ratio: 6.0422%\nCumulative Return: 261.7286%\n\nMin Variance:\nMean Return: 0.0499%\nVolatility: 0.6731%\nSharpe Ratio: 7.4197%\nCumulative Return: 231.6049%\n\nMax Sharpe:\nMean Return: 0.0850%\nVolatility: 0.8703%\nSharpe Ratio: 9.7722%\nCumulative Return: 671.2589%\n\nTest Period Performance:\n\nEqual Weight:\nMean Return: 0.0563%\nVolatility: 1.3392%\nSharpe Ratio: 4.2020%\nCumulative Return: 81.2116%\n\nMin Variance:\nMean Return: 0.0390%\nVolatility: 1.0081%\nSharpe Ratio: 3.8640%\nCumulative Return: 53.1191%\n\nMax Sharpe:\nMean Return: 0.0595%\nVolatility: 1.3445%\nSharpe Ratio: 4.4278%\nCumulative Return: 88.5475%"
  },
  {
    "objectID": "content/Cours_4/portfolio_tp_corrected.html#l3-finance",
    "href": "content/Cours_4/portfolio_tp_corrected.html#l3-finance",
    "title": "Modern Portfolio Theory - Practical Work - Corrected version",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport yfinance as yf\nfrom scipy.optimize import minimize\nimport seaborn as sns\n\n\n\n\n\nWe will work with a diversified portfolio of major stocks covering different sectors of the economy. Using the yfinance library, retrieve daily closing prices for the following stocks from January 1st, 2015 to January 1st, 2025:\nHint: Use yf.download() function with parameters: - tickers: list or string of tickers - start: start date - end: end date - interval: ‘d’ for daily data - Use the ‘Close’ column\n\n# Define the tickers\ntickers = [\n    # Technology\n    'AAPL', 'MSFT', 'INTC', 'CSCO', 'ORCL',\n    # Financial Services\n    'JPM', 'BAC', 'GS', 'MS', 'C', 'AXP', 'WFC',\n    # Healthcare\n    'JNJ', 'PFE', 'MRK', 'ABT', 'BMY',\n    # Energy\n    'XOM', 'CVX', 'COP', 'SLB', 'OXY',\n    # Consumer Staples\n    'WMT', 'PG', 'KO', 'PEP', 'CL', 'KMB', 'GIS',\n    # Consumer Discretionary\n    'HD', 'MCD', 'NKE', 'SBUX', 'TJX', 'LOW', 'YUM',\n    # Industrial\n    'CAT', 'BA', 'MMM', 'HON', 'GE', 'DE', 'FDX',\n    # Materials\n    'APD', 'ECL', 'NEM', 'FCX', 'PPG', 'NUE',\n    # Telecommunications\n    'VZ', 'T', 'CMCSA',\n    # Real Estate\n    'SPG', 'PSA'\n]\n\n\n# Download the data\nstart_date = '2010-01-01'\nend_date = '2025-01-01'\n\nprices = yf.download(tickers, \n                    start=start_date,\n                    end=end_date,\n                    interval='1d')['Close']\n\n# Check the first few rows of the data\nprint(\"First few rows of the price data:\")\nprint(prices.head())\n\n[*********************100%***********************]  54 of 54 completed\n\n\nFirst few rows of the price data:\nTicker          AAPL        ABT        APD        AXP         BA        BAC  \\\nDate                                                                          \n2010-01-04  6.447412  18.665758  52.804508  32.828983  43.777561  12.451034   \n2010-01-05  6.458560  18.514959  52.366360  32.756783  45.211349  12.855753   \n2010-01-06  6.355827  18.617779  51.934586  33.286285  46.582794  13.006530   \n2010-01-07  6.344077  18.772020  51.636158  33.826145  48.468563  13.435059   \n2010-01-08  6.386254  18.867979  51.966351  33.801979  48.001026  13.316021   \n\nTicker            BMY          C        CAT         CL  ...      SBUX  \\\nDate                                                    ...             \n2010-01-04  15.436789  25.928009  39.738235  28.930437  ...  8.835545   \n2010-01-05  15.195873  26.919380  40.213326  29.164408  ...  9.042539   \n2010-01-06  15.189850  27.758226  40.335484  29.098055  ...  8.977375   \n2010-01-07  15.201899  27.834469  40.498383  28.982828  ...  8.954374   \n2010-01-08  14.948930  27.376934  40.953117  28.462532  ...  8.923708   \n\nTicker            SLB        SPG         T       TJX         VZ        WFC  \\\nDate                                                                         \n2010-01-04  47.246723  39.174126  7.038978  7.384900  14.442019  18.417709   \n2010-01-05  47.380508  38.906082  7.004502  7.583662  14.468057  18.923317   \n2010-01-06  48.436508  38.469257  6.935692  7.614400  14.052043  18.950285   \n2010-01-07  48.936378  38.970608  6.857815  8.003725  13.968397  19.637922   \n2010-01-08  49.738956  38.037426  6.807579  7.899220  13.977206  19.455894   \n\nTicker            WMT        XOM        YUM  \nDate                                         \n2010-01-04  13.084426  39.272114  18.878279  \n2010-01-05  12.954136  39.425453  18.813725  \n2010-01-06  12.925184  39.766212  18.679226  \n2010-01-07  12.932426  39.641270  18.673841  \n2010-01-08  12.867274  39.482235  18.679226  \n\n[5 rows x 54 columns]\n\n\n\n\n\nCalculate the daily returns for each asset. The daily return is defined as the percentage change in price from one day to the next.\nHint: - Use the pct_change() method from pandas - Be sure to handle any missing values that might appear\n\n# Calculate daily returns\nreturns = prices.pct_change()\n\n# Drop any missing values\nreturns = returns.dropna()\n\n# Display summary statistics of the returns\nprint(\"\\nSummary statistics of daily returns:\")\nprint(returns.describe())\n\n\nSummary statistics of daily returns:\nTicker         AAPL          ABT          APD          AXP           BA  \\\ncount   3773.000000  3773.000000  3773.000000  3773.000000  3773.000000   \nmean       0.001124     0.000568     0.000567     0.000748     0.000625   \nstd        0.017552     0.013505     0.015242     0.018248     0.022538   \nmin       -0.128647    -0.097857    -0.155518    -0.148187    -0.238484   \n25%       -0.007398    -0.006053    -0.006462    -0.007042    -0.009198   \n50%        0.001001     0.000596     0.000751     0.000768     0.000676   \n75%        0.010355     0.007639     0.008000     0.009271     0.010452   \nmax        0.119808     0.109360     0.137233     0.218822     0.243186   \n\nTicker          BAC          BMY            C          CAT           CL  ...  \\\ncount   3773.000000  3773.000000  3773.000000  3773.000000  3773.000000  ...   \nmean       0.000559     0.000449     0.000494     0.000753     0.000365  ...   \nstd        0.021172     0.014655     0.021367     0.018295     0.011262  ...   \nmin       -0.203182    -0.159851    -0.192986    -0.142822    -0.097829  ...   \n25%       -0.009895    -0.006971    -0.009486    -0.008498    -0.005121  ...   \n50%        0.000349     0.000622     0.000294     0.000584     0.000369  ...   \n75%        0.010749     0.007588     0.010222     0.010267     0.006184  ...   \nmax        0.177962     0.114425     0.179843     0.103321     0.126082  ...   \n\nTicker         SBUX          SLB          SPG            T          TJX  \\\ncount   3773.000000  3773.000000  3773.000000  3773.000000  3773.000000   \nmean       0.000768     0.000208     0.000605     0.000392     0.000864   \nstd        0.017326     0.022881     0.020546     0.012944     0.015659   \nmin       -0.162042    -0.274214    -0.267127    -0.104061    -0.203995   \n25%       -0.007363    -0.010883    -0.007593    -0.005913    -0.006955   \n50%        0.000654    -0.000108     0.000992     0.000725     0.000714   \n75%        0.008734     0.010998     0.009068     0.006838     0.008502   \nmax        0.244970     0.199080     0.278694     0.100223     0.129033   \n\nTicker           VZ          WFC          WMT          XOM          YUM  \ncount   3773.000000  3773.000000  3773.000000  3773.000000  3773.000000  \nmean       0.000333     0.000532     0.000585     0.000391     0.000631  \nstd        0.011605     0.018845     0.012085     0.015723     0.014886  \nmin       -0.074978    -0.158676    -0.113757    -0.122248    -0.188324  \n25%       -0.005823    -0.008342    -0.005145    -0.007267    -0.006211  \n50%        0.000496     0.000341     0.000679     0.000133     0.000812  \n75%        0.006458     0.009181     0.006373     0.007995     0.007590  \nmax        0.092705     0.145346     0.117085     0.126868     0.232485  \n\n[8 rows x 54 columns]\n\n\n\n\n\nCreate a visualization of the correlation between the assets using a heatmap. Also, compute and display the covariance matrix.\nHint: - Use seaborn.heatmap() for visualization - Use returns.corr() for correlation matrix - Use returns.cov() for covariance matrix\n\n# Compute correlation matrix\ncorrelation_matrix = returns.corr()\n\n# Create a heatmap\nplt.figure(figsize=(10, 8))\nsns.heatmap(correlation_matrix, \n            annot=False,\n            cmap='coolwarm', \n            vmin=-1, \n            vmax=1,\n            center=0)\nplt.title('Correlation Matrix of Asset Returns')\nplt.show()\n\n# Compute and display covariance matrix\ncovariance_matrix = returns.cov()\nprint(\"\\nCovariance Matrix:\")\nprint(covariance_matrix)\n\n\n\n\n\n\n\n\n\nCovariance Matrix:\nTicker      AAPL       ABT       APD       AXP        BA       BAC       BMY  \\\nTicker                                                                         \nAAPL    0.000308  0.000095  0.000105  0.000131  0.000152  0.000141  0.000065   \nABT     0.000095  0.000182  0.000097  0.000101  0.000103  0.000111  0.000079   \nAPD     0.000105  0.000097  0.000232  0.000135  0.000143  0.000158  0.000073   \nAXP     0.000131  0.000101  0.000135  0.000333  0.000237  0.000260  0.000081   \nBA      0.000152  0.000103  0.000143  0.000237  0.000508  0.000236  0.000082   \nBAC     0.000141  0.000111  0.000158  0.000260  0.000236  0.000448  0.000091   \nBMY     0.000065  0.000079  0.000073  0.000081  0.000082  0.000091  0.000215   \nC       0.000147  0.000114  0.000162  0.000265  0.000263  0.000383  0.000097   \nCAT     0.000128  0.000087  0.000147  0.000187  0.000200  0.000226  0.000074   \nCL      0.000059  0.000069  0.000075  0.000064  0.000070  0.000067  0.000055   \nCMCSA   0.000103  0.000081  0.000100  0.000136  0.000133  0.000153  0.000070   \nCOP     0.000111  0.000078  0.000134  0.000193  0.000209  0.000226  0.000081   \nCSCO    0.000132  0.000096  0.000110  0.000136  0.000139  0.000163  0.000073   \nCVX     0.000100  0.000080  0.000121  0.000171  0.000187  0.000194  0.000077   \nDE      0.000120  0.000085  0.000131  0.000168  0.000198  0.000198  0.000072   \nECL     0.000110  0.000097  0.000131  0.000150  0.000153  0.000159  0.000071   \nFCX     0.000186  0.000127  0.000210  0.000263  0.000292  0.000306  0.000103   \nFDX     0.000127  0.000096  0.000130  0.000163  0.000193  0.000199  0.000071   \nGE      0.000118  0.000087  0.000128  0.000196  0.000234  0.000221  0.000074   \nGIS     0.000043  0.000053  0.000058  0.000041  0.000035  0.000051  0.000046   \nGS      0.000131  0.000099  0.000136  0.000217  0.000207  0.000297  0.000081   \nHD      0.000118  0.000091  0.000107  0.000134  0.000144  0.000147  0.000070   \nHON     0.000116  0.000094  0.000130  0.000170  0.000195  0.000188  0.000078   \nINTC    0.000161  0.000108  0.000125  0.000155  0.000181  0.000171  0.000069   \nJNJ     0.000061  0.000078  0.000072  0.000075  0.000076  0.000084  0.000071   \nJPM     0.000119  0.000100  0.000139  0.000225  0.000209  0.000316  0.000083   \nKMB     0.000050  0.000062  0.000066  0.000056  0.000055  0.000058  0.000053   \nKO      0.000064  0.000065  0.000077  0.000090  0.000098  0.000088  0.000053   \nLOW     0.000122  0.000096  0.000113  0.000146  0.000159  0.000165  0.000072   \nMCD     0.000078  0.000066  0.000077  0.000098  0.000110  0.000096  0.000052   \nMMM     0.000099  0.000085  0.000112  0.000135  0.000138  0.000157  0.000071   \nMRK     0.000064  0.000084  0.000078  0.000081  0.000077  0.000096  0.000076   \nMS      0.000151  0.000124  0.000168  0.000256  0.000237  0.000365  0.000100   \nMSFT    0.000166  0.000105  0.000112  0.000136  0.000139  0.000144  0.000066   \nNEM     0.000056  0.000040  0.000070  0.000048  0.000056  0.000044  0.000036   \nNKE     0.000127  0.000093  0.000109  0.000145  0.000164  0.000148  0.000066   \nNUE     0.000125  0.000090  0.000155  0.000192  0.000200  0.000240  0.000079   \nORCL    0.000128  0.000090  0.000115  0.000135  0.000132  0.000158  0.000066   \nOXY     0.000125  0.000083  0.000147  0.000224  0.000272  0.000269  0.000080   \nPEP     0.000071  0.000069  0.000075  0.000075  0.000079  0.000078  0.000055   \nPFE     0.000072  0.000084  0.000082  0.000090  0.000092  0.000106  0.000090   \nPG      0.000063  0.000068  0.000069  0.000066  0.000066  0.000071  0.000053   \nPPG     0.000113  0.000095  0.000143  0.000167  0.000177  0.000187  0.000076   \nPSA     0.000080  0.000070  0.000084  0.000093  0.000100  0.000104  0.000056   \nSBUX    0.000128  0.000091  0.000119  0.000156  0.000169  0.000161  0.000069   \nSLB     0.000120  0.000073  0.000145  0.000219  0.000237  0.000255  0.000077   \nSPG     0.000112  0.000070  0.000114  0.000218  0.000260  0.000215  0.000071   \nT       0.000064  0.000065  0.000076  0.000099  0.000101  0.000116  0.000055   \nTJX     0.000102  0.000081  0.000099  0.000147  0.000168  0.000153  0.000060   \nVZ      0.000049  0.000057  0.000064  0.000069  0.000066  0.000083  0.000047   \nWFC     0.000119  0.000097  0.000138  0.000237  0.000227  0.000315  0.000085   \nWMT     0.000061  0.000056  0.000058  0.000056  0.000056  0.000065  0.000043   \nXOM     0.000085  0.000065  0.000106  0.000149  0.000169  0.000174  0.000066   \nYUM     0.000098  0.000079  0.000100  0.000131  0.000144  0.000134  0.000061   \n\nTicker         C       CAT        CL  ...      SBUX       SLB       SPG  \\\nTicker                                ...                                 \nAAPL    0.000147  0.000128  0.000059  ...  0.000128  0.000120  0.000112   \nABT     0.000114  0.000087  0.000069  ...  0.000091  0.000073  0.000070   \nAPD     0.000162  0.000147  0.000075  ...  0.000119  0.000145  0.000114   \nAXP     0.000265  0.000187  0.000064  ...  0.000156  0.000219  0.000218   \nBA      0.000263  0.000200  0.000070  ...  0.000169  0.000237  0.000260   \nBAC     0.000383  0.000226  0.000067  ...  0.000161  0.000255  0.000215   \nBMY     0.000097  0.000074  0.000055  ...  0.000069  0.000077  0.000071   \nC       0.000457  0.000233  0.000072  ...  0.000169  0.000279  0.000238   \nCAT     0.000233  0.000335  0.000058  ...  0.000122  0.000248  0.000160   \nCL      0.000072  0.000058  0.000127  ...  0.000071  0.000055  0.000064   \nCMCSA   0.000160  0.000127  0.000066  ...  0.000113  0.000131  0.000129   \nCOP     0.000243  0.000216  0.000055  ...  0.000123  0.000366  0.000190   \nCSCO    0.000166  0.000139  0.000068  ...  0.000120  0.000141  0.000115   \nCVX     0.000210  0.000181  0.000058  ...  0.000111  0.000286  0.000170   \nDE      0.000204  0.000229  0.000061  ...  0.000119  0.000205  0.000155   \nECL     0.000164  0.000131  0.000072  ...  0.000127  0.000139  0.000141   \nFCX     0.000327  0.000345  0.000069  ...  0.000171  0.000379  0.000240   \nFDX     0.000213  0.000179  0.000065  ...  0.000134  0.000177  0.000157   \nGE      0.000237  0.000190  0.000061  ...  0.000131  0.000222  0.000192   \nGIS     0.000048  0.000038  0.000068  ...  0.000045  0.000036  0.000032   \nGS      0.000303  0.000194  0.000061  ...  0.000139  0.000217  0.000186   \nHD      0.000153  0.000120  0.000070  ...  0.000127  0.000111  0.000139   \nHON     0.000197  0.000172  0.000066  ...  0.000127  0.000175  0.000161   \nINTC    0.000185  0.000155  0.000062  ...  0.000123  0.000153  0.000134   \nJNJ     0.000086  0.000070  0.000060  ...  0.000063  0.000068  0.000060   \nJPM     0.000315  0.000192  0.000065  ...  0.000139  0.000221  0.000188   \nKMB     0.000059  0.000049  0.000086  ...  0.000057  0.000039  0.000054   \nKO      0.000094  0.000074  0.000071  ...  0.000075  0.000082  0.000095   \nLOW     0.000173  0.000135  0.000071  ...  0.000137  0.000133  0.000157   \nMCD     0.000107  0.000077  0.000059  ...  0.000106  0.000088  0.000104   \nMMM     0.000162  0.000154  0.000065  ...  0.000101  0.000142  0.000125   \nMRK     0.000098  0.000078  0.000059  ...  0.000068  0.000083  0.000068   \nMS      0.000367  0.000232  0.000074  ...  0.000167  0.000260  0.000204   \nMSFT    0.000152  0.000123  0.000067  ...  0.000129  0.000107  0.000105   \nNEM     0.000050  0.000078  0.000038  ...  0.000045  0.000099  0.000056   \nNKE     0.000160  0.000129  0.000065  ...  0.000153  0.000125  0.000138   \nNUE     0.000252  0.000230  0.000061  ...  0.000131  0.000243  0.000180   \nORCL    0.000163  0.000136  0.000068  ...  0.000117  0.000129  0.000104   \nOXY     0.000293  0.000244  0.000058  ...  0.000142  0.000429  0.000262   \nPEP     0.000081  0.000062  0.000079  ...  0.000077  0.000062  0.000075   \nPFE     0.000109  0.000086  0.000056  ...  0.000073  0.000084  0.000079   \nPG      0.000073  0.000056  0.000085  ...  0.000066  0.000050  0.000056   \nPPG     0.000199  0.000167  0.000068  ...  0.000129  0.000165  0.000160   \nPSA     0.000107  0.000084  0.000068  ...  0.000090  0.000076  0.000139   \nSBUX    0.000169  0.000122  0.000071  ...  0.000300  0.000134  0.000157   \nSLB     0.000279  0.000248  0.000055  ...  0.000134  0.000524  0.000229   \nSPG     0.000238  0.000160  0.000064  ...  0.000157  0.000229  0.000422   \nT       0.000122  0.000090  0.000059  ...  0.000072  0.000102  0.000099   \nTJX     0.000158  0.000120  0.000062  ...  0.000125  0.000128  0.000165   \nVZ      0.000083  0.000067  0.000056  ...  0.000059  0.000066  0.000071   \nWFC     0.000311  0.000191  0.000067  ...  0.000144  0.000229  0.000205   \nWMT     0.000063  0.000054  0.000057  ...  0.000060  0.000044  0.000051   \nXOM     0.000188  0.000166  0.000052  ...  0.000093  0.000268  0.000155   \nYUM     0.000144  0.000114  0.000058  ...  0.000141  0.000113  0.000129   \n\nTicker         T       TJX        VZ       WFC       WMT       XOM       YUM  \nTicker                                                                        \nAAPL    0.000064  0.000102  0.000049  0.000119  0.000061  0.000085  0.000098  \nABT     0.000065  0.000081  0.000057  0.000097  0.000056  0.000065  0.000079  \nAPD     0.000076  0.000099  0.000064  0.000138  0.000058  0.000106  0.000100  \nAXP     0.000099  0.000147  0.000069  0.000237  0.000056  0.000149  0.000131  \nBA      0.000101  0.000168  0.000066  0.000227  0.000056  0.000169  0.000144  \nBAC     0.000116  0.000153  0.000083  0.000315  0.000065  0.000174  0.000134  \nBMY     0.000055  0.000060  0.000047  0.000085  0.000043  0.000066  0.000061  \nC       0.000122  0.000158  0.000083  0.000311  0.000063  0.000188  0.000144  \nCAT     0.000090  0.000120  0.000067  0.000191  0.000054  0.000166  0.000114  \nCL      0.000059  0.000062  0.000056  0.000067  0.000057  0.000052  0.000058  \nCMCSA   0.000093  0.000100  0.000073  0.000139  0.000057  0.000098  0.000087  \nCOP     0.000092  0.000115  0.000065  0.000201  0.000046  0.000263  0.000111  \nCSCO    0.000079  0.000102  0.000061  0.000140  0.000067  0.000103  0.000095  \nCVX     0.000089  0.000108  0.000067  0.000174  0.000047  0.000221  0.000102  \nDE      0.000085  0.000118  0.000063  0.000173  0.000055  0.000138  0.000107  \nECL     0.000078  0.000115  0.000060  0.000142  0.000055  0.000102  0.000111  \nFCX     0.000119  0.000164  0.000083  0.000259  0.000068  0.000250  0.000165  \nFDX     0.000082  0.000122  0.000063  0.000173  0.000064  0.000120  0.000106  \nGE      0.000099  0.000133  0.000070  0.000203  0.000050  0.000153  0.000111  \nGIS     0.000052  0.000037  0.000050  0.000050  0.000051  0.000039  0.000040  \nGS      0.000097  0.000130  0.000067  0.000247  0.000056  0.000146  0.000117  \nHD      0.000072  0.000125  0.000060  0.000132  0.000070  0.000086  0.000104  \nHON     0.000085  0.000121  0.000063  0.000169  0.000055  0.000122  0.000113  \nINTC    0.000080  0.000112  0.000063  0.000153  0.000065  0.000111  0.000099  \nJNJ     0.000058  0.000058  0.000053  0.000078  0.000048  0.000062  0.000058  \nJPM     0.000102  0.000135  0.000074  0.000265  0.000058  0.000152  0.000119  \nKMB     0.000058  0.000048  0.000057  0.000055  0.000053  0.000043  0.000054  \nKO      0.000065  0.000070  0.000057  0.000087  0.000049  0.000071  0.000069  \nLOW     0.000075  0.000138  0.000060  0.000146  0.000068  0.000098  0.000112  \nMCD     0.000055  0.000083  0.000045  0.000092  0.000045  0.000068  0.000103  \nMMM     0.000076  0.000095  0.000060  0.000143  0.000052  0.000102  0.000090  \nMRK     0.000061  0.000062  0.000057  0.000084  0.000048  0.000070  0.000064  \nMS      0.000114  0.000152  0.000081  0.000293  0.000070  0.000174  0.000137  \nMSFT    0.000061  0.000101  0.000054  0.000124  0.000066  0.000083  0.000104  \nNEM     0.000047  0.000023  0.000040  0.000035  0.000029  0.000072  0.000049  \nNKE     0.000070  0.000130  0.000055  0.000136  0.000059  0.000094  0.000115  \nNUE     0.000096  0.000133  0.000077  0.000209  0.000065  0.000167  0.000115  \nORCL    0.000073  0.000099  0.000057  0.000135  0.000064  0.000090  0.000089  \nOXY     0.000111  0.000131  0.000070  0.000243  0.000044  0.000303  0.000118  \nPEP     0.000061  0.000066  0.000056  0.000076  0.000060  0.000061  0.000064  \nPFE     0.000065  0.000065  0.000058  0.000096  0.000049  0.000072  0.000063  \nPG      0.000059  0.000053  0.000056  0.000068  0.000058  0.000051  0.000054  \nPPG     0.000078  0.000122  0.000062  0.000168  0.000049  0.000113  0.000117  \nPSA     0.000061  0.000080  0.000057  0.000092  0.000051  0.000064  0.000080  \nSBUX    0.000072  0.000125  0.000059  0.000144  0.000060  0.000093  0.000141  \nSLB     0.000102  0.000128  0.000066  0.000229  0.000044  0.000268  0.000113  \nSPG     0.000099  0.000165  0.000071  0.000205  0.000051  0.000155  0.000129  \nT       0.000168  0.000074  0.000101  0.000110  0.000048  0.000085  0.000063  \nTJX     0.000074  0.000245  0.000056  0.000143  0.000061  0.000097  0.000109  \nVZ      0.000101  0.000056  0.000135  0.000078  0.000046  0.000063  0.000048  \nWFC     0.000110  0.000143  0.000078  0.000355  0.000060  0.000162  0.000118  \nWMT     0.000048  0.000061  0.000046  0.000060  0.000146  0.000044  0.000045  \nXOM     0.000085  0.000097  0.000063  0.000162  0.000044  0.000247  0.000087  \nYUM     0.000063  0.000109  0.000048  0.000118  0.000045  0.000087  0.000222  \n\n[54 rows x 54 columns]\n\n\n\n\n\nCreate a plot showing the evolution of prices for all assets on the same graph. Make sure to normalize the prices to start at 100 to make them comparable.\nHint: - Normalize prices by dividing by the initial price and multiplying by 100 - Use matplotlib’s plot function - Add a legend to distinguish between assets\n\n# Normalize prices\nnormalized_prices = prices / prices.iloc[0] * 100\n\n# Create the plot\nplt.figure(figsize=(12, 6))\nfor column in normalized_prices.columns:\n    plt.plot(normalized_prices.index, normalized_prices[column], label=column)\n\nplt.title('Normalized Price Evolution (Base 100)')\nplt.xlabel('Date')\nplt.ylabel('Normalized Price')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreate an equally-weighted portfolio from our five assets. Calculate its daily returns and analyze its performance metrics (mean return, volatility, Sharpe ratio assuming risk-free rate = 0).\nHint: - Equal weights means 1/N for each asset - Portfolio return is the weighted sum of individual returns - Portfolio volatility requires using the covariance matrix\n\n# Create equal weights\nn_assets = len(tickers)\nweights_equal = np.array([1/n_assets] * n_assets)\n\n# Calculate portfolio returns\nportfolio_returns = returns @ weights_equal\n\n# Calculate portfolio metrics\nportfolio_mean_return = portfolio_returns.mean()\nportfolio_volatility = np.sqrt(weights_equal.T @ covariance_matrix @ weights_equal)\nsharpe_ratio = portfolio_mean_return / portfolio_volatility\n\nprint(f\"Equal-weighted Portfolio Metrics (daily):\")\nprint(f\"Mean Return: {portfolio_mean_return:.4%}\")\nprint(f\"Volatility: {portfolio_volatility:.4%}\")\nprint(f\"Sharpe Ratio: {sharpe_ratio:.4f}\")\n\nEqual-weighted Portfolio Metrics (daily):\nMean Return: 0.0556%\nVolatility: 1.0755%\nSharpe Ratio: 0.0517\n\n\n\n\n\nWrite a function that computes the mean return and volatility of a portfolio given: - A set of weights - The mean returns of individual assets - The covariance matrix of returns\nHint: - Portfolio return = weighted sum of individual returns - Portfolio variance = w^T * Σ * w (where Σ is the covariance matrix)\n\ndef portfolio_metrics(weights, mean_returns, cov_matrix):\n    \"\"\"\n    Calculate portfolio metrics\n    \n    Parameters:\n    weights: array of asset weights\n    mean_returns: array of asset mean returns\n    cov_matrix: covariance matrix of returns\n    \n    Returns:\n    tuple: (portfolio return, portfolio volatility)\n    \"\"\"\n    portfolio_return = np.sum(mean_returns * weights)\n    portfolio_volatility = np.sqrt(weights.T @ cov_matrix @ weights)\n    \n    return portfolio_return, portfolio_volatility\n\n# Test the function with equal weights\nmean_returns = returns.mean()\ntest_metrics = portfolio_metrics(weights_equal, mean_returns, covariance_matrix)\nprint(\"\\nTest with equal weights:\")\nprint(f\"Portfolio Return: {test_metrics[0]:.4%}\")\nprint(f\"Portfolio Volatility: {test_metrics[1]:.4%}\")\n\n\nTest with equal weights:\nPortfolio Return: 0.0556%\nPortfolio Volatility: 1.0755%\n\n\n\n\n\nSplit your data into two periods: training (2020-2021) and testing (2022-2023). Calculate the mean returns and covariance matrix for the training period.\nHint: - Use datetime index to split the data - Recalculate all metrics on the training set\n\n# Split the data\nsplit_date = '2020-01-01'\ntrain_returns = returns[returns.index &lt; split_date]\ntest_returns = returns[returns.index &gt;= split_date]\n\n# Calculate metrics for training period\ntrain_mean_returns = train_returns.mean()\ntrain_cov_matrix = train_returns.cov()\n\nprint(\"Training Period Statistics:\")\nprint(\"\\nMean Returns:\")\nprint(train_mean_returns)\nprint(\"\\nCovariance Matrix:\")\nprint(train_cov_matrix)\n\n\nTraining Period Statistics:\n\nMean Returns:\nTicker\nAAPL     0.001087\nABT      0.000644\nAPD      0.000630\nAXP      0.000605\nBA       0.000918\nBAC      0.000574\nBMY      0.000599\nC        0.000563\nCAT      0.000624\nCL       0.000349\nCMCSA    0.000832\nCOP      0.000472\nCSCO     0.000489\nCVX      0.000404\nDE       0.000664\nECL      0.000692\nFCX      0.000109\nFDX      0.000395\nGE       0.000142\nGIS      0.000354\nGS       0.000303\nHD       0.000980\nHON      0.000778\nINTC     0.000661\nJNJ      0.000488\nJPM      0.000689\nKMB      0.000510\nKO       0.000430\nLOW      0.000846\nMCD      0.000623\nMMM      0.000477\nMRK      0.000569\nMS       0.000478\nMSFT     0.000845\nNEM      0.000262\nNKE      0.000887\nNUE      0.000329\nORCL     0.000459\nOXY      0.000020\nPEP      0.000477\nPFE      0.000502\nPG       0.000453\nPPG      0.000765\nPSA      0.000599\nSBUX     0.000982\nSLB      0.000046\nSPG      0.000505\nT        0.000470\nTJX      0.000900\nVZ       0.000514\nWFC      0.000488\nWMT      0.000470\nXOM      0.000200\nYUM      0.000729\ndtype: float64\n\nCovariance Matrix:\nTicker      AAPL       ABT       APD       AXP        BA       BAC       BMY  \\\nTicker                                                                         \nAAPL    0.000263  0.000065  0.000078  0.000089  0.000099  0.000119  0.000058   \nABT     0.000065  0.000138  0.000072  0.000077  0.000080  0.000091  0.000072   \nAPD     0.000078  0.000072  0.000167  0.000095  0.000103  0.000129  0.000062   \nAXP     0.000089  0.000077  0.000095  0.000205  0.000112  0.000177  0.000066   \nBA      0.000099  0.000080  0.000103  0.000112  0.000244  0.000152  0.000069   \nBAC     0.000119  0.000091  0.000129  0.000177  0.000152  0.000419  0.000081   \nBMY     0.000058  0.000072  0.000062  0.000066  0.000069  0.000081  0.000211   \nC       0.000118  0.000099  0.000135  0.000171  0.000153  0.000332  0.000088   \nCAT     0.000120  0.000078  0.000127  0.000130  0.000144  0.000189  0.000068   \nCL      0.000042  0.000047  0.000056  0.000053  0.000058  0.000051  0.000045   \nCMCSA   0.000075  0.000061  0.000080  0.000092  0.000087  0.000123  0.000059   \nCOP     0.000088  0.000068  0.000097  0.000100  0.000104  0.000153  0.000061   \nCSCO    0.000105  0.000075  0.000091  0.000098  0.000103  0.000142  0.000062   \nCVX     0.000076  0.000066  0.000089  0.000089  0.000094  0.000131  0.000059   \nDE      0.000101  0.000070  0.000105  0.000107  0.000123  0.000159  0.000061   \nECL     0.000067  0.000065  0.000089  0.000079  0.000085  0.000111  0.000058   \nFCX     0.000149  0.000111  0.000167  0.000176  0.000178  0.000255  0.000091   \nFDX     0.000094  0.000078  0.000106  0.000114  0.000125  0.000171  0.000067   \nGE      0.000086  0.000069  0.000095  0.000109  0.000107  0.000161  0.000063   \nGIS     0.000034  0.000038  0.000044  0.000040  0.000041  0.000047  0.000034   \nGS      0.000100  0.000080  0.000110  0.000138  0.000122  0.000251  0.000071   \nHD      0.000076  0.000063  0.000076  0.000090  0.000088  0.000115  0.000059   \nHON     0.000093  0.000076  0.000106  0.000110  0.000124  0.000152  0.000068   \nINTC    0.000107  0.000077  0.000086  0.000097  0.000102  0.000129  0.000063   \nJNJ     0.000045  0.000057  0.000055  0.000059  0.000062  0.000069  0.000059   \nJPM     0.000095  0.000081  0.000111  0.000144  0.000125  0.000268  0.000075   \nKMB     0.000032  0.000044  0.000050  0.000042  0.000047  0.000046  0.000045   \nKO      0.000039  0.000043  0.000051  0.000051  0.000052  0.000057  0.000039   \nLOW     0.000077  0.000066  0.000082  0.000096  0.000094  0.000133  0.000061   \nMCD     0.000047  0.000043  0.000050  0.000050  0.000052  0.000060  0.000038   \nMMM     0.000082  0.000069  0.000089  0.000094  0.000101  0.000127  0.000060   \nMRK     0.000052  0.000074  0.000066  0.000072  0.000067  0.000090  0.000062   \nMS      0.000119  0.000105  0.000142  0.000178  0.000156  0.000338  0.000090   \nMSFT    0.000106  0.000076  0.000086  0.000097  0.000096  0.000125  0.000060   \nNEM     0.000043  0.000022  0.000046  0.000035  0.000035  0.000029  0.000029   \nNKE     0.000082  0.000066  0.000082  0.000093  0.000094  0.000114  0.000057   \nNUE     0.000097  0.000077  0.000119  0.000118  0.000124  0.000188  0.000070   \nORCL    0.000095  0.000073  0.000094  0.000100  0.000101  0.000140  0.000064   \nOXY     0.000088  0.000069  0.000103  0.000097  0.000108  0.000159  0.000062   \nPEP     0.000038  0.000041  0.000046  0.000046  0.000048  0.000049  0.000040   \nPFE     0.000059  0.000069  0.000065  0.000074  0.000068  0.000096  0.000077   \nPG      0.000039  0.000041  0.000044  0.000047  0.000047  0.000050  0.000041   \nPPG     0.000085  0.000078  0.000115  0.000106  0.000110  0.000149  0.000067   \nPSA     0.000051  0.000045  0.000062  0.000068  0.000069  0.000089  0.000044   \nSBUX    0.000087  0.000063  0.000087  0.000093  0.000090  0.000116  0.000058   \nSLB     0.000102  0.000068  0.000111  0.000109  0.000116  0.000177  0.000061   \nSPG     0.000066  0.000053  0.000070  0.000084  0.000081  0.000114  0.000050   \nT       0.000046  0.000044  0.000051  0.000057  0.000056  0.000075  0.000041   \nTJX     0.000067  0.000060  0.000064  0.000075  0.000078  0.000099  0.000049   \nVZ      0.000037  0.000044  0.000048  0.000052  0.000049  0.000063  0.000038   \nWFC     0.000090  0.000077  0.000103  0.000137  0.000122  0.000234  0.000069   \nWMT     0.000040  0.000044  0.000041  0.000047  0.000049  0.000057  0.000039   \nXOM     0.000067  0.000059  0.000080  0.000078  0.000086  0.000116  0.000053   \nYUM     0.000075  0.000060  0.000079  0.000084  0.000086  0.000109  0.000055   \n\nTicker         C       CAT        CL  ...      SBUX       SLB       SPG  \\\nTicker                                ...                                 \nAAPL    0.000118  0.000120  0.000042  ...  0.000087  0.000102  0.000066   \nABT     0.000099  0.000078  0.000047  ...  0.000063  0.000068  0.000053   \nAPD     0.000135  0.000127  0.000056  ...  0.000087  0.000111  0.000070   \nAXP     0.000171  0.000130  0.000053  ...  0.000093  0.000109  0.000084   \nBA      0.000153  0.000144  0.000058  ...  0.000090  0.000116  0.000081   \nBAC     0.000332  0.000189  0.000051  ...  0.000116  0.000177  0.000114   \nBMY     0.000088  0.000068  0.000045  ...  0.000058  0.000061  0.000050   \nC       0.000381  0.000192  0.000059  ...  0.000117  0.000181  0.000114   \nCAT     0.000192  0.000293  0.000052  ...  0.000095  0.000179  0.000092   \nCL      0.000059  0.000052  0.000105  ...  0.000058  0.000050  0.000053   \nCMCSA   0.000125  0.000109  0.000052  ...  0.000080  0.000096  0.000077   \nCOP     0.000153  0.000162  0.000047  ...  0.000072  0.000199  0.000073   \nCSCO    0.000141  0.000126  0.000054  ...  0.000089  0.000112  0.000076   \nCVX     0.000135  0.000135  0.000049  ...  0.000069  0.000158  0.000074   \nDE      0.000159  0.000190  0.000050  ...  0.000083  0.000140  0.000081   \nECL     0.000112  0.000103  0.000052  ...  0.000077  0.000096  0.000061   \nFCX     0.000260  0.000310  0.000063  ...  0.000110  0.000279  0.000120   \nFDX     0.000173  0.000158  0.000053  ...  0.000095  0.000135  0.000088   \nGE      0.000165  0.000138  0.000050  ...  0.000083  0.000135  0.000082   \nGIS     0.000047  0.000040  0.000051  ...  0.000042  0.000042  0.000046   \nGS      0.000243  0.000154  0.000047  ...  0.000089  0.000142  0.000086   \nHD      0.000116  0.000097  0.000050  ...  0.000087  0.000082  0.000075   \nHON     0.000154  0.000149  0.000058  ...  0.000094  0.000126  0.000084   \nINTC    0.000134  0.000128  0.000046  ...  0.000077  0.000106  0.000072   \nJNJ     0.000074  0.000061  0.000045  ...  0.000051  0.000059  0.000047   \nJPM     0.000257  0.000155  0.000052  ...  0.000094  0.000148  0.000093   \nKMB     0.000049  0.000046  0.000069  ...  0.000047  0.000038  0.000050   \nKO      0.000061  0.000054  0.000052  ...  0.000049  0.000051  0.000050   \nLOW     0.000131  0.000111  0.000051  ...  0.000093  0.000098  0.000081   \nMCD     0.000064  0.000055  0.000042  ...  0.000068  0.000048  0.000046   \nMMM     0.000128  0.000130  0.000052  ...  0.000073  0.000113  0.000073   \nMRK     0.000092  0.000074  0.000046  ...  0.000060  0.000067  0.000058   \nMS      0.000328  0.000198  0.000063  ...  0.000120  0.000192  0.000114   \nMSFT    0.000129  0.000116  0.000050  ...  0.000091  0.000091  0.000066   \nNEM     0.000037  0.000075  0.000027  ...  0.000025  0.000086  0.000044   \nNKE     0.000120  0.000103  0.000051  ...  0.000099  0.000092  0.000075   \nNUE     0.000188  0.000179  0.000052  ...  0.000093  0.000163  0.000091   \nORCL    0.000146  0.000125  0.000053  ...  0.000090  0.000117  0.000076   \nOXY     0.000164  0.000161  0.000049  ...  0.000082  0.000202  0.000087   \nPEP     0.000055  0.000046  0.000053  ...  0.000046  0.000044  0.000046   \nPFE     0.000099  0.000079  0.000041  ...  0.000061  0.000075  0.000061   \nPG      0.000056  0.000047  0.000063  ...  0.000047  0.000044  0.000046   \nPPG     0.000153  0.000143  0.000059  ...  0.000088  0.000121  0.000084   \nPSA     0.000090  0.000073  0.000050  ...  0.000068  0.000068  0.000111   \nSBUX    0.000117  0.000095  0.000058  ...  0.000221  0.000088  0.000079   \nSLB     0.000181  0.000179  0.000050  ...  0.000088  0.000309  0.000091   \nSPG     0.000114  0.000092  0.000053  ...  0.000079  0.000091  0.000174   \nT       0.000080  0.000069  0.000043  ...  0.000047  0.000066  0.000052   \nTJX     0.000101  0.000082  0.000046  ...  0.000079  0.000071  0.000070   \nVZ      0.000067  0.000056  0.000044  ...  0.000047  0.000053  0.000055   \nWFC     0.000221  0.000139  0.000051  ...  0.000097  0.000136  0.000094   \nWMT     0.000060  0.000049  0.000042  ...  0.000049  0.000041  0.000048   \nXOM     0.000121  0.000118  0.000047  ...  0.000061  0.000137  0.000066   \nYUM     0.000114  0.000098  0.000050  ...  0.000102  0.000078  0.000069   \n\nTicker         T       TJX        VZ       WFC       WMT       XOM       YUM  \nTicker                                                                        \nAAPL    0.000046  0.000067  0.000037  0.000090  0.000040  0.000067  0.000075  \nABT     0.000044  0.000060  0.000044  0.000077  0.000044  0.000059  0.000060  \nAPD     0.000051  0.000064  0.000048  0.000103  0.000041  0.000080  0.000079  \nAXP     0.000057  0.000075  0.000052  0.000137  0.000047  0.000078  0.000084  \nBA      0.000056  0.000078  0.000049  0.000122  0.000049  0.000086  0.000086  \nBAC     0.000075  0.000099  0.000063  0.000234  0.000057  0.000116  0.000109  \nBMY     0.000041  0.000049  0.000038  0.000069  0.000039  0.000053  0.000055  \nC       0.000080  0.000101  0.000067  0.000221  0.000060  0.000121  0.000114  \nCAT     0.000069  0.000082  0.000056  0.000139  0.000049  0.000118  0.000098  \nCL      0.000043  0.000046  0.000044  0.000051  0.000042  0.000047  0.000050  \nCMCSA   0.000064  0.000069  0.000058  0.000104  0.000048  0.000076  0.000072  \nCOP     0.000056  0.000063  0.000050  0.000117  0.000040  0.000139  0.000076  \nCSCO    0.000057  0.000074  0.000048  0.000110  0.000051  0.000082  0.000078  \nCVX     0.000058  0.000060  0.000054  0.000106  0.000041  0.000124  0.000066  \nDE      0.000061  0.000072  0.000052  0.000121  0.000043  0.000091  0.000082  \nECL     0.000046  0.000063  0.000044  0.000088  0.000039  0.000071  0.000072  \nFCX     0.000089  0.000105  0.000075  0.000187  0.000061  0.000176  0.000119  \nFDX     0.000062  0.000085  0.000052  0.000132  0.000053  0.000091  0.000091  \nGE      0.000066  0.000074  0.000058  0.000125  0.000044  0.000092  0.000074  \nGIS     0.000039  0.000038  0.000040  0.000044  0.000037  0.000038  0.000039  \nGS      0.000064  0.000078  0.000052  0.000172  0.000047  0.000097  0.000086  \nHD      0.000050  0.000086  0.000046  0.000094  0.000053  0.000064  0.000075  \nHON     0.000059  0.000078  0.000053  0.000122  0.000050  0.000087  0.000086  \nINTC    0.000054  0.000072  0.000048  0.000101  0.000045  0.000082  0.000077  \nJNJ     0.000041  0.000042  0.000043  0.000063  0.000037  0.000053  0.000048  \nJPM     0.000068  0.000083  0.000060  0.000189  0.000051  0.000103  0.000092  \nKMB     0.000043  0.000039  0.000048  0.000045  0.000041  0.000042  0.000046  \nKO      0.000040  0.000038  0.000043  0.000054  0.000037  0.000046  0.000046  \nLOW     0.000052  0.000092  0.000047  0.000106  0.000055  0.000073  0.000079  \nMCD     0.000033  0.000046  0.000035  0.000053  0.000035  0.000042  0.000067  \nMMM     0.000053  0.000063  0.000050  0.000102  0.000045  0.000080  0.000070  \nMRK     0.000049  0.000050  0.000050  0.000074  0.000042  0.000061  0.000058  \nMS      0.000082  0.000102  0.000069  0.000227  0.000062  0.000125  0.000108  \nMSFT    0.000051  0.000066  0.000049  0.000099  0.000048  0.000074  0.000086  \nNEM     0.000031  0.000011  0.000027  0.000022  0.000015  0.000057  0.000026  \nNKE     0.000048  0.000089  0.000044  0.000096  0.000049  0.000065  0.000083  \nNUE     0.000068  0.000080  0.000060  0.000139  0.000054  0.000111  0.000087  \nORCL    0.000056  0.000071  0.000048  0.000106  0.000046  0.000083  0.000079  \nOXY     0.000060  0.000068  0.000052  0.000123  0.000039  0.000132  0.000078  \nPEP     0.000037  0.000038  0.000042  0.000047  0.000038  0.000042  0.000042  \nPFE     0.000047  0.000051  0.000046  0.000081  0.000041  0.000063  0.000055  \nPG      0.000039  0.000036  0.000042  0.000047  0.000040  0.000044  0.000041  \nPPG     0.000057  0.000079  0.000055  0.000118  0.000046  0.000086  0.000086  \nPSA     0.000042  0.000056  0.000046  0.000076  0.000040  0.000050  0.000065  \nSBUX    0.000047  0.000079  0.000047  0.000097  0.000049  0.000061  0.000102  \nSLB     0.000066  0.000071  0.000053  0.000136  0.000041  0.000137  0.000078  \nSPG     0.000052  0.000070  0.000055  0.000094  0.000048  0.000066  0.000069  \nT       0.000111  0.000045  0.000073  0.000066  0.000039  0.000056  0.000044  \nTJX     0.000045  0.000172  0.000043  0.000082  0.000050  0.000056  0.000070  \nVZ      0.000073  0.000043  0.000111  0.000059  0.000040  0.000048  0.000043  \nWFC     0.000066  0.000082  0.000059  0.000229  0.000050  0.000097  0.000088  \nWMT     0.000039  0.000050  0.000040  0.000050  0.000118  0.000039  0.000041  \nXOM     0.000056  0.000056  0.000048  0.000097  0.000039  0.000136  0.000061  \nYUM     0.000044  0.000070  0.000043  0.000088  0.000041  0.000061  0.000198  \n\n[54 rows x 54 columns]\n\n\n\n\n\nCreate a function to generate random portfolio weights and use it to create the efficient frontier visualization. Generate 1000 random portfolios and plot them on a risk-return graph.\nHint: - Use np.random.random() to generate weights - Normalize weights to sum to 1 - Store results in arrays for plotting - Highlight the minimum variance and maximum Sharpe ratio portfolios\n\ndef generate_random_weights(n_assets):\n    \"\"\"Generate random weights that sum to 1\"\"\"\n    weights = np.random.random(n_assets)\n    return weights / np.sum(weights)\n\n# Generate random portfolios\nn_portfolios = 100000\nresults = np.zeros((n_portfolios, 3))  # To store return, volatility, Sharpe ratio\n\nfor i in range(n_portfolios):\n    weights = generate_random_weights(n_assets)\n    ret, vol = portfolio_metrics(weights, train_mean_returns, train_cov_matrix)\n    sharpe = ret / vol\n    results[i] = [ret, vol, sharpe]\n\n# Plot results\nplt.figure(figsize=(10, 6))\nplt.scatter(results[:, 1], results[:, 0], \n           c=results[:, 2], cmap='viridis', \n           marker='o', s=10, alpha=0.3)\n\nplt.colorbar(label='Sharpe ratio')\nplt.xlabel('Volatility')\nplt.ylabel('Expected Return')\nplt.title('Efficient Frontier of Random Portfolios')\n\n# Plot equal weight portfolio\nequal_ret, equal_vol = portfolio_metrics(weights_equal, \n                                       train_mean_returns, \n                                       train_cov_matrix)\nplt.scatter(equal_vol, equal_ret, \n           color='red', marker='*', s=200, \n           label='Equal Weight Portfolio')\n\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nUse scipy’s optimize function to find the minimum variance portfolio and the maximum Sharpe ratio portfolio. Make sure to include the constraint that weights must sum to 1 and be non-negative.\nHint: - Use scipy.optimize.minimize - Define objective functions for minimum variance and maximum Sharpe ratio - Use SLSQP optimizer - Check the optimization success flag\n\ndef objective_variance(weights):\n    return portfolio_metrics(weights, train_mean_returns, train_cov_matrix)[1]\n\ndef objective_sharpe(weights):\n    ret, vol = portfolio_metrics(weights, train_mean_returns, train_cov_matrix)\n    return -ret/vol  # Negative because we minimize\n\n# Constraints\nconstraints = (\n    {'type': 'eq', 'fun': lambda x: np.sum(x) - 1}  # weights sum to 1\n)\nbounds = tuple((0, 1) for _ in range(n_assets))  # weights between 0 and 1\n\n# Find minimum variance portfolio\nmin_var_result = minimize(objective_variance, weights_equal,\n                         method='SLSQP',\n                         bounds=bounds,\n                         constraints=constraints)\n\nif not min_var_result.success:\n    print(\"Warning: Minimum variance optimization did not converge!\")\n\n# Find maximum Sharpe ratio portfolio\nmax_sharpe_result = minimize(objective_sharpe, weights_equal,\n                           method='SLSQP',\n                           bounds=bounds,\n                           constraints=constraints)\n\nif not max_sharpe_result.success:\n    print(\"Warning: Maximum Sharpe optimization did not converge!\")\n\n# Print results\nprint(\"\\nMinimum Variance Portfolio:\")\nfor ticker, weight in zip(tickers, min_var_result.x):\n    print(f\"{ticker}: {weight:.4f}\")\nret, vol = portfolio_metrics(min_var_result.x, train_mean_returns, train_cov_matrix)\nprint(f\"Expected Return: {ret:.4%}\")\nprint(f\"Volatility: {vol:.4%}\")\n\nprint(\"\\nMaximum Sharpe Ratio Portfolio:\")\nfor ticker, weight in zip(tickers, max_sharpe_result.x):\n    print(f\"{ticker}: {weight:.4f}\")\nret, vol = portfolio_metrics(max_sharpe_result.x, train_mean_returns, train_cov_matrix)\nprint(f\"Expected Return: {ret:.4%}\")\nprint(f\"Volatility: {vol:.4%}\")\n\n\nMinimum Variance Portfolio:\nAAPL: 0.0134\nMSFT: 0.0049\nINTC: 0.0000\nCSCO: 0.0000\nORCL: 0.0000\nJPM: 0.0000\nBAC: 0.0103\nGS: 0.0000\nMS: 0.0000\nC: 0.0000\nAXP: 0.0000\nWFC: 0.0000\nJNJ: 0.0000\nPFE: 0.0000\nMRK: 0.0000\nABT: 0.0000\nBMY: 0.0000\nXOM: 0.0000\nCVX: 0.0000\nCOP: 0.0846\nSLB: 0.0000\nOXY: 0.0000\nWMT: 0.0000\nPG: 0.0000\nKO: 0.0952\nPEP: 0.0000\nCL: 0.0342\nKMB: 0.0841\nGIS: 0.0000\nHD: 0.1474\nMCD: 0.0000\nNKE: 0.0015\nSBUX: 0.0000\nTJX: 0.0000\nLOW: 0.0445\nYUM: 0.0000\nCAT: 0.0000\nBA: 0.0000\nMMM: 0.0000\nHON: 0.1014\nGE: 0.0133\nDE: 0.0877\nFDX: 0.0000\nAPD: 0.0061\nECL: 0.0000\nNEM: 0.0000\nFCX: 0.0000\nPPG: 0.0696\nNUE: 0.0297\nVZ: 0.0575\nT: 0.0000\nCMCSA: 0.1146\nSPG: 0.0000\nPSA: 0.0000\nExpected Return: 0.0499%\nVolatility: 0.6731%\n\nMaximum Sharpe Ratio Portfolio:\nAAPL: 0.1639\nMSFT: 0.0000\nINTC: 0.0000\nCSCO: 0.0000\nORCL: 0.0310\nJPM: 0.0000\nBAC: 0.0101\nGS: 0.0000\nMS: 0.0000\nC: 0.0000\nAXP: 0.0556\nWFC: 0.0000\nJNJ: 0.0000\nPFE: 0.0000\nMRK: 0.0000\nABT: 0.0000\nBMY: 0.0000\nXOM: 0.0000\nCVX: 0.0000\nCOP: 0.0000\nSLB: 0.0000\nOXY: 0.2121\nWMT: 0.0000\nPG: 0.0000\nKO: 0.0000\nPEP: 0.0000\nCL: 0.0647\nKMB: 0.0000\nGIS: 0.0000\nHD: 0.1537\nMCD: 0.0000\nNKE: 0.0000\nSBUX: 0.0000\nTJX: 0.0015\nLOW: 0.0009\nYUM: 0.0187\nCAT: 0.0000\nBA: 0.0000\nMMM: 0.0000\nHON: 0.0285\nGE: 0.0000\nDE: 0.0000\nFDX: 0.0000\nAPD: 0.0000\nECL: 0.0780\nNEM: 0.0000\nFCX: 0.0000\nPPG: 0.0000\nNUE: 0.1387\nVZ: 0.0425\nT: 0.0000\nCMCSA: 0.0000\nSPG: 0.0000\nPSA: 0.0000\nExpected Return: 0.0850%\nVolatility: 0.8703%\n\n\n\n\n\nBacktest your optimized portfolios (minimum variance and maximum Sharpe ratio) on the test period. Compare their performance with the equally-weighted portfolio.\nHint: - Use the weights found in the training period - Calculate cumulative returns for each portfolio - Plot the evolution of portfolio values - Calculate key performance metrics (return, volatility, Sharpe ratio, maximum drawdown)\n\ndef calculate_portfolio_value(weights, returns):\n    \"\"\"Calculate portfolio value evolution starting at 100\"\"\"\n    portfolio_returns = returns @ weights\n    return 100 * (1 + portfolio_returns).cumprod()\n\n\n# Calculate performance metrics for test period\ndef calculate_metrics(returns):\n    mean_ret = returns.mean()\n    vol = returns.std()\n    sharpe = mean_ret / vol\n    cum_ret = (1 + returns).prod() - 1\n    return {'Mean Return': mean_ret,\n            'Volatility': vol,\n            'Sharpe Ratio': sharpe,\n            'Cumulative Return': cum_ret}\n\n# Calculate portfolio values for each strategy\ntrain_equal = calculate_portfolio_value(weights_equal, train_returns)\ntrain_min_var = calculate_portfolio_value(min_var_result.x, train_returns)\ntrain_max_sharpe = calculate_portfolio_value(max_sharpe_result.x, train_returns)\n\n# Plot results\nplt.figure(figsize=(12, 6))\nplt.plot(train_equal.index, train_equal, label='Equal Weight')\nplt.plot(train_min_var.index, train_min_var, label='Min Variance')\nplt.plot(train_max_sharpe.index, train_max_sharpe, label='Max Sharpe')\n\nplt.title('Portfolio Value Evolution - Train Period')\nplt.xlabel('Date')\nplt.ylabel('Portfolio Value')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n# Calculate and display metrics for each portfolio\nportfolios = {\n    'Equal Weight': weights_equal,\n    'Min Variance': min_var_result.x,\n    'Max Sharpe': max_sharpe_result.x\n}\n\nprint(\"\\nTrain Period Performance:\")\nfor name, weights in portfolios.items():\n    portfolio_returns = train_returns @ weights\n    metrics = calculate_metrics(portfolio_returns)\n    print(f\"\\n{name}:\")\n    for metric, value in metrics.items():\n        print(f\"{metric}: {value:.4%}\")\n\n\n# Calculate portfolio values for each strategy\ntest_equal = calculate_portfolio_value(weights_equal, test_returns)\ntest_min_var = calculate_portfolio_value(min_var_result.x, test_returns)\ntest_max_sharpe = calculate_portfolio_value(max_sharpe_result.x, test_returns)\n\n# Plot results\nplt.figure(figsize=(12, 6))\nplt.plot(test_equal.index, test_equal, label='Equal Weight')\nplt.plot(test_min_var.index, test_min_var, label='Min Variance')\nplt.plot(test_max_sharpe.index, test_max_sharpe, label='Max Sharpe')\n\nplt.title('Portfolio Value Evolution - Test Period')\nplt.xlabel('Date')\nplt.ylabel('Portfolio Value')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n# Calculate and display metrics for each portfolio\nportfolios = {\n    'Equal Weight': weights_equal,\n    'Min Variance': min_var_result.x,\n    'Max Sharpe': max_sharpe_result.x\n}\n\nprint(\"\\nTest Period Performance:\")\nfor name, weights in portfolios.items():\n    portfolio_returns = test_returns @ weights\n    metrics = calculate_metrics(portfolio_returns)\n    print(f\"\\n{name}:\")\n    for metric, value in metrics.items():\n        print(f\"{metric}: {value:.4%}\")\n\n\n\n\n\n\n\n\n\nTrain Period Performance:\n\nEqual Weight:\nMean Return: 0.0553%\nVolatility: 0.9158%\nSharpe Ratio: 6.0422%\nCumulative Return: 261.7286%\n\nMin Variance:\nMean Return: 0.0499%\nVolatility: 0.6731%\nSharpe Ratio: 7.4197%\nCumulative Return: 231.6049%\n\nMax Sharpe:\nMean Return: 0.0850%\nVolatility: 0.8703%\nSharpe Ratio: 9.7722%\nCumulative Return: 671.2589%\n\nTest Period Performance:\n\nEqual Weight:\nMean Return: 0.0563%\nVolatility: 1.3392%\nSharpe Ratio: 4.2020%\nCumulative Return: 81.2116%\n\nMin Variance:\nMean Return: 0.0390%\nVolatility: 1.0081%\nSharpe Ratio: 3.8640%\nCumulative Return: 53.1191%\n\nMax Sharpe:\nMean Return: 0.0595%\nVolatility: 1.3445%\nSharpe Ratio: 4.4278%\nCumulative Return: 88.5475%"
  },
  {
    "objectID": "content/Cours_4/portfolio_tp_corrected.html#question-3.1-creating-sector-returns",
    "href": "content/Cours_4/portfolio_tp_corrected.html#question-3.1-creating-sector-returns",
    "title": "Modern Portfolio Theory - Practical Work - Corrected version",
    "section": "Question 3.1: Creating Sector Returns",
    "text": "Question 3.1: Creating Sector Returns\nCreate sector-based returns by averaging returns of stocks within the same sector. First, define sector mappings, then compute their historical returns using our existing returns data.\nHint: - Define a dictionary mapping sectors to their constituent stocks - Use pandas mean() function to compute average returns - Remember to handle the train/test split consistently with previous analysis\n\n# Define sector mappings\nsector_mapping = {\n    'Technology': ['AAPL', 'MSFT', 'INTC', 'CSCO', 'ORCL'],\n    'Financial': ['JPM', 'BAC', 'GS', 'MS', 'C', 'AXP', 'WFC'],\n    'Healthcare': ['JNJ', 'PFE', 'MRK', 'ABT', 'BMY'],\n    'Energy': ['XOM', 'CVX', 'COP', 'SLB', 'OXY'],\n    'Consumer_Staples': ['WMT', 'PG', 'KO', 'PEP', 'CL', 'KMB', 'GIS'],\n    'Consumer_Discretionary': ['HD', 'MCD', 'NKE', 'SBUX', 'TJX', 'LOW', 'YUM'],\n    'Industrial': ['CAT', 'BA', 'MMM', 'HON', 'GE', 'DE', 'FDX'],\n    'Materials': ['APD', 'ECL', 'NEM', 'FCX', 'PPG', 'NUE'],\n    'Telecommunications': ['VZ', 'T', 'CMCSA'],\n    'Real_Estate': ['SPG', 'PSA']\n}\n\n\n# Calculate sector returns\nsector_returns = pd.DataFrame()\nfor sector, stocks in sector_mapping.items():\n    sector_returns[sector] = returns[stocks].mean(axis=1)\n\n# Split into training and testing periods\ntrain_sector_returns = sector_returns[returns.index &lt; split_date]\ntest_sector_returns = sector_returns[returns.index &gt;= split_date]\n\n# Display summary statistics for training period\nprint(\"Sector Returns Summary (Training Period):\")\nprint(train_sector_returns.describe())\n\n# Display correlations between sectors\nprint(\"\\nSector Return Correlations (Training Period):\")\nprint(train_sector_returns.corr())\n\nSector Returns Summary (Training Period):\n        Technology    Financial   Healthcare       Energy  Consumer_Staples  \\\ncount  2515.000000  2515.000000  2515.000000  2515.000000       2515.000000   \nmean      0.000708     0.000529     0.000561     0.000228          0.000435   \nstd       0.011622     0.015460     0.009070     0.013255          0.007475   \nmin      -0.056637    -0.120743    -0.048842    -0.080151         -0.039052   \n25%      -0.004963    -0.006888    -0.004165    -0.006827         -0.003661   \n50%       0.000966     0.000601     0.000699     0.000480          0.000543   \n75%       0.006897     0.008406     0.005836     0.007352          0.004696   \nmax       0.063131     0.090448     0.049754     0.058274          0.035414   \n\n       Consumer_Discretionary   Industrial    Materials  Telecommunications  \\\ncount             2515.000000  2515.000000  2515.000000         2515.000000   \nmean                 0.000850     0.000571     0.000464            0.000605   \nstd                  0.009784     0.011905     0.013003            0.009453   \nmin                 -0.055153    -0.069274    -0.058961           -0.054617   \n25%                 -0.004366    -0.005423    -0.006640           -0.004637   \n50%                  0.001120     0.000822     0.000835            0.001034   \n75%                  0.006386     0.006830     0.007747            0.006185   \nmax                  0.058083     0.059283     0.075934            0.038374   \n\n       Real_Estate  \ncount  2515.000000  \nmean      0.000552  \nstd       0.011736  \nmin      -0.079154  \n25%      -0.005862  \n50%       0.000981  \n75%       0.007002  \nmax       0.109263  \n\nSector Return Correlations (Training Period):\n                        Technology  Financial  Healthcare    Energy  \\\nTechnology                1.000000   0.652064    0.603375  0.597924   \nFinancial                 0.652064   1.000000    0.572227  0.634610   \nHealthcare                0.603375   0.572227    1.000000  0.527469   \nEnergy                    0.597924   0.634610    0.527469  1.000000   \nConsumer_Staples          0.515071   0.434815    0.616829  0.436855   \nConsumer_Discretionary    0.673522   0.631643    0.607782  0.538476   \nIndustrial                0.739289   0.762015    0.628253  0.719753   \nMaterials                 0.619829   0.639049    0.543687  0.716903   \nTelecommunications        0.553905   0.557995    0.584180  0.523741   \nReal_Estate               0.473704   0.491617    0.476236  0.440345   \n\n                        Consumer_Staples  Consumer_Discretionary  Industrial  \\\nTechnology                      0.515071                0.673522    0.739289   \nFinancial                       0.434815                0.631643    0.762015   \nHealthcare                      0.616829                0.607782    0.628253   \nEnergy                          0.436855                0.538476    0.719753   \nConsumer_Staples                1.000000                0.603731    0.535556   \nConsumer_Discretionary          0.603731                1.000000    0.704662   \nIndustrial                      0.535556                0.704662    1.000000   \nMaterials                       0.466227                0.579457    0.751812   \nTelecommunications              0.613324                0.583881    0.610452   \nReal_Estate                     0.532315                0.572199    0.537836   \n\n                        Materials  Telecommunications  Real_Estate  \nTechnology               0.619829            0.553905     0.473704  \nFinancial                0.639049            0.557995     0.491617  \nHealthcare               0.543687            0.584180     0.476236  \nEnergy                   0.716903            0.523741     0.440345  \nConsumer_Staples         0.466227            0.613324     0.532315  \nConsumer_Discretionary   0.579457            0.583881     0.572199  \nIndustrial               0.751812            0.610452     0.537836  \nMaterials                1.000000            0.529148     0.465546  \nTelecommunications       0.529148            1.000000     0.499715  \nReal_Estate              0.465546            0.499715     1.000000"
  },
  {
    "objectID": "content/Cours_4/portfolio_tp_corrected.html#question-3.2-weight-conversion-function",
    "href": "content/Cours_4/portfolio_tp_corrected.html#question-3.2-weight-conversion-function",
    "title": "Modern Portfolio Theory - Practical Work - Corrected version",
    "section": "Question 3.2: Weight Conversion Function",
    "text": "Question 3.2: Weight Conversion Function\nCreate and test a function that converts sector-level portfolio weights into individual stock weights, assuming equal weighting within each sector.\nHint: - Each stock within a sector should have equal weight - The sum of all stock weights should equal 1 - Test the function with simple cases\n\n\ndef sector_to_stock_weights(sector_weights, sector_mapping):\n    \"\"\"\n    Convert sector weights to individual stock weights\n\n    Parameters:\n    sector_weights: array-like, weights for each sector\n    sector_mapping: dict, mapping sectors to stock lists\n\n    Returns:\n    dict: Individual stock weights\n    \"\"\"\n    stock_weights = {}\n    \n    for sector, weight in zip(sector_mapping.keys(), sector_weights):\n        stocks_in_sector = sector_mapping[sector]\n        weight_per_stock = weight / len(stocks_in_sector)\n        \n        for stock in stocks_in_sector:\n            stock_weights[stock] = weight_per_stock\n            \n    return stock_weights\n\n# Test 1: Equal weights across sectors\nprint(\"Test 1: Equal sector weights\")\nn_sectors = len(sector_mapping)\nequal_weights = np.ones(n_sectors) / n_sectors\n\nprint(\"\\nSector weights:\")\nfor sector, weight in zip(sector_mapping.keys(), equal_weights):\n    print(f\"{sector}: {weight:.4f}\")\n\nequal_stock_weights = sector_to_stock_weights(equal_weights, sector_mapping)\nprint(\"\\nResulting stock weights:\")\nfor stock, weight in equal_stock_weights.items():\n    print(f\"{stock}: {weight:.4f}\")\n\n# Test 2: Different sector weights\nprint(\"\\nTest 2: Custom sector weights\")\ncustom_weights = np.array([0.3, 0.2, 0.2, 0.1, 0.1, 0.1])\nprint(\"\\nSector weights:\")\nfor sector, weight in zip(sector_mapping.keys(), custom_weights):\n    print(f\"{sector}: {weight:.4f}\")\n\ncustom_stock_weights = sector_to_stock_weights(custom_weights, sector_mapping)\nprint(\"\\nResulting stock weights:\")\nfor stock, weight in custom_stock_weights.items():\n    print(f\"{stock}: {weight:.4f}\")\n\n# Verify weights sum to 1\nprint(f\"\\nVerification - sum of weights: {sum(custom_stock_weights.values()):.6f}\")\n\nTest 1: Equal sector weights\n\nSector weights:\nTechnology: 0.1000\nFinancial: 0.1000\nHealthcare: 0.1000\nEnergy: 0.1000\nConsumer_Staples: 0.1000\nConsumer_Discretionary: 0.1000\nIndustrial: 0.1000\nMaterials: 0.1000\nTelecommunications: 0.1000\nReal_Estate: 0.1000\n\nResulting stock weights:\nAAPL: 0.0200\nMSFT: 0.0200\nINTC: 0.0200\nCSCO: 0.0200\nORCL: 0.0200\nJPM: 0.0143\nBAC: 0.0143\nGS: 0.0143\nMS: 0.0143\nC: 0.0143\nAXP: 0.0143\nWFC: 0.0143\nJNJ: 0.0200\nPFE: 0.0200\nMRK: 0.0200\nABT: 0.0200\nBMY: 0.0200\nXOM: 0.0200\nCVX: 0.0200\nCOP: 0.0200\nSLB: 0.0200\nOXY: 0.0200\nWMT: 0.0143\nPG: 0.0143\nKO: 0.0143\nPEP: 0.0143\nCL: 0.0143\nKMB: 0.0143\nGIS: 0.0143\nHD: 0.0143\nMCD: 0.0143\nNKE: 0.0143\nSBUX: 0.0143\nTJX: 0.0143\nLOW: 0.0143\nYUM: 0.0143\nCAT: 0.0143\nBA: 0.0143\nMMM: 0.0143\nHON: 0.0143\nGE: 0.0143\nDE: 0.0143\nFDX: 0.0143\nAPD: 0.0167\nECL: 0.0167\nNEM: 0.0167\nFCX: 0.0167\nPPG: 0.0167\nNUE: 0.0167\nVZ: 0.0333\nT: 0.0333\nCMCSA: 0.0333\nSPG: 0.0500\nPSA: 0.0500\n\nTest 2: Custom sector weights\n\nSector weights:\nTechnology: 0.3000\nFinancial: 0.2000\nHealthcare: 0.2000\nEnergy: 0.1000\nConsumer_Staples: 0.1000\nConsumer_Discretionary: 0.1000\n\nResulting stock weights:\nAAPL: 0.0600\nMSFT: 0.0600\nINTC: 0.0600\nCSCO: 0.0600\nORCL: 0.0600\nJPM: 0.0286\nBAC: 0.0286\nGS: 0.0286\nMS: 0.0286\nC: 0.0286\nAXP: 0.0286\nWFC: 0.0286\nJNJ: 0.0400\nPFE: 0.0400\nMRK: 0.0400\nABT: 0.0400\nBMY: 0.0400\nXOM: 0.0200\nCVX: 0.0200\nCOP: 0.0200\nSLB: 0.0200\nOXY: 0.0200\nWMT: 0.0143\nPG: 0.0143\nKO: 0.0143\nPEP: 0.0143\nCL: 0.0143\nKMB: 0.0143\nGIS: 0.0143\nHD: 0.0143\nMCD: 0.0143\nNKE: 0.0143\nSBUX: 0.0143\nTJX: 0.0143\nLOW: 0.0143\nYUM: 0.0143\n\nVerification - sum of weights: 1.000000"
  },
  {
    "objectID": "content/Cours_4/portfolio_tp_corrected.html#question-3.3-sector-portfolio-optimization",
    "href": "content/Cours_4/portfolio_tp_corrected.html#question-3.3-sector-portfolio-optimization",
    "title": "Modern Portfolio Theory - Practical Work - Corrected version",
    "section": "Question 3.3: Sector Portfolio Optimization",
    "text": "Question 3.3: Sector Portfolio Optimization\nUsing the training period data, optimize sector-based portfolios for minimum variance and maximum Sharpe ratio. Compare with an equal-weight sector allocation.\nHint: - Use the same optimization approach as in Part 2 - Remember to create new constraints for the number of sectors - Use only training period data for optimization\n\n# Calculate training period metrics\ntrain_sector_mean_returns = train_sector_returns.mean()\ntrain_sector_cov_matrix = train_sector_returns.cov()\n\n# Define optimization constraints for sectors\nn_sectors = len(sector_mapping)\nsector_constraints = ({'type': 'eq', 'fun': lambda x: np.sum(x) - 1})\nsector_bounds = tuple((0, 1) for _ in range(n_sectors))\n\n# Optimize minimum variance portfolio\nsector_min_var_result = minimize(\n    lambda w: portfolio_metrics(w, train_sector_mean_returns, train_sector_cov_matrix)[1],\n    np.ones(n_sectors)/n_sectors,\n    constraints=sector_constraints,\n    bounds=sector_bounds,\n    method='SLSQP'\n)\n\n# Optimize maximum Sharpe ratio portfolio\nsector_max_sharpe_result = minimize(\n    lambda w: -portfolio_metrics(w, train_sector_mean_returns, train_sector_cov_matrix)[0]/\n             portfolio_metrics(w, train_sector_mean_returns, train_sector_cov_matrix)[1],\n    np.ones(n_sectors)/n_sectors,\n    constraints=sector_constraints,\n    bounds=sector_bounds,\n    method='SLSQP'\n)\n\n# Print optimization results\nprint(\"Minimum Variance Portfolio Weights:\")\nfor sector, weight in zip(sector_mapping.keys(), sector_min_var_result.x):\n    print(f\"{sector}: {weight:.4f}\")\n\nprint(\"\\nMaximum Sharpe Ratio Portfolio Weights:\")\nfor sector, weight in zip(sector_mapping.keys(), sector_max_sharpe_result.x):\n    print(f\"{sector}: {weight:.4f}\")\n\nMinimum Variance Portfolio Weights:\nTechnology: 0.0000\nFinancial: 0.0000\nHealthcare: 0.2300\nEnergy: 0.0000\nConsumer_Staples: 0.4999\nConsumer_Discretionary: 0.0869\nIndustrial: 0.0000\nMaterials: 0.0000\nTelecommunications: 0.1832\nReal_Estate: 0.0000\n\nMaximum Sharpe Ratio Portfolio Weights:\nTechnology: 0.0000\nFinancial: 0.0000\nHealthcare: 0.0861\nEnergy: 0.0000\nConsumer_Staples: 0.0000\nConsumer_Discretionary: 0.7308\nIndustrial: 0.0000\nMaterials: 0.0000\nTelecommunications: 0.1831\nReal_Estate: 0.0000"
  },
  {
    "objectID": "content/Cours_4/portfolio_tp_corrected.html#question-3.4-portfolio-visualization",
    "href": "content/Cours_4/portfolio_tp_corrected.html#question-3.4-portfolio-visualization",
    "title": "Modern Portfolio Theory - Practical Work - Corrected version",
    "section": "Question 3.4: Portfolio Visualization",
    "text": "Question 3.4: Portfolio Visualization\nCreate visualizations to compare the sector allocations and corresponding stock allocations for each portfolio strategy.\nHint: - Use pie charts to show both sector and stock level allocations - Use the sector_to_stock_weights function from Question 3.2 - Consider using subplots for clear comparison\n\n# Define portfolio strategies\nportfolios = {\n    'Equal-Weight': np.ones(n_sectors)/n_sectors,\n    'Min Variance': sector_min_var_result.x,\n    'Max Sharpe': sector_max_sharpe_result.x\n}\n\n# Create visualization\nplt.figure(figsize=(15, 10))\n\nfor idx, (name, weights) in enumerate(portfolios.items(), 1):\n    # Sector weights\n    plt.subplot(2, 3, idx)\n    plt.pie(weights, labels=sector_mapping.keys(), autopct='%1.1f%%')\n    plt.title(f'{name}\\nSector Allocation')\n    \n    # Stock weights\n    plt.subplot(2, 3, idx+3)\n    stock_weights = sector_to_stock_weights(weights, sector_mapping)\n    plt.pie(list(stock_weights.values()), \n            labels=list(stock_weights.keys()), \n            autopct='%1.1f%%')\n    plt.title(f'{name}\\nStock Allocation')\n\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "content/Cours_4/portfolio_tp_corrected.html#question-4.1-risk-metrics-function",
    "href": "content/Cours_4/portfolio_tp_corrected.html#question-4.1-risk-metrics-function",
    "title": "Modern Portfolio Theory - Practical Work - Corrected version",
    "section": "Question 4.1: Risk Metrics Function",
    "text": "Question 4.1: Risk Metrics Function\nCreate a function to calculate various risk metrics for a return series: - Maximum Drawdown - Sortino Ratio - Value at Risk (VaR) - Conditional Value at Risk (CVaR)\nHint: - Use cumulative returns for drawdown calculation - Consider using numpy percentile for VaR - Remember to annualize metrics where appropriate\n\n\ndef calculate_risk_metrics(returns, rf_rate=0.02/252):  # Default daily risk-free rate\n    \"\"\"\n    Calculate various risk metrics for a return series\n    \n    Parameters:\n    returns: Series of returns\n    rf_rate: Daily risk-free rate\n    \n    Returns:\n    dict: Dictionary of risk metrics\n    \"\"\"\n    # Maximum Drawdown\n    cum_returns = (1 + returns).cumprod()\n    running_max = cum_returns.cummax()\n    drawdowns = (cum_returns - running_max) / running_max\n    max_drawdown = drawdowns.min()\n    \n    # Sortino Ratio\n    excess_returns = returns - rf_rate\n    downside_returns = returns[returns &lt; 0]\n    downside_std = np.std(downside_returns, ddof=1)\n    sortino = np.sqrt(252) * excess_returns.mean() / downside_std\n    \n    # Value at Risk (95%)\n    var_95 = np.percentile(returns, 5)\n    \n    # Conditional Value at Risk (Expected Shortfall)\n    cvar_95 = returns[returns &lt;= var_95].mean()\n    \n    return {\n        'Maximum Drawdown': max_drawdown,\n        'Sortino Ratio': sortino,\n        'VaR (95%)': var_95,\n        'CVaR (95%)': cvar_95\n    }\n\n# Test the function on training data\nprint(\"Risk Metrics for Equal-Weight Sector Portfolio (Training Period):\")\nequal_weight_returns = train_sector_returns @ (np.ones(n_sectors)/n_sectors)\nmetrics = calculate_risk_metrics(equal_weight_returns)\nfor metric, value in metrics.items():\n    print(f\"{metric}: {value:.4f}\")\n\nRisk Metrics for Equal-Weight Sector Portfolio (Training Period):\nMaximum Drawdown: -0.1618\nSortino Ratio: 1.0901\nVaR (95%): -0.0144\nCVaR (95%): -0.0216"
  },
  {
    "objectID": "content/Cours_4/portfolio_tp_corrected.html#question-4.2-capm-analysis",
    "href": "content/Cours_4/portfolio_tp_corrected.html#question-4.2-capm-analysis",
    "title": "Modern Portfolio Theory - Practical Work - Corrected version",
    "section": "Question 4.2: CAPM Analysis",
    "text": "Question 4.2: CAPM Analysis\nCalculate CAPM metrics (alpha and beta) for sector portfolios. Compare the risk-adjusted performance across different portfolio strategies.\nHint: - Download market data (S&P 500) for the same period - Use linear regression to calculate beta - Remember to annualize alpha\n\nimport statsmodels.api as sm\n\n# Download market data\nmarket_data = yf.download('^GSPC', start=start_date, end=end_date)['Close']\nmarket_returns = market_data.pct_change().dropna()\n\ndef calculate_capm_metrics(returns, market_returns, rf_rate=0.02/252):\n    \"\"\"\n    Calculate CAPM metrics\n    \n    Returns:\n    tuple: (alpha, beta)\n    \"\"\"\n    # Prepare data for regression\n    excess_returns = returns - rf_rate\n    excess_market_returns = market_returns - rf_rate\n    \n    # Add constant for regression\n    X = sm.add_constant(excess_market_returns)\n    \n    # Perform regression\n    model = sm.OLS(excess_returns, X).fit()\n    \n    # Extract and annualize alpha\n    alpha = model.params[0] * 252\n    beta = model.params[1]\n    \n    return alpha, beta\n\n# Calculate CAPM metrics for each portfolio\nfor name, weights in portfolios.items():\n    print(f\"\\n{name} Portfolio CAPM Metrics:\")\n    \n    # Training period\n    portfolio_returns = train_sector_returns @ weights\n    train_market_returns = market_returns[market_returns.index &lt; split_date]\n    alpha, beta = calculate_capm_metrics(portfolio_returns, train_market_returns)\n    print(f\"Training Period - Alpha: {alpha:.4%}, Beta: {beta:.4f}\")\n    \n    # Testing period\n    portfolio_returns = test_sector_returns @ weights\n    test_market_returns = market_returns[market_returns.index &gt;= split_date]\n    alpha, beta = calculate_capm_metrics(portfolio_returns, test_market_returns)\n    print(f\"Testing Period - Alpha: {alpha:.4%}, Beta: {beta:.4f}\")\n\n[*********************100%***********************]  1 of 1 completed\n/var/folders/dr/3gd86y8j4w19p8jdnqy5s65m0000gp/T/ipykernel_70455/2328182781.py:25: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n  alpha = model.params[0] * 252\n/var/folders/dr/3gd86y8j4w19p8jdnqy5s65m0000gp/T/ipykernel_70455/2328182781.py:26: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n  beta = model.params[1]\n/var/folders/dr/3gd86y8j4w19p8jdnqy5s65m0000gp/T/ipykernel_70455/2328182781.py:25: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n  alpha = model.params[0] * 252\n/var/folders/dr/3gd86y8j4w19p8jdnqy5s65m0000gp/T/ipykernel_70455/2328182781.py:26: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n  beta = model.params[1]\n/var/folders/dr/3gd86y8j4w19p8jdnqy5s65m0000gp/T/ipykernel_70455/2328182781.py:25: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n  alpha = model.params[0] * 252\n/var/folders/dr/3gd86y8j4w19p8jdnqy5s65m0000gp/T/ipykernel_70455/2328182781.py:26: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n  beta = model.params[1]\n/var/folders/dr/3gd86y8j4w19p8jdnqy5s65m0000gp/T/ipykernel_70455/2328182781.py:25: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n  alpha = model.params[0] * 252\n/var/folders/dr/3gd86y8j4w19p8jdnqy5s65m0000gp/T/ipykernel_70455/2328182781.py:26: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n  beta = model.params[1]\n/var/folders/dr/3gd86y8j4w19p8jdnqy5s65m0000gp/T/ipykernel_70455/2328182781.py:25: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n  alpha = model.params[0] * 252\n/var/folders/dr/3gd86y8j4w19p8jdnqy5s65m0000gp/T/ipykernel_70455/2328182781.py:26: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n  beta = model.params[1]\n/var/folders/dr/3gd86y8j4w19p8jdnqy5s65m0000gp/T/ipykernel_70455/2328182781.py:25: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n  alpha = model.params[0] * 252\n/var/folders/dr/3gd86y8j4w19p8jdnqy5s65m0000gp/T/ipykernel_70455/2328182781.py:26: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n  beta = model.params[1]\n\n\n\nEqual-Weight Portfolio CAPM Metrics:\nTraining Period - Alpha: 2.8582%, Beta: 0.9390\nTesting Period - Alpha: 0.6888%, Beta: 0.9013\n\nMin Variance Portfolio CAPM Metrics:\nTraining Period - Alpha: 5.2233%, Beta: 0.6415\nTesting Period - Alpha: -1.0409%, Beta: 0.5726\n\nMax Sharpe Portfolio CAPM Metrics:\nTraining Period - Alpha: 9.7843%, Beta: 0.8203\nTesting Period - Alpha: -1.7344%, Beta: 0.8535"
  },
  {
    "objectID": "content/Cours_4/portfolio_tp_corrected.html#question-4.3-performance-comparison",
    "href": "content/Cours_4/portfolio_tp_corrected.html#question-4.3-performance-comparison",
    "title": "Modern Portfolio Theory - Practical Work - Corrected version",
    "section": "Question 4.3: Performance Comparison",
    "text": "Question 4.3: Performance Comparison\nCompare the performance of sector-based portfolios with the individual stock portfolios from Part 2. Create visualizations showing the cumulative returns and risk metrics for both approaches.\nHint: - Use the optimal portfolios from both Parts 2 and 3 - Plot cumulative returns on the same graph - Create a summary table of risk metrics\n\n# Calculate cumulative returns for all portfolios\nplt.figure(figsize=(12, 6))\n\n# Plot sector portfolios\nfor name, weights in portfolios.items():\n    portfolio_returns = pd.concat([\n        train_sector_returns @ weights,\n        test_sector_returns @ weights\n    ])\n    cum_returns = (1 + portfolio_returns).cumprod()\n    plt.plot(cum_returns.index, cum_returns, \n             label=f'Sector {name}', linestyle='-')\n\n# Plot individual stock portfolios from Part 2\nindividual_portfolios = {\n    'Min Variance': min_var_result.x,\n    'Max Sharpe': max_sharpe_result.x\n}\n\nfor name, weights in individual_portfolios.items():\n    portfolio_returns = returns @ weights\n    cum_returns = (1 + portfolio_returns).cumprod()\n    plt.plot(cum_returns.index, cum_returns, \n             label=f'Stock {name}', linestyle='--')\n\nplt.axvline(x=pd.to_datetime(split_date), color='black', \n            linestyle=':', label='Train/Test Split')\nplt.title('Cumulative Returns Comparison')\nplt.xlabel('Date')\nplt.ylabel('Cumulative Return')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n# Compare risk metrics\nprint(\"\\nRisk Metrics Comparison (Testing Period):\")\nall_portfolios = {\n    'Sector Equal-Weight': np.ones(n_sectors)/n_sectors,\n    'Sector Min Variance': sector_min_var_result.x,\n    'Sector Max Sharpe': sector_max_sharpe_result.x,\n    'Stock Min Variance': min_var_result.x,\n    'Stock Max Sharpe': max_sharpe_result.x\n}\n\nfor name, weights in all_portfolios.items():\n    print(f\"\\n{name}:\")\n    if 'Sector' in name:\n        returns_series = test_sector_returns @ weights\n    else:\n        returns_series = test_returns @ weights\n    \n    metrics = calculate_risk_metrics(returns_series)\n    for metric, value in metrics.items():\n        print(f\"{metric}: {value:.4f}\")\n\n\n\n\n\n\n\n\n\nRisk Metrics Comparison (Testing Period):\n\nSector Equal-Weight:\nMaximum Drawdown: -0.3801\nSortino Ratio: 0.6716\nVaR (95%): -0.0170\nCVaR (95%): -0.0311\n\nSector Min Variance:\nMaximum Drawdown: -0.2407\nSortino Ratio: 0.4855\nVaR (95%): -0.0136\nCVaR (95%): -0.0229\n\nSector Max Sharpe:\nMaximum Drawdown: -0.3563\nSortino Ratio: 0.5206\nVaR (95%): -0.0174\nCVaR (95%): -0.0301\n\nStock Min Variance:\nMaximum Drawdown: -0.2395\nSortino Ratio: 0.6236\nVaR (95%): -0.0134\nCVaR (95%): -0.0226\n\nStock Max Sharpe:\nMaximum Drawdown: -0.3405\nSortino Ratio: 0.7347\nVaR (95%): -0.0177\nCVaR (95%): -0.0309\n\n\n\n# Calculate cumulative returns for all portfolios\nplt.figure(figsize=(12, 6))\n\n# Plot sector portfolios\nfor name, weights in portfolios.items():\n    portfolio_returns = test_sector_returns @ weights\n    cum_returns = (1 + portfolio_returns).cumprod()\n    plt.plot(cum_returns.index, cum_returns, \n             label=f'Sector {name}', linestyle='-')\n\n# Plot individual stock portfolios from Part 2\nindividual_portfolios = {\n    'Min Variance': min_var_result.x,\n    'Max Sharpe': max_sharpe_result.x\n}\n\nfor name, weights in individual_portfolios.items():\n    portfolio_returns = test_returns @ weights\n    cum_returns = (1 + portfolio_returns).cumprod()\n    plt.plot(cum_returns.index, cum_returns, \n             label=f'Stock {name}', linestyle='--')\n\nplt.axvline(x=pd.to_datetime(split_date), color='black', \n            linestyle=':', label='Train/Test Split')\nplt.title('Cumulative Returns Comparison')\nplt.xlabel('Date')\nplt.ylabel('Cumulative Return')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n# Compare risk metrics\nprint(\"\\nRisk Metrics Comparison (Testing Period):\")\nall_portfolios = {\n    'Sector Equal-Weight': np.ones(n_sectors)/n_sectors,\n    'Sector Min Variance': sector_min_var_result.x,\n    'Sector Max Sharpe': sector_max_sharpe_result.x,\n    'Stock Min Variance': min_var_result.x,\n    'Stock Max Sharpe': max_sharpe_result.x\n}\n\nfor name, weights in all_portfolios.items():\n    print(f\"\\n{name}:\")\n    if 'Sector' in name:\n        returns_series = test_sector_returns @ weights\n    else:\n        returns_series = test_returns @ weights\n    \n    metrics = calculate_risk_metrics(returns_series)\n    for metric, value in metrics.items():\n        print(f\"{metric}: {value:.4f}\")\n\n\n\n\n\n\n\n\n\nRisk Metrics Comparison (Testing Period):\n\nSector Equal-Weight:\nMaximum Drawdown: -0.3801\nSortino Ratio: 0.6716\nVaR (95%): -0.0170\nCVaR (95%): -0.0311\n\nSector Min Variance:\nMaximum Drawdown: -0.2407\nSortino Ratio: 0.4855\nVaR (95%): -0.0136\nCVaR (95%): -0.0229\n\nSector Max Sharpe:\nMaximum Drawdown: -0.3563\nSortino Ratio: 0.5206\nVaR (95%): -0.0174\nCVaR (95%): -0.0301\n\nStock Min Variance:\nMaximum Drawdown: -0.2395\nSortino Ratio: 0.6236\nVaR (95%): -0.0134\nCVaR (95%): -0.0226\n\nStock Max Sharpe:\nMaximum Drawdown: -0.3405\nSortino Ratio: 0.7347\nVaR (95%): -0.0177\nCVaR (95%): -0.0309"
  },
  {
    "objectID": "content/Cours_4/tp_option_seller_uncorrected.html",
    "href": "content/Cours_4/tp_option_seller_uncorrected.html",
    "title": "TP Python for Finance: Introduction to Option Pricing",
    "section": "",
    "text": "Using the yfinance library, download daily price data for the stock “AAPL” (Apple Inc.) for the last year. Calculate and plot the daily returns of the stock.\n\n\nimport yfinance as yf\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Download the data\nticker = \"AAPL\"\nstart_date = \"2020-01-01\"\nend_date = \"2024-12-31\"\n\n# Your code here to:\n# 1. Download the data using yfinance\n# 2. Calculate daily returns\n# 3. Create a plot of the stock price and returns\n\n[*********************100%***********************]  1 of 1 completed",
    "crumbs": [
      "Travaux Pratiques",
      "TP Python for Finance: Introduction to Option Pricing"
    ]
  },
  {
    "objectID": "content/Cours_4/tp_option_seller_uncorrected.html#question-1-data-collection",
    "href": "content/Cours_4/tp_option_seller_uncorrected.html#question-1-data-collection",
    "title": "TP Python for Finance: Introduction to Option Pricing",
    "section": "",
    "text": "Using the yfinance library, download daily price data for the stock “AAPL” (Apple Inc.) for the last year. Calculate and plot the daily returns of the stock.\n\n\nimport yfinance as yf\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Download the data\nticker = \"AAPL\"\nstart_date = \"2020-01-01\"\nend_date = \"2024-12-31\"\n\n# Your code here to:\n# 1. Download the data using yfinance\n# 2. Calculate daily returns\n# 3. Create a plot of the stock price and returns\n\n[*********************100%***********************]  1 of 1 completed",
    "crumbs": [
      "Travaux Pratiques",
      "TP Python for Finance: Introduction to Option Pricing"
    ]
  },
  {
    "objectID": "content/Cours_4/tp_option_seller_uncorrected.html#question-2-understanding-call-options",
    "href": "content/Cours_4/tp_option_seller_uncorrected.html#question-2-understanding-call-options",
    "title": "TP Python for Finance: Introduction to Option Pricing",
    "section": "Question 2: Understanding Call Options",
    "text": "Question 2: Understanding Call Options\nA Call option is a financial contract that gives the buyer the right (but not the obligation) to buy a stock at a predetermined price (strike price) at a future date (expiration date). The seller of the option (writer) receives a premium for taking on the obligation to sell at the strike price if the buyer exercises their right.\nExample: If you buy a call option for AAPL with: - Strike price (K) = $180 - Current price (S) = $170 - Expiration = 1 month\nIf at expiration: - AAPL price = $190: Your profit = $190 - $180 = $10 (minus the premium paid) - AAPL price = $170: Your loss = premium paid\nCreate a function that calculates the payoff of a call option at expiration.\n\n# Your code here to:\n# Create a function that takes as input:\n# - Strike price (K)\n# - Current price (S)\n# And returns the payoff at expiration\n\n\nTesting call option payoff with strike price = 180\nStock price: 160, Payoff: 0\nStock price: 170, Payoff: 0\nStock price: 180, Payoff: 0\nStock price: 190, Payoff: 10\nStock price: 200, Payoff: 20",
    "crumbs": [
      "Travaux Pratiques",
      "TP Python for Finance: Introduction to Option Pricing"
    ]
  },
  {
    "objectID": "content/Cours_4/tp_option_seller_uncorrected.html#question-3-monte-carlo-simulation",
    "href": "content/Cours_4/tp_option_seller_uncorrected.html#question-3-monte-carlo-simulation",
    "title": "TP Python for Finance: Introduction to Option Pricing",
    "section": "Question 3: Monte Carlo Simulation",
    "text": "Question 3: Monte Carlo Simulation\nCreate a function that simulates future stock prices using Monte Carlo simulation. We’ll use the following assumptions: - Stock returns are normally distributed (Note: This is a simplifying assumption that doesn’t hold well in reality) - The volatility is estimated from historical data\n\n# Your code here to:\n# 1. Create a function that simulates stock paths\n# 2. Use it to estimate option prices\n\nEstimated call option price: 0.81",
    "crumbs": [
      "Travaux Pratiques",
      "TP Python for Finance: Introduction to Option Pricing"
    ]
  },
  {
    "objectID": "content/Cours_4/tp_option_seller_uncorrected.html#question-4-competing-option-sellers",
    "href": "content/Cours_4/tp_option_seller_uncorrected.html#question-4-competing-option-sellers",
    "title": "TP Python for Finance: Introduction to Option Pricing",
    "section": "Question 4: Competing Option Sellers",
    "text": "Question 4: Competing Option Sellers\nTwo option sellers are competing in the market. They use different methods to estimate volatility: - Seller 1: Uses 5-day rolling standard deviation - Seller 2: Uses 10-day rolling standard deviation\nFollow these steps to simulate their competition:\n\nFirst, calculate the rolling volatility for each seller:\n\nUse rolling() function with window=5 for seller 1\nUse rolling() function with window=10 for seller 2\nDon’t forget to use .std() to get the standard deviation\n\nFor each day, calculate the option price that each seller would offer:\n\nUse the estimate_call_price function we created earlier\nYou can use apply() with a lambda function to calculate prices\nEach seller uses their own volatility estimate\n\nDetermine which seller makes the sale:\n\nThe seller with the lower price wins the trade\nUse comparison operators and astype(int) to create indicator variables\n\nCalculate the payoff of the options:\n\nRemember: payoff = max(0, future_price - strike_price)\nUse shift(-1) to get the next day’s price\nUse apply() with lambda x: max(x, 0) for the payoff\n\nCalculate the PnL for each seller:\n\nPnL = (premium received - option payoff) when seller wins the trade\nUse the indicator variables from step 3\n\nPlot the cumulative PnL:\n\nUse cumsum() to calculate cumulative sums\nUse plot() to visualize the results\n\n\n\n# Your code here:\n\n# 1. Calculate rolling volatilities\nstock_data['vol_5d'] = ...\nstock_data['vol_10d'] = ...\n\n# 2. Calculate option prices for each seller\nstock_data['seller_1_price'] = ...\nstock_data['seller_2_price'] = ...\n\n# 3. Determine who makes each sale\nstock_data['seller_1_sold'] = ...\nstock_data['seller_2_sold'] = ...\n\n# 4. Calculate option payoffs\nstock_data['Option Payoff'] = ...\n\n# 5. Calculate PnL for each seller\nstock_data['seller_1_pnl'] = ...\nstock_data['seller_2_pnl'] = ...\n\n# 6. Plot cumulative PnL\n...\n\n\n\n\n\n\n\n\n\nQuestion 4.2:\nCreate the degenerated case with only one option seller, and see how the choice of sigma impact the obtained PnL",
    "crumbs": [
      "Travaux Pratiques",
      "TP Python for Finance: Introduction to Option Pricing"
    ]
  },
  {
    "objectID": "content/Cours_4/1-MutabilitéEtScopes.html",
    "href": "content/Cours_4/1-MutabilitéEtScopes.html",
    "title": "Mutabilité et Scope",
    "section": "",
    "text": "Mutabilité et Scope - Une base de Python\n\n\nCours sur la Mutabilité et le Scope en Python\n\nPremière Partie: Comprendre la Mutabilité\n\nQu’est-ce que la Mutabilité ?\nLa mutabilité en Python fait référence à la capacité d’un objet à être modifié après sa création. Dans Python, certains types de données sont mutables, tandis que d’autres sont immutables.\n\n\nTypes Mutables vs. Immutables\n\nImmutables : Ces types ne peuvent pas être modifiés une fois créés. Les principaux types immutables en Python incluent les entiers (int), les nombres à virgule flottante (float), les chaînes de caractères (str), et les tuples (tuple).\nMutables : Ces types peuvent être modifiés. Les listes (list), les dictionnaires (dict), et les ensembles (set) sont des exemples de types mutables.\n\n\n\nImplications de la Mutabilité\n\nSécurité : Les objets immutables sont plus sûrs à partager et à utiliser car ils ne peuvent pas être modifiés de manière inattendue.\nPerformance : La mutabilité peut affecter la performance. Par exemple, l’ajout d’éléments à une liste (mutable) est généralement plus rapide que la concaténation de tuples (immutables).\n\nTypes Immutables\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nTypes Mutables\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nDeuxième Partie: Scope en Python\n\nQu’est-ce que le Scope ?\nLe scope en Python fait référence à la portée dans laquelle les variables sont visibles et accessibles. Il détermine la visibilité d’une variable au sein du code.\n\n\nTypes de Scope\n\nLocal Scope : Les variables définies à l’intérieur d’une fonction. Elles ne sont accessibles que dans cette fonction.\nEnclosing Scope : Apparaît dans les fonctions imbriquées (fonctions dans une fonction). Une variable dans une fonction englobante est accessible dans la fonction imbriquée.\nGlobal Scope : Les variables définies au niveau du module ou du script. Accessibles partout dans le script ou le module.\nBuilt-in Scope : Contient des noms préassignés par Python, comme print, len.\n\n\n\nManipulation de Scope\n\nglobal Keyword : Permet de modifier une variable globale à l’intérieur d’une fonction.\nnonlocal Keyword : Utilisé dans les fonctions imbriquées pour modifier une variable dans le scope englobant.\n\nExemple 2: Scope en Python\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nTroisième Partie: Mutabilité et Classes en Python\n\nClasses et Objets Mutables\n\nEn Python, les classes peuvent être utilisées pour créer des types mutables. L’état d’une instance de classe (c’est-à-dire ses attributs) peut être modifié après sa création.\nExemple : Une classe Car avec un attribut color peut voir sa couleur modifiée après la création de l’objet.\n\n\n\nPrécautions avec les Objets Mutables\n\nLes modifications apportées à un objet mutable peuvent avoir des effets inattendus, en particulier lors de la copie d’objets ou du passage d’objets comme arguments à des fonctions.\n\nExemple 3: Classes et Mutabilité\n\nclass Car:\n    def __init__(self, color):\n        self.color = color\n\nmy_car = Car(\"red\")\nprint(my_car.color)  # Affiche 'red'\n\nmy_car.color = \"blue\"  # Modification de l'attribut 'color'\nprint(my_car.color)  # Affiche 'blue'\n\nred\nblue\n\n\n\n\n\n\nQuatrième Partie: Implications Pratiques et Bonnes Pratiques\n\ndef add_to_list(element, target_list=[]):  # Liste mutable comme argument par défaut\n    target_list.append(element)\n    return target_list\n\nprint(add_to_list(1))  # Affiche [1]\nprint(add_to_list(2))  # Affiche [1, 2] - L'effet de bord se produit ici\n\n[1]\n[1, 2]\n\n\n\nImplications de la Mutabilité\n\nEffets de Bord : La modification d’objets mutables peut entraîner des effets de bord indésirables, en particulier lorsqu’ils sont partagés entre différentes parties d’un programme.\nCopie Profonde vs. Copie Superficielle : La compréhension de la différence entre copie profonde (deepcopy) et copie superficielle (copy) est essentielle lors de la manipulation d’objets mutables.\n\n\n\nBonnes Pratiques\n\nImmutabilité par Défaut : Préférer l’utilisation de types immutables sauf si la mutabilité est nécessaire. Cela réduit les risques d’erreurs et les effets de bord.\nPrudence avec les Objets Globaux : Être prudent lors de la modification de variables globales, surtout si elles sont mutables.\nDocumentation et Commentaires : Documenter clairement l’utilisation et les modifications des objets mutables, surtout dans les grandes bases de code et les projets de groupe.\n\n\nimport copy\n\noriginal_list = [[1, 2, 3], [4, 5, 6]]\n\n# Copie superficielle\nshallow_copied_list = copy.copy(original_list)\nshallow_copied_list[0][0] = \"X\"\nprint(original_list)  # Affecte la liste originale\n\n# Copie profonde\ndeep_copied_list = copy.deepcopy(original_list)\ndeep_copied_list[0][0] = \"Y\"\nprint(original_list)  # Ne change pas la liste originale\n\n[['X', 2, 3], [4, 5, 6]]\n[['X', 2, 3], [4, 5, 6]]\n\n\n\n\n\nConclusion\nLa compréhension de la mutabilité et du scope en Python est fondamentale pour écrire un code clair, efficace et sans erreurs. Bien que la mutabilité offre de la flexibilité, elle doit être utilisée judicieusement pour éviter des complications inutiles. La maîtrise du scope aide à structurer le code de manière logique et à éviter les conflits de noms et les erreurs inattendues.\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Mutabilité et Scope"
    ]
  },
  {
    "objectID": "content/Cours_4/2-TypageEnPython.html",
    "href": "content/Cours_4/2-TypageEnPython.html",
    "title": "Typage en Python",
    "section": "",
    "text": "Python est un langage à typage dynamique, ce qui signifie que le type d’une variable est déterminé à l’exécution et peut changer au cours du temps.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nAvantages : Flexibilité et facilité d’écriture du code.\nInconvénients : Moins de prévisibilité et risque accru d’erreurs à l’exécution.",
    "crumbs": [
      "Typage en Python"
    ]
  },
  {
    "objectID": "content/Cours_4/2-TypageEnPython.html#types-et-typage-dynamique",
    "href": "content/Cours_4/2-TypageEnPython.html#types-et-typage-dynamique",
    "title": "Typage en Python",
    "section": "",
    "text": "Python est un langage à typage dynamique, ce qui signifie que le type d’une variable est déterminé à l’exécution et peut changer au cours du temps.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nAvantages : Flexibilité et facilité d’écriture du code.\nInconvénients : Moins de prévisibilité et risque accru d’erreurs à l’exécution.",
    "crumbs": [
      "Typage en Python"
    ]
  },
  {
    "objectID": "content/Cours_4/2-TypageEnPython.html#typage-en-python-approfondissement",
    "href": "content/Cours_4/2-TypageEnPython.html#typage-en-python-approfondissement",
    "title": "Typage en Python",
    "section": "Typage en Python: Approfondissement",
    "text": "Typage en Python: Approfondissement\n\nTypage Dynamique en Python\n\nComprendre le Typage Dynamique\nPython est un langage à typage dynamique, ce qui signifie que le type d’une variable est déterminé au moment de l’exécution et non à la compilation. Cette caractéristique offre une grande flexibilité.\n\n\nExemple de Typage Dynamique\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nImplications du Typage Dynamique\n\nFlexibilité : Permet de réaffecter des variables à différents types.\nRisques Potentiels : Peut conduire à des erreurs subtiles, difficiles à détecter avant l’exécution.\n\n\n\n\n\nClasses Abstraites\n\nUtilisation des Classes Abstraites\nLes classes abstraites en Python, utilisées via le module abc, servent à définir une interface pour d’autres classes à suivre, imposant ainsi une certaine structure dans le code.\n\n\nExemple de Classe Abstraite\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nImportance des Classes Abstraites\n\nDéfinition d’Interfaces : Force les classes dérivées à implémenter certaines méthodes.\nStructuration du Code : Aide à maintenir une architecture de code claire et organisée.\n\n\n\n\n\nCompilation avec Cython\n\nAmélioration des Performances avec Cython\nCython permet d’écrire des extensions Python en C pour une exécution plus rapide, ce qui est particulièrement utile pour les calculs intensifs.\n\n\nExemple de Code Cython\nDéfinition d’une fonction en Cython\ncdef int multiply(int a, int b):\n    return a * b\nCette fonction peut maintenant être utilisée comme une fonction Python normale, mais elle est compilée en C et s’exécute plus rapidement.\n\n\nAvantages de l’Utilisation de Cython\n\nPerformance : Le code Cython est généralement beaucoup plus rapide.\nInteropérabilité : Permet d’intégrer facilement des bibliothèques C/C++ dans des applications Python.\n\n\n\n\nConclusion\nLe typage en Python, avec ses différentes facettes - typage dynamique, type hinting, classes abstraites et Cython - offre une gamme variée d’outils pour augmenter la clarté, la performance et la structure du code. La compréhension de ces aspects est essentielle pour les développeurs Python afin de produire des codes efficaces, maintenables et performants.",
    "crumbs": [
      "Typage en Python"
    ]
  },
  {
    "objectID": "content/Cours_3/0-Install_and_import.html",
    "href": "content/Cours_3/0-Install_and_import.html",
    "title": "Installer et importer des librairies en Python",
    "section": "",
    "text": "1. Rappel sur les Bibliothèques Python\nDéfinition et Utilisation : Une bibliothèque Python est un ensemble de modules et de fonctions pré-écrits qui peuvent être importés dans un programme pour ajouter des fonctionnalités sans écrire de code supplémentaire. Ces bibliothèques sont essentielles pour étendre les capacités de Python au-delà de ses fonctionnalités de base.\nExemples Pratiques : - Importation et Utilisation de la Bibliothèque Mathématique (math) : epicapvrjelvmbcy   import math   print(math.sqrt(16))  # Affiche 4.0, la racine carrée de 16\n\nManipulation de Données avec Pandas :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nCes exemples montrent comment les bibliothèques standard comme math et des bibliothèques tierces comme pandas peuvent être utilisées pour effectuer des tâches complexes avec peu de code.\n\nImportance des Bibliothèques : Les bibliothèques Python sont au cœur de nombreuses applications, des analyses de données à la création de serveurs web. Elles permettent aux développeurs de se concentrer sur la logique spécifique de leur programme, en s’appuyant sur des outils fiables et bien testés pour des fonctions standard.\n\n\n2. Comprendre pip et PYTHONPATH\nFonctionnement de pip : pip est le gestionnaire de paquets par défaut pour Python. Il permet aux utilisateurs d’installer, de mettre à jour et de gérer des bibliothèques et des outils tiers disponibles sur le Python Package Index (PyPI). pip simplifie considérablement le processus d’installation des bibliothèques, en automatisant le téléchargement, la construction et l’installation des paquets.\nExemples d’Utilisation de pip : - Installation d’une bibliothèque : bash   pip install requests Cette commande installe la bibliothèque requests, utilisée pour effectuer des requêtes HTTP.\n\nMise à jour d’une bibliothèque :\npip install --upgrade numpy\nMet à jour la bibliothèque numpy à la dernière version disponible.\n\nInfluence de PYTHONPATH : PYTHONPATH est une variable d’environnement qui informe l’interpréteur Python des emplacements où chercher les modules lors de l’importation. Si un module est installé dans un répertoire qui n’est pas inclus dans PYTHONPATH, Python ne le trouvera pas, ce qui peut entraîner des erreurs d’importation.\nExemples de Configuration de PYTHONPATH : - Ajout d’un Chemin à PYTHONPATH sur Unix/Linux : bash   export PYTHONPATH=\"/chemin/vers/mon/module:$PYTHONPATH\" Ajoute “/chemin/vers/mon/module” au PYTHONPATH.\n\nAjout d’un Chemin à PYTHONPATH sur Windows :\nset PYTHONPATH=C:\\chemin\\vers\\mon\\module;%PYTHONPATH%\nAjoute “C:” au PYTHONPATH.\n\nImportance de Comprendre pip et PYTHONPATH : La compréhension de pip et de PYTHONPATH est cruciale pour gérer efficacement les dépendances dans les projets Python. Une bonne gestion des paquets et une configuration adéquate de PYTHONPATH permettent d’éviter les conflits de dépendances et les erreurs lors de l’exécution des programmes.\n\n\n3. Gestion de Plusieurs Versions de Python : Comprendre python -m pip vs pip\nContexte des Versions Multiples de Python : Dans un environnement où plusieurs versions de Python sont installées, il est essentiel de s’assurer que les commandes pip correspondent à la bonne version de Python. Cela est particulièrement vrai dans les systèmes où Python 2 et Python 3 coexistent, ou lorsqu’on utilise plusieurs sous-versions de Python 3.\nExplication de python -m pip vs pip : - pip seul : Lorsqu’on utilise la commande pip seule, elle fait référence au pip associé à la version de Python par défaut dans le chemin d’accès système (PATH). Cela peut conduire à des ambiguïtés si plusieurs versions de Python sont installées. - python -m pip : L’utilisation de -m est un indicateur pour Python d’exécuter le module de bibliothèque comme un script. Cela signifie que lorsque vous exécutez python -m pip, vous demandez explicitement à la version spécifique de Python (précédée de la commande) d’exécuter le module pip. Ainsi, python3.8 -m pip exécutera pip pour Python 3.8, indépendamment de la version de Python définie par défaut dans le chemin d’accès système.\nExemples Pratiques : - Installation avec une Version Spécifique : bash   python3.8 -m pip install requests Cette commande utilise pip associé à Python 3.8 pour installer la bibliothèque requests.\n\nDifférence dans l’Environnement :\npython3.6 -m pip --version\npython3.7 -m pip --version\nCes commandes affichent les versions de pip associées respectivement à Python 3.6 et 3.7, démontrant l’utilisation ciblée de pip pour différentes versions de Python.\n\nRésolution des Problèmes de Versions : L’usage de python -m pip est crucial dans des environnements multi-versions pour garantir que les bonnes versions de Python et de pip sont utilisées, évitant ainsi des problèmes de compatibilité et des erreurs de dépendances.\n\n\n4. Emplacements d’Installation des Bibliothèques en Python\nChemins d’Installation par Défaut : Lorsque des bibliothèques sont installées via pip, elles sont généralement placées dans le répertoire site-packages de l’installation Python concernée. Ce répertoire est spécifique à chaque version de Python sur le système. Par exemple, sous un système d’exploitation Windows, pour Python 3.9, le chemin par défaut serait C:\\Python39\\Lib\\site-packages.\nChemins d’Installation Personnalisés : Il est également possible de spécifier un chemin d’installation personnalisé pour les bibliothèques Python en utilisant l’option --target de pip. Cette méthode est utile pour installer des bibliothèques dans un environnement spécifique ou pour éviter des modifications globales sur le système.\nExemples d’Installation de Bibliothèques : - Installation Standard : bash   pip install requests Installe requests dans le répertoire site-packages par défaut de la version de Python utilisée.\n\nInstallation dans un Chemin Personnalisé :\npip install matplotlib --target=/mon/dossier/personnel\nInstalle matplotlib dans /mon/dossier/personnel.\n\nRôle de PYTHONPATH dans l’Installation : Si des bibliothèques sont installées dans un emplacement personnalisé, ce chemin doit être ajouté à PYTHONPATH pour que Python puisse trouver ces bibliothèques lors de l’importation. Sans cela, des erreurs d’importation peuvent survenir.\nExemple de Configuration de PYTHONPATH pour un Chemin Personnalisé : - Ajout d’un Chemin Personnalisé à PYTHONPATH sur Unix/Linux : bash   export PYTHONPATH=\"/mon/dossier/personnel:$PYTHONPATH\" Ajoute le chemin personnalisé au PYTHONPATH.\n\n\n5. Environnements Virtuels en Python\nDéfinition et Objectif des Environnements Virtuels : Un environnement virtuel en Python est un espace isolé qui permet d’installer et de gérer des bibliothèques pour des projets spécifiques, indépendamment des bibliothèques installées globalement sur le système. Cela évite les conflits entre les versions des bibliothèques requises par différents projets.\nCréation et Gestion des Environnements Virtuels : Pour créer un environnement virtuel, on utilise la commande python -m venv. Ceci crée un dossier contenant une installation Python indépendante. Dans cet environnement, vous pouvez installer, mettre à jour ou supprimer des bibliothèques sans affecter l’environnement global ou d’autres environnements virtuels.\nExemples d’Utilisation des Environnements Virtuels : - Création d’un Environnement Virtuel : bash   python -m venv mon_env Crée un nouvel environnement virtuel nommé mon_env.\n\nActivation d’un Environnement Virtuel :\n\nSous Windows : mon_env\\Scripts\\activate\nSous Unix ou MacOS : source mon_env/bin/activate\n\nCes commandes activent l’environnement virtuel, isolant ainsi les dépendances de projet.\nInstallation de Bibliothèques dans un Environnement Virtuel : Une fois l’environnement activé :\npip install flask\nInstalle flask uniquement dans l’environnement virtuel actif.\n\nAvantages des Environnements Virtuels : Les environnements virtuels offrent plusieurs avantages : - Isolation des Dépendances : Permet de gérer des dépendances spécifiques à chaque projet. - Prévention des Conflits : Évite les conflits entre les différentes versions des bibliothèques. - Facilité de Reproduction : Facilite la reproduction des environnements de développement et de production.\n\n\n6. Histoire et Évolution de la Gestion des Dépendances en Python\nProblèmes avec requirements.txt : Historiquement, la gestion des dépendances en Python s’effectuait principalement via un fichier requirements.txt. Ce fichier contenait une liste des bibliothèques nécessaires au projet. Cependant, requirements.txt avait des limitations, notamment en ce qui concerne la gestion des sous-dépendances (les dépendances des bibliothèques installées) et la spécification des versions.\nUn problème majeur était l’absence de reproductibilité : même en spécifiant les versions directes des dépendances, requirements.txt ne gérait pas toujours correctement les sous-dépendances. Deux installations du même requirements.txt pouvaient donc aboutir à des environnements légèrement différents, en raison de variations dans les versions des sous-dépendances.\nIntroduction de pipenv et poetry : Pour remédier à ces problèmes, des outils comme pipenv et poetry ont été développés. Ces outils offrent une approche plus holistique de la gestion des dépendances, en traitant non seulement les dépendances directes mais aussi les sous-dépendances.\npipenv : Pipenv utilise un Pipfile et un Pipfile.lock pour gérer les dépendances. Le Pipfile.lock joue un rôle crucial en enregistrant les versions exactes de toutes les dépendances et sous-dépendances, garantissant ainsi la reproductibilité des environnements.\npoetry : Poetry va plus loin en introduisant le fichier pyproject.toml. Ce fichier remplit plusieurs fonctions : - Gestion Globale des Dépendances : pyproject.toml permet de déclarer des dépendances de manière plus structurée et lisible. - Séparation des Dépendances de Développement : Poetry permet de distinguer les dépendances nécessaires pour l’exécution du projet (production) de celles nécessaires uniquement pour le développement (développement). Cela permet une meilleure gestion et une installation plus légère en production. - Facilité de Configuration : pyproject.toml sert également à configurer d’autres aspects du projet, comme les scripts de build et les métadonnées, centralisant ainsi la configuration.\nExemple avec poetry :\n[tool.poetry]\nname = \"mon_projet\"\nversion = \"0.1.0\"\ndescription = \"Un exemple de projet Python\"\n\n[tool.poetry.dependencies]\npython = \"^3.8\"\nrequests = \"^2.25.1\"\n\n[tool.poetry.dev-dependencies]\npytest = \"^6.2.2\"\nDans cet exemple, requests est une dépendance de production, tandis que pytest est une dépendance de développement, utilisée uniquement pendant la phase de test.\n\n\n7. Utilisation des Bibliothèques Importées\nPrincipes de Base de l’Importation en Python : Après avoir installé une bibliothèque, elle doit être importée dans votre script pour être utilisée. L’importation en Python est réalisée à l’aide du mot-clé import, suivi du nom de la bibliothèque. Cette étape est cruciale pour accéder aux fonctions, classes et méthodes que la bibliothèque offre.\nExemples Pratiques d’Importation et d’Utilisation de Bibliothèques : - Utilisation de la Bibliothèque Requests : epicapvrjelvmbcy   import requests   response = requests.get('https://www.example.com')   print(response.text) Dans cet exemple, requests est utilisée pour effectuer une requête HTTP vers un site web, et le contenu de la réponse est affiché.\n\nTravail avec Pandas :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIci, pandas est importé sous l’alias pd, et est utilisé pour lire un fichier CSV et afficher ses premières lignes.\n\nGestion des Importations en Cas de Conflits : Parfois, des noms de modules ou de fonctions peuvent entrer en conflit avec d’autres ou avec des noms réservés de Python. Dans ces cas, les alias peuvent être utilisés pour résoudre ces conflits, comme dans l’exemple avec pandas.\nImportance de Comprendre l’Importation : Comprendre comment importer et utiliser les bibliothèques est fondamental pour le développement en Python. Cela permet non seulement d’étendre les capacités du code, mais favorise également la réutilisation de code et le partage de fonctionnalités entre projets.\n\n\n\n\n Back to top",
    "crumbs": [
      "Installer et importer des librairies en Python"
    ]
  },
  {
    "objectID": "content/Cours_3/6-Visualisation.html",
    "href": "content/Cours_3/6-Visualisation.html",
    "title": "Visualiser et présenter ces données avec Python",
    "section": "",
    "text": "Visualisation de données avec Python\n\n\nChapitre sur la Visualisation de Données en Python\n\nIntroduction à la Visualisation de Données\nLa visualisation est un aspect crucial de l’analyse de données, aidant à comprendre les tendances, les modèles et les anomalies dans les données. Python offre une variété de bibliothèques de visualisation, chacune avec ses propres forces et cas d’utilisation.\n\n\nMatplotlib: Le Fondement de la Visualisation en Python\n\nMatplotlib est la bibliothèque de visualisation la plus connue et la plus utilisée en Python. Elle offre une grande flexibilité pour créer une large gamme de graphiques statiques, animés et interactifs.\nExemple d’utilisation :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nSeaborn: Visualisation Statistique Facilitée\n\nSeaborn est basé sur Matplotlib et fournit une interface de haut niveau pour dessiner des graphiques statistiques attractifs et informatifs.\nExemple de visualisation des relations entre variables :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nAltair: Déclaration Declarative pour la Visualisation\n\nAltair offre une API déclarative puissante pour construire des visualisations complexes de manière concise et intuitive.\nExemple simple d’un graphique à barres :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nPlotly: Visualisation Interactive et Avancée\n\nPlotly est remarquable pour ses graphiques interactifs et ses capacités de visualisation avancées, permettant des visualisations complexes et multi-dimensionnelles.\nExemple d’intégration avec Pandas pour une visualisation interactive :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nExercice Pratique\n\nObjectif: Créer un graphique interactif avec Plotly et l’intégrer à un DataFrame Pandas.\nÉnoncé: Utilisez Plotly pour créer un graphique à bulles interactif qui montre les relations entre différentes variables dans un DataFrame Pandas.\nSolution: Utilisez le code d’exemple Plotly fourni ci-dessus comme point de départ et ajustez-le en fonction de vos données spécifiques et des relations que vous souhaitez visualiser.\n\n\n\nConclusion\nLa visualisation de données est un élément essentiel de l’analyse de données, et Python offre une gamme impressionnante de bibliothèques pour créer des visualisations statiques, animées et interactives. Que vous cherchiez à produire des graphiques simples ou à explorer des visualisations interactives avancées, il existe une bibliothèque Python qui répond à vos besoins.\n\n\n\nTechniques Avancées de Visualisation de Données en Python\n\nCréation de Tableaux de Bord Interactifs\nLa capacité de créer des tableaux de bord interactifs permet une exploration en profondeur et dynamique des données.\n\nDash: Un framework Python pour créer des applications web analytiques.\n\nPermet de construire des tableaux de bord interactifs en utilisant uniquement Python.\nExemple :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nAnimation de Graphiques\nLes animations peuvent aider à comprendre les tendances et les modèles au fil du temps.\n\nMatplotlib pour les Animations:\n\nMatplotlib peut être utilisé pour créer des animations de base.\nExemple d’animation d’un graphique linéaire :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nIntégration de Visualisations dans des Applications Web\nL’intégration de graphiques dans des applications web rend les analyses de données plus accessibles et interactives.\n\nPlotly avec Flask ou Django:\n\nLes graphiques Plotly peuvent être intégrés dans des applications web Python utilisant Flask ou Django.\nExemple d’intégration Plotly avec Flask :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nindex.html contiendra le div pour afficher le graphique Plotly.\n\n\n\n\nConclusion\nLes techniques avancées de visualisation de données en Python, telles que la création de tableaux de bord interactifs avec Dash, l’animation de graphiques avec Matplotlib et l’intégration de visualisations dans des applications web, offrent des moyens puissants pour présenter et explorer des données complexes. Ces outils permettent aux utilisateurs de voir et d’interagir avec les données de manières innovantes, améliorant ainsi la compréhension et la prise de décisions basées sur les données.\n\n\n\nVisualisation de Données Géospatiales\n\nIntroduction à la Visualisation Géospatiale\nLa visualisation de données géospatiales implique la représentation de données ayant une composante géographique. Ces visualisations peuvent révéler des tendances et des modèles liés à l’emplacement.\n\n\nBibliothèques Clés pour la Visualisation Géospatiale\n\nGeopandas:\n\nExtension de Pandas pour faciliter le travail avec des données spatiales.\nPermet de lire, écrire et manipuler des données dans des formats géospatiaux variés.\nExemple d’utilisation de Geopandas :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nFolium:\n\nBibliothèque qui crée des cartes interactives à l’aide de la plateforme Leaflet.js.\nIdéal pour les visualisations géospatiales interactives dans les notebooks Jupyter.\nExemple simple avec Folium :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nVisualisation 3D avec Python\n\n\nOutils pour la Visualisation 3D\n\nMatplotlib:\n\nMatplotlib propose également des fonctionnalités de base pour la visualisation 3D.\nExemple de graphique en 3D :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlotly:\n\nPlotly excelle également dans la création de visualisations 3D interactives.\nExemple de surface 3D avec Plotly :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Visualiser et présenter ces données avec Python"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Feed_Internet.html",
    "href": "content/Cours_3/5-Feed_Internet.html",
    "title": "Python - Aussi un language pour servir des données",
    "section": "",
    "text": "Python est une langue de choix pour le développement web backend en raison de sa simplicité, de sa lisibilité et de la richesse de ses frameworks web. Ces frameworks facilitent la création d’applications web robustes et évolutives.\n\n\n\n\nDjango:\n\nUn framework web haut niveau qui encourage un développement rapide et propre. Il est idéal pour les projets de grande envergure grâce à sa structure “batteries incluses”.\nFonctionnalités clés :\n\nORM (Object-Relational Mapping) intégré\nSystème d’administration robuste\nSécurité renforcée\n\n\nFlask:\n\nUn micro-framework léger, flexible et plus adapté aux petits projets ou aux applications avec des exigences spécifiques.\nPoints forts :\n\nSimplicité et flexibilité\nFacilité de déploiement\nExtensible avec de nombreux plugins\n\n\nFastAPI:\n\nUn framework moderne, rapide (basé sur Starlette et Pydantic) pour construire des API avec Python 3.7+. Il est conçu pour être facile à utiliser tout en offrant des performances élevées.\nAvantages :\n\nSupport natif pour les requêtes asynchrones\nGénération automatique de documentation (Swagger UI)\nValidation de données et sérialisation\n\n\n\n\n\n\n\nObjectif: Créer une simple API avec Flask.\nÉnoncé: Développez une API RESTful qui renvoie “Hello, World!” à chaque requête GET sur le chemin racine.\nSolution:\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nSécurité : Protéger les applications contre les attaques courantes telles que l’injection SQL, le cross-site scripting (XSS) et le cross-site request forgery (CSRF).\nGestion des Dépendances : Utiliser des environnements virtuels et gérer les dépendances pour assurer la cohérence des projets.\nTest et Débogage : Écrire des tests unitaires et utiliser des outils de débogage pour maintenir la qualité du code.\n\n\n\n\nLe développement web backend en Python, grâce à des frameworks comme Django, Flask et FastAPI, offre une grande flexibilité et une base solide pour construire des applications web. Que vous construisiez une simple application web ou une API complexe, Python a les outils et les bibliothèques nécessaires pour répondre aux besoins de votre projet.\n\n\n\n\n\n\nFastAPI est un framework moderne et rapide pour la construction d’APIs avec Python, qui offre une performance élevée et une écriture de code rapide et efficace. Il est particulièrement apprécié pour sa facilité d’intégration avec les systèmes asynchrones et ses fonctionnalités automatiques de documentation.\n\n\n\n\nCréation d’une API CRUD (Create, Read, Update, Delete):\n\nFastAPI simplifie la création d’APIs CRUD, qui sont essentielles dans de nombreuses applications web pour gérer les données.\nExemple de base : ```uhcsrqtdfhjqcgxo from fastapi import FastAPI from pydantic import BaseModel\n\n\napp = FastAPI()\nclass Item(BaseModel): name: str description: str = None price: float tax: float = None\n@app.post(“/items/”) async def create_item(item: Item): return item\n@app.get(“/items/{item_id}”) async def read_item(item_id: int): return {“item_id”: item_id} ```\n\nIntégration avec des Bases de Données:\n\nFastAPI peut être facilement intégré avec des bases de données comme PostgreSQL, MySQL, ou MongoDB.\nUtilisation avec SQLAlchemy (pour les bases de données SQL) :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nValidation et Sérialisation des Données:\n\nFastAPI utilise Pydantic pour la validation des données entrantes et la sérialisation des données sortantes.\nExemple avec un modèle Pydantic :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nAuthentification et Sécurité:\n\nFastAPI fournit plusieurs outils pour l’authentification et la gestion de la sécurité, y compris OAuth2.\nExemple d’authentification basique :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\nFastAPI est un outil extrêmement puissant pour la création d’APIs modernes en Python. Sa facilité d’utilisation, sa performance élevée, et ses fonctionnalités intégrées comme la documentation automatique, la validation des données, et les fonctionnalités de sécurité, en font un choix idéal pour les développeurs souhaitant créer des APIs robustes et efficaces.\n\n\n\n\n\n\nLa mise en cache est une technique cruciale pour améliorer les performances des applications web en réduisant le temps de réponse des requêtes répétitives.\n\nMise en Cache avec Redis:\n\nRedis, en tant que magasin de données en mémoire, est souvent utilisé pour le cache dans les applications web.\nUtilisation avec FastAPI :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\nLe traitement asynchrone est essentiel pour gérer les opérations I/O sans bloquer le serveur, en particulier dans les applications Web hautement scalables.\n\nUtilisation de async et await avec FastAPI:\n\nFastAPI prend en charge la programmation asynchrone native, ce qui permet de gérer facilement les requêtes asynchrones.\nExemple de requête asynchrone :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\nLa capacité à gérer une charge croissante de requêtes est un facteur clé pour le succès des applications web.\n\nUtilisation de Serveurs Asynchrones:\n\nDes serveurs tels que Uvicorn ou Hypercorn offrent des performances accrues pour les applications asynchrones en Python.\nExemple de déploiement avec Uvicorn :\nuvicorn myapp:app --host 0.0.0.0 --port 8000\n\nLoad Balancing:\n\nLe load balancing, avec des outils comme Nginx ou HAProxy, est crucial pour distribuer efficacement le trafic entre plusieurs instances de votre application.\n\nOptimisation des Bases de Données:\n\nUtiliser des techniques comme l’indexation, les requêtes optimisées et les pools de connexions pour améliorer les performances des bases de données.\n\n\n\n\n\nL’intégration web en Python, en utilisant des technologies telles que FastAPI, Redis, et des serveurs asynchrones, offre des moyens efficaces pour créer des applications web performantes et scalables. Les pratiques telles que la mise en cache, le traitement asynchrone, et la scalabilité sont essentielles pour répondre aux exigences des applications web modernes.",
    "crumbs": [
      "Python - Aussi un language pour servir des données"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Feed_Internet.html#introduction-au-développement-web-backend-avec-python",
    "href": "content/Cours_3/5-Feed_Internet.html#introduction-au-développement-web-backend-avec-python",
    "title": "Python - Aussi un language pour servir des données",
    "section": "",
    "text": "Python est une langue de choix pour le développement web backend en raison de sa simplicité, de sa lisibilité et de la richesse de ses frameworks web. Ces frameworks facilitent la création d’applications web robustes et évolutives.",
    "crumbs": [
      "Python - Aussi un language pour servir des données"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Feed_Internet.html#frameworks-web-python-populaires",
    "href": "content/Cours_3/5-Feed_Internet.html#frameworks-web-python-populaires",
    "title": "Python - Aussi un language pour servir des données",
    "section": "",
    "text": "Django:\n\nUn framework web haut niveau qui encourage un développement rapide et propre. Il est idéal pour les projets de grande envergure grâce à sa structure “batteries incluses”.\nFonctionnalités clés :\n\nORM (Object-Relational Mapping) intégré\nSystème d’administration robuste\nSécurité renforcée\n\n\nFlask:\n\nUn micro-framework léger, flexible et plus adapté aux petits projets ou aux applications avec des exigences spécifiques.\nPoints forts :\n\nSimplicité et flexibilité\nFacilité de déploiement\nExtensible avec de nombreux plugins\n\n\nFastAPI:\n\nUn framework moderne, rapide (basé sur Starlette et Pydantic) pour construire des API avec Python 3.7+. Il est conçu pour être facile à utiliser tout en offrant des performances élevées.\nAvantages :\n\nSupport natif pour les requêtes asynchrones\nGénération automatique de documentation (Swagger UI)\nValidation de données et sérialisation",
    "crumbs": [
      "Python - Aussi un language pour servir des données"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Feed_Internet.html#exercice-pratique",
    "href": "content/Cours_3/5-Feed_Internet.html#exercice-pratique",
    "title": "Python - Aussi un language pour servir des données",
    "section": "",
    "text": "Objectif: Créer une simple API avec Flask.\nÉnoncé: Développez une API RESTful qui renvoie “Hello, World!” à chaque requête GET sur le chemin racine.\nSolution:\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Python - Aussi un language pour servir des données"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Feed_Internet.html#bonnes-pratiques-de-développement-web-backend",
    "href": "content/Cours_3/5-Feed_Internet.html#bonnes-pratiques-de-développement-web-backend",
    "title": "Python - Aussi un language pour servir des données",
    "section": "",
    "text": "Sécurité : Protéger les applications contre les attaques courantes telles que l’injection SQL, le cross-site scripting (XSS) et le cross-site request forgery (CSRF).\nGestion des Dépendances : Utiliser des environnements virtuels et gérer les dépendances pour assurer la cohérence des projets.\nTest et Débogage : Écrire des tests unitaires et utiliser des outils de débogage pour maintenir la qualité du code.",
    "crumbs": [
      "Python - Aussi un language pour servir des données"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Feed_Internet.html#conclusion",
    "href": "content/Cours_3/5-Feed_Internet.html#conclusion",
    "title": "Python - Aussi un language pour servir des données",
    "section": "",
    "text": "Le développement web backend en Python, grâce à des frameworks comme Django, Flask et FastAPI, offre une grande flexibilité et une base solide pour construire des applications web. Que vous construisiez une simple application web ou une API complexe, Python a les outils et les bibliothèques nécessaires pour répondre aux besoins de votre projet.",
    "crumbs": [
      "Python - Aussi un language pour servir des données"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Feed_Internet.html#introduction-à-fastapi",
    "href": "content/Cours_3/5-Feed_Internet.html#introduction-à-fastapi",
    "title": "Python - Aussi un language pour servir des données",
    "section": "",
    "text": "FastAPI est un framework moderne et rapide pour la construction d’APIs avec Python, qui offre une performance élevée et une écriture de code rapide et efficace. Il est particulièrement apprécié pour sa facilité d’intégration avec les systèmes asynchrones et ses fonctionnalités automatiques de documentation.",
    "crumbs": [
      "Python - Aussi un language pour servir des données"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Feed_Internet.html#exemples-dutilisation-de-fastapi",
    "href": "content/Cours_3/5-Feed_Internet.html#exemples-dutilisation-de-fastapi",
    "title": "Python - Aussi un language pour servir des données",
    "section": "",
    "text": "Création d’une API CRUD (Create, Read, Update, Delete):\n\nFastAPI simplifie la création d’APIs CRUD, qui sont essentielles dans de nombreuses applications web pour gérer les données.\nExemple de base : ```uhcsrqtdfhjqcgxo from fastapi import FastAPI from pydantic import BaseModel\n\n\napp = FastAPI()\nclass Item(BaseModel): name: str description: str = None price: float tax: float = None\n@app.post(“/items/”) async def create_item(item: Item): return item\n@app.get(“/items/{item_id}”) async def read_item(item_id: int): return {“item_id”: item_id} ```\n\nIntégration avec des Bases de Données:\n\nFastAPI peut être facilement intégré avec des bases de données comme PostgreSQL, MySQL, ou MongoDB.\nUtilisation avec SQLAlchemy (pour les bases de données SQL) :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nValidation et Sérialisation des Données:\n\nFastAPI utilise Pydantic pour la validation des données entrantes et la sérialisation des données sortantes.\nExemple avec un modèle Pydantic :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nAuthentification et Sécurité:\n\nFastAPI fournit plusieurs outils pour l’authentification et la gestion de la sécurité, y compris OAuth2.\nExemple d’authentification basique :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Python - Aussi un language pour servir des données"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Feed_Internet.html#conclusion-1",
    "href": "content/Cours_3/5-Feed_Internet.html#conclusion-1",
    "title": "Python - Aussi un language pour servir des données",
    "section": "",
    "text": "FastAPI est un outil extrêmement puissant pour la création d’APIs modernes en Python. Sa facilité d’utilisation, sa performance élevée, et ses fonctionnalités intégrées comme la documentation automatique, la validation des données, et les fonctionnalités de sécurité, en font un choix idéal pour les développeurs souhaitant créer des APIs robustes et efficaces.",
    "crumbs": [
      "Python - Aussi un language pour servir des données"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Feed_Internet.html#mise-en-cache-pour-améliorer-les-performances",
    "href": "content/Cours_3/5-Feed_Internet.html#mise-en-cache-pour-améliorer-les-performances",
    "title": "Python - Aussi un language pour servir des données",
    "section": "",
    "text": "La mise en cache est une technique cruciale pour améliorer les performances des applications web en réduisant le temps de réponse des requêtes répétitives.\n\nMise en Cache avec Redis:\n\nRedis, en tant que magasin de données en mémoire, est souvent utilisé pour le cache dans les applications web.\nUtilisation avec FastAPI :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Python - Aussi un language pour servir des données"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Feed_Internet.html#traitement-asynchrone-des-données",
    "href": "content/Cours_3/5-Feed_Internet.html#traitement-asynchrone-des-données",
    "title": "Python - Aussi un language pour servir des données",
    "section": "",
    "text": "Le traitement asynchrone est essentiel pour gérer les opérations I/O sans bloquer le serveur, en particulier dans les applications Web hautement scalables.\n\nUtilisation de async et await avec FastAPI:\n\nFastAPI prend en charge la programmation asynchrone native, ce qui permet de gérer facilement les requêtes asynchrones.\nExemple de requête asynchrone :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Python - Aussi un language pour servir des données"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Feed_Internet.html#scalabilité-et-performance",
    "href": "content/Cours_3/5-Feed_Internet.html#scalabilité-et-performance",
    "title": "Python - Aussi un language pour servir des données",
    "section": "",
    "text": "La capacité à gérer une charge croissante de requêtes est un facteur clé pour le succès des applications web.\n\nUtilisation de Serveurs Asynchrones:\n\nDes serveurs tels que Uvicorn ou Hypercorn offrent des performances accrues pour les applications asynchrones en Python.\nExemple de déploiement avec Uvicorn :\nuvicorn myapp:app --host 0.0.0.0 --port 8000\n\nLoad Balancing:\n\nLe load balancing, avec des outils comme Nginx ou HAProxy, est crucial pour distribuer efficacement le trafic entre plusieurs instances de votre application.\n\nOptimisation des Bases de Données:\n\nUtiliser des techniques comme l’indexation, les requêtes optimisées et les pools de connexions pour améliorer les performances des bases de données.",
    "crumbs": [
      "Python - Aussi un language pour servir des données"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Feed_Internet.html#conclusion-2",
    "href": "content/Cours_3/5-Feed_Internet.html#conclusion-2",
    "title": "Python - Aussi un language pour servir des données",
    "section": "",
    "text": "L’intégration web en Python, en utilisant des technologies telles que FastAPI, Redis, et des serveurs asynchrones, offre des moyens efficaces pour créer des applications web performantes et scalables. Les pratiques telles que la mise en cache, le traitement asynchrone, et la scalabilité sont essentielles pour répondre aux exigences des applications web modernes.",
    "crumbs": [
      "Python - Aussi un language pour servir des données"
    ]
  },
  {
    "objectID": "content/Cours_3/index.html",
    "href": "content/Cours_3/index.html",
    "title": "Les Librairies Python",
    "section": "",
    "text": "Les cours de cette partie sont:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCalcul Scientifique et Optimization\n\n\nNumpy, Scipy, pour ne cité qu’eux\n\n\n\nRemi Genet\n\n\n2025-01-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInstaller et importer des librairies en Python\n\n\nRappel sur les bibliothèques Python, la gestion des paquets et les environnements virtuels\n\n\n\nRemi Genet\n\n\n2025-01-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLes DataFrames\n\n\nLes DataFrames\n\n\n\nRemi Genet\n\n\n2025-01-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMachine Learning\n\n\nPython, où le ML à deux cliques de souris\n\n\n\nRemi Genet\n\n\n2025-01-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython - Aussi un language pour servir des données\n\n\nDjango, FastAPI, Flask, Bottle, Pyramid, Falcon, Sanic, Tornado, AIOHTTP, Starlette,… La liste est longue\n\n\n\nRemi Genet\n\n\n2025-01-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRecupérer des données du net\n\n\nRequête HTTP, Webscrapping, websockets, API, JSON, XML, CSV, HTML, SQL, NoSQL, FTP, SSH, …\n\n\n\nRemi Genet\n\n\n2025-01-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTP-3 Libraries\n\n\nMise en pratique simple des éléments vu aurparavant.\n\n\n\nRemi Genet\n\n\n2025-01-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVisualiser et présenter ces données avec Python\n\n\nMatplotlib, Plotly ou Seaborn ? Peut être Altair !\n\n\n\nRemi Genet\n\n\n2025-01-29\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to top",
    "crumbs": [
      "Les Librairies Python"
    ]
  },
  {
    "objectID": "content/Cours_3/4-Access_Internet.html",
    "href": "content/Cours_3/4-Access_Internet.html",
    "title": "Recupérer des données du net",
    "section": "",
    "text": "Recupérer des données du net\n\n\nChapitre sur l’Accès à Internet en Python\n\nIntroduction à l’Accès Internet en Python\nPython fournit plusieurs bibliothèques pour interagir avec le Web, permettant des opérations telles que le scraping de données, les requêtes Web, et l’interaction avec les API.\n\n\nBibliothèques Clés pour l’Accès à Internet\n\nRequests: Une bibliothèque Python simplifiée pour envoyer des requêtes HTTP. Elle est idéale pour interagir avec des API RESTful.\n\nExemple d’utilisation :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nBeautiful Soup: Utilisée pour le web scraping, Beautiful Soup permet d’analyser le contenu HTML et d’extraire les données nécessaires.\n\nExemple de scraping :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nScrapy: Un framework puissant pour créer des crawlers Web. Il est utilisé pour des scrapings plus complexes et des bots d’indexation.\n\nUtilisation typique :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nExercice Pratique\n\nObjectif: Se familiariser avec les requêtes Web et le scraping en Python.\nÉnoncé: Écrivez un script qui récupère les titres des dernières nouvelles d’un site d’actualités et les affiche.\nSolution:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nSécurité et Bonnes Pratiques\n\nRespecter les règles du robots.txt: S’assurer de respecter les directives du fichier robots.txt des sites Web lors du scraping.\nGestion des erreurs et des exceptions: Traiter correctement les réponses HTTP, comme les erreurs 404 ou 503.\nUtiliser des headers de requête appropriés: Inclure des informations d’en-tête comme User-Agent pour éviter d’être bloqué par les sites Web.\n\n\n\nConclusion\nL’accès à Internet en Python, grâce à des bibliothèques comme Requests, Beautiful Soup et Scrapy, offre un potentiel immense pour collecter et traiter des données du Web. Que ce soit pour des tâches simples comme récupérer des données d’une API ou pour des projets de scraping Web plus complexes, Python fournit les outils nécessaires pour interagir efficacement avec le Web.\n\nDans le prochain chapitre, nous explorerons comment Python peut être utilisé pour “alimenter” le Web, en se concentrant sur les frameworks Web et le développement backend en Python.\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Recupérer des données du net"
    ]
  },
  {
    "objectID": "content/Projets/index.html",
    "href": "content/Projets/index.html",
    "title": "Projets",
    "section": "",
    "text": "Les cours de cette partie sont:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nProjets Introduction à Python - Millésime 2024\n\n\n\n\n\n\nRemi Genet\n\n\n2025-01-29\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to top",
    "crumbs": [
      "Projets"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "La syntaxe de Python est conçue pour être lisible et concise. Comprendre ses particularités peut vous aider à écrire du code plus efficace et expressif.\n\n\n\nExpressions : En Python, chaque ligne de code est généralement une expression, par exemple a = 5 ou print(a).\nIndentations : Python utilise l’indentation pour définir des blocs de code. Contrairement à d’autres langages qui utilisent des accolades, l’indentation en Python n’est pas seulement pour la lisibilité mais est syntaxiquement significative.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nEn Python, les commentaires commencent par #. Tout ce qui suit # sur la ligne est ignoré par l’interpréteur.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nNB: L’utilisation du # est utilisé dans de nombreux langages de programmation, comme le C, le C++, le Java, le PHP, le Perl, le Ruby, le Python, etc. pour définir les commentaires\n\n\n\n\n\nNombres : Python supporte int, float, et plus rarement utilisés, complex.\nChaînes de Caractères : Déclarées avec des guillemets simples 'texte' ou doubles \"texte\". Le + peut concaténer des chaînes.\nBooléens : True et False. Intéressant, en Python, 0, None, un string vide '', et les collections vides comme [], {} sont considérés comme équivalents à False.\n\n\n\n\n\n\nLes variables en Python sont des identificateurs liés à des valeurs. Elles ne nécessitent pas de déclaration explicite de type.\n\n\n\nLes noms de variables doivent commencer par une lettre ou un underscore _, suivis de lettres, chiffres, ou underscores.\nLes conventions de nommage courantes incluent snake_case pour les variables et fonctions, CamelCase pour les classes.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\nPython offre une gamme complète d’opérateurs arithmétiques (+, -, *, /, // pour la division entière, % pour le modulo, ** pour la puissance) et de comparaison (==, !=, &gt;, &lt;, &gt;=, &lt;=).\n\n\n\n\n\nLes opérateurs logiques incluent and, or, et not.\n\n\n\n\n\nOpérateurs Bitwise : Opèrent sur des bits et incluent & (ET), | (OU), ^ (XOR), ~ (NON), &lt;&lt; (décalage à gauche), &gt;&gt; (décalage à droite).\nOpérateur d’Identité : is et is not vérifient si deux variables pointent vers le même objet.\nOpérateur d’Appartenance : in et not in vérifient si une valeur est présente dans une séquence.\n\n\n\n\n\n\nLes structures de contrôle en Python permettent d’exécuter conditionnellement des blocs de code ou de répéter des opérations.\n\n\n\nif, else, elif permettent d’exécuter des blocs de code basés sur des conditions.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\nBoucle For : Itère sur une séquence (comme une liste, un tuple, un dictionnaire, un ensemble, ou une chaîne de caractères).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nBoucle While : Continue à exécuter un bloc de code tant qu’une condition est vraie.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nCompréhensions de Liste\n\nUne façon concise de créer des listes. Par exemple, [x for x in range(10)] crée une liste des nombres de 0 à 9.\n\n\n\n\n\n\nLa gestion des erreurs est cruciale pour écrire des applications robustes. Python fournit un mécanisme de gestion des exceptions pour gérer les erreurs de manière contrôlée.\n\n\n\nUn bloc try permet de tester un bloc de code pour les erreurs, et le bloc except permet de gérer l’erreur.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nVous pouvez spécifier plusieurs blocs except pour gérer différentes exceptions.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nLe bloc finally est facultatif et exécuté quel que soit le résultat des blocs try et except.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nVoyons comment on peut combiner les concepts abordés précédemment dans un exemple pratique. Cet exemple utilise une boucle while, une instruction conditionnelle if, et gère une éventuelle exception.\n\n\nImaginons un scénario où nous avons deux variables x et y. Nous voulons exécuter une boucle qui continue tant que la somme de x et y est supérieure à 8. Dans la boucle, nous effectuons une opération qui peut potentiellement lever une exception.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nDans cet exemple, la boucle while continue de s’exécuter tant que la condition x + y &gt; 8 est vraie. Si x est impair, le code essaie de diviser par zéro, ce qui lève une ZeroDivisionError. Dans ce cas, le message d’erreur est imprimé, et le mot-clé break interrompt la boucle. Le bloc finally est exécuté après chaque itération, peu importe les erreurs.\n\n\n\n\nPython offre plusieurs structures de données intégrées, comme les listes et les tuples, qui sont essentielles pour le stockage et la manipulation de données.\n\n\n\nLes listes en Python sont des collections ordonnées et modifiables. Elles peuvent contenir des éléments de différents types.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nOpérations de Base sur les Listes :\n\nAjout d’éléments (append, extend).\nSuppression d’éléments (remove, pop).\nAccès et slicing (ma_liste[0], ma_liste[1:3]).\n\n\n\n\n\n\nLes tuples sont similaires aux listes, mais ils sont immuables (leurs valeurs ne peuvent pas être modifiées après leur création).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nUtilisés pour des données qui ne doivent pas être modifiées, comme les clés dans les dictionnaires.\n\n\n\n\n\nLes dictionnaires et les ensembles sont des structures de données puissantes pour stocker et gérer des ensembles de données.\n\n\n\nLes dictionnaires stockent des paires clé-valeur. Ils sont mutables et non ordonnés.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nManipulation de Dictionnaires :\n\nAjout et modification d’éléments (mon_dictionnaire[\"nom\"] = \"Bob\").\nSuppression d’éléments (del mon_dictionnaire[\"age\"], mon_dictionnaire.pop(\"langage\")).\nAccès sécurisé (get).\n\n\n\n\n\n\nLes ensembles sont des collections non ordonnées de valeurs uniques. Utiles pour les opérations mathématiques comme les unions, intersections, et différences.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nOpérations sur les Ensembles :\n\nAjout (add) et suppression (remove) d’éléments.\nOpérations comme union, intersection, et difference.\n\n\n\n\n\n\nVoyons comment combiner listes, tuples, dictionnaires et ensembles dans un exemple pratique.\n\n\nSupposons que nous avons une liste de tuples, chaque tuple contenant le nom d’un étudiant et son score. Nous voulons créer un dictionnaire où chaque clé est un score unique, et la valeur est la liste des noms d’étudiants ayant ce score.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nDans cet exemple, nous parcourons la liste etudiants. Pour chaque tuple, nous vérifions si le score est déjà une clé dans le dictionnaire scores. Si ce n’est pas le cas, nous ajoutons une nouvelle clé avec le score et initialisons sa valeur avec une liste contenant le nom de l’étudiant. Si le score existe déjà, nous ajoutons simplement le nom de l’étudiant à la liste correspondante.\n\n\n\n\n\nLes compréhensions en Python sont un moyen concis et puissant de créer de nouvelles listes, dictionnaires ou ensembles à partir de séquences ou d’autres structures itérables.\n\n\n\nLes compréhensions de liste fournissent une façon concise de créer des listes. Elles consistent en une expression suivie par une clause for, puis zéro ou plusieurs clauses for ou if.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\nSemblables aux compréhensions de liste, mais créent des dictionnaires. Elles sont entourées de {} avec une paire clé-valeur suivie d’une clause for.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\nUtilisées pour créer des ensembles de manière similaire aux compréhensions de liste, mais avec des éléments uniques.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\nLes compréhensions peuvent être particulièrement utiles pour transformer et filtrer des données. Voici un exemple qui utilise des compréhensions de liste et de dictionnaire pour traiter des données.\n\n\nImaginons que nous avons une liste de mots et que nous voulons créer un dictionnaire qui associe chaque mot à sa longueur, mais seulement pour les mots de plus de trois lettres.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nDans cet exemple, la compréhension de dictionnaire parcourt la liste mots, incluant uniquement les mots dont la longueur dépasse trois lettres. Pour chaque mot éligible, le dictionnaire longueur_mots est construit avec le mot comme clé et sa longueur comme valeur.\n\n\n\n\nLes opérateurs ternaires et les expressions lambda en Python offrent des moyens concis d’effectuer des opérations conditionnelles et de créer de petites fonctions anonymes.\n\n\n\nLes opérateurs ternaires permettent d’écrire des instructions conditionnelles en une seule ligne. La syntaxe est : [valeur_si_vrai] if [condition] else [valeur_si_faux].\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\nLes expressions lambda permettent de créer de petites fonctions anonymes. Elles sont utiles pour des opérations simples nécessitant une fonction.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\nPython fournit des outils puissants pour manipuler des listes, des tuples et d’autres séquences de manière expressive.\n\n\n\nLe slicing permet de sélectionner des sous-parties d’une séquence. En plus des bases, Python permet des slicings plus complexes.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\nLes listes et dictionnaires peuvent être imbriqués pour créer des structures de données complexes.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\nPour conclure ce chapitre, combinons plusieurs des concepts abordés dans un exemple illustrant leur utilité pratique.\n\n\nSupposons que nous avons une liste de dictionnaires représentant des livres, et nous voulons extraire les titres des livres publiés après 2000.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nDans cet exemple, une compréhension de liste est utilisée pour parcourir livres, en extrayant le titre de chaque livre dont l’année est supérieure à 2000. Cela démontre comment les compréhensions de liste peuvent être utilisées pour filtrer et transformer des données de manière concise et lisible. ```\nPour vous entrainez à pratiquer ces notions:\n Telecharger le premier jeu d'exercice \n Telecharger le premier second d'exercice",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.1-les-bases-de-la-syntaxe-python",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.1-les-bases-de-la-syntaxe-python",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "La syntaxe de Python est conçue pour être lisible et concise. Comprendre ses particularités peut vous aider à écrire du code plus efficace et expressif.\n\n\n\nExpressions : En Python, chaque ligne de code est généralement une expression, par exemple a = 5 ou print(a).\nIndentations : Python utilise l’indentation pour définir des blocs de code. Contrairement à d’autres langages qui utilisent des accolades, l’indentation en Python n’est pas seulement pour la lisibilité mais est syntaxiquement significative.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nEn Python, les commentaires commencent par #. Tout ce qui suit # sur la ligne est ignoré par l’interpréteur.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nNB: L’utilisation du # est utilisé dans de nombreux langages de programmation, comme le C, le C++, le Java, le PHP, le Perl, le Ruby, le Python, etc. pour définir les commentaires\n\n\n\n\n\nNombres : Python supporte int, float, et plus rarement utilisés, complex.\nChaînes de Caractères : Déclarées avec des guillemets simples 'texte' ou doubles \"texte\". Le + peut concaténer des chaînes.\nBooléens : True et False. Intéressant, en Python, 0, None, un string vide '', et les collections vides comme [], {} sont considérés comme équivalents à False.",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.2-variables-et-opérateurs",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.2-variables-et-opérateurs",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "Les variables en Python sont des identificateurs liés à des valeurs. Elles ne nécessitent pas de déclaration explicite de type.\n\n\n\nLes noms de variables doivent commencer par une lettre ou un underscore _, suivis de lettres, chiffres, ou underscores.\nLes conventions de nommage courantes incluent snake_case pour les variables et fonctions, CamelCase pour les classes.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\nPython offre une gamme complète d’opérateurs arithmétiques (+, -, *, /, // pour la division entière, % pour le modulo, ** pour la puissance) et de comparaison (==, !=, &gt;, &lt;, &gt;=, &lt;=).\n\n\n\n\n\nLes opérateurs logiques incluent and, or, et not.\n\n\n\n\n\nOpérateurs Bitwise : Opèrent sur des bits et incluent & (ET), | (OU), ^ (XOR), ~ (NON), &lt;&lt; (décalage à gauche), &gt;&gt; (décalage à droite).\nOpérateur d’Identité : is et is not vérifient si deux variables pointent vers le même objet.\nOpérateur d’Appartenance : in et not in vérifient si une valeur est présente dans une séquence.",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.3-structures-de-contrôle",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.3-structures-de-contrôle",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "Les structures de contrôle en Python permettent d’exécuter conditionnellement des blocs de code ou de répéter des opérations.\n\n\n\nif, else, elif permettent d’exécuter des blocs de code basés sur des conditions.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\nBoucle For : Itère sur une séquence (comme une liste, un tuple, un dictionnaire, un ensemble, ou une chaîne de caractères).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nBoucle While : Continue à exécuter un bloc de code tant qu’une condition est vraie.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nCompréhensions de Liste\n\nUne façon concise de créer des listes. Par exemple, [x for x in range(10)] crée une liste des nombres de 0 à 9.",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.4-gestion-des-erreurs-et-exceptions",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.4-gestion-des-erreurs-et-exceptions",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "La gestion des erreurs est cruciale pour écrire des applications robustes. Python fournit un mécanisme de gestion des exceptions pour gérer les erreurs de manière contrôlée.\n\n\n\nUn bloc try permet de tester un bloc de code pour les erreurs, et le bloc except permet de gérer l’erreur.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nVous pouvez spécifier plusieurs blocs except pour gérer différentes exceptions.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nLe bloc finally est facultatif et exécuté quel que soit le résultat des blocs try et except.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.5-exemple-concret-mélangeant-les-concepts",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.5-exemple-concret-mélangeant-les-concepts",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "Voyons comment on peut combiner les concepts abordés précédemment dans un exemple pratique. Cet exemple utilise une boucle while, une instruction conditionnelle if, et gère une éventuelle exception.\n\n\nImaginons un scénario où nous avons deux variables x et y. Nous voulons exécuter une boucle qui continue tant que la somme de x et y est supérieure à 8. Dans la boucle, nous effectuons une opération qui peut potentiellement lever une exception.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nDans cet exemple, la boucle while continue de s’exécuter tant que la condition x + y &gt; 8 est vraie. Si x est impair, le code essaie de diviser par zéro, ce qui lève une ZeroDivisionError. Dans ce cas, le message d’erreur est imprimé, et le mot-clé break interrompt la boucle. Le bloc finally est exécuté après chaque itération, peu importe les erreurs.",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.6-structures-de-données-de-base---listes-et-tuples",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.6-structures-de-données-de-base---listes-et-tuples",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "Python offre plusieurs structures de données intégrées, comme les listes et les tuples, qui sont essentielles pour le stockage et la manipulation de données.\n\n\n\nLes listes en Python sont des collections ordonnées et modifiables. Elles peuvent contenir des éléments de différents types.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nOpérations de Base sur les Listes :\n\nAjout d’éléments (append, extend).\nSuppression d’éléments (remove, pop).\nAccès et slicing (ma_liste[0], ma_liste[1:3]).\n\n\n\n\n\n\nLes tuples sont similaires aux listes, mais ils sont immuables (leurs valeurs ne peuvent pas être modifiées après leur création).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nUtilisés pour des données qui ne doivent pas être modifiées, comme les clés dans les dictionnaires.",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.7-structures-de-données-de-base---dictionnaires-et-ensembles",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.7-structures-de-données-de-base---dictionnaires-et-ensembles",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "Les dictionnaires et les ensembles sont des structures de données puissantes pour stocker et gérer des ensembles de données.\n\n\n\nLes dictionnaires stockent des paires clé-valeur. Ils sont mutables et non ordonnés.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nManipulation de Dictionnaires :\n\nAjout et modification d’éléments (mon_dictionnaire[\"nom\"] = \"Bob\").\nSuppression d’éléments (del mon_dictionnaire[\"age\"], mon_dictionnaire.pop(\"langage\")).\nAccès sécurisé (get).\n\n\n\n\n\n\nLes ensembles sont des collections non ordonnées de valeurs uniques. Utiles pour les opérations mathématiques comme les unions, intersections, et différences.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nOpérations sur les Ensembles :\n\nAjout (add) et suppression (remove) d’éléments.\nOpérations comme union, intersection, et difference.",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.8-exemple-pratique-mélangeant-les-structures-de-données",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.8-exemple-pratique-mélangeant-les-structures-de-données",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "Voyons comment combiner listes, tuples, dictionnaires et ensembles dans un exemple pratique.\n\n\nSupposons que nous avons une liste de tuples, chaque tuple contenant le nom d’un étudiant et son score. Nous voulons créer un dictionnaire où chaque clé est un score unique, et la valeur est la liste des noms d’étudiants ayant ce score.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nDans cet exemple, nous parcourons la liste etudiants. Pour chaque tuple, nous vérifions si le score est déjà une clé dans le dictionnaire scores. Si ce n’est pas le cas, nous ajoutons une nouvelle clé avec le score et initialisons sa valeur avec une liste contenant le nom de l’étudiant. Si le score existe déjà, nous ajoutons simplement le nom de l’étudiant à la liste correspondante.",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.9-compréhensions-de-liste-de-dictionnaire-et-densemble",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.9-compréhensions-de-liste-de-dictionnaire-et-densemble",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "Les compréhensions en Python sont un moyen concis et puissant de créer de nouvelles listes, dictionnaires ou ensembles à partir de séquences ou d’autres structures itérables.\n\n\n\nLes compréhensions de liste fournissent une façon concise de créer des listes. Elles consistent en une expression suivie par une clause for, puis zéro ou plusieurs clauses for ou if.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\nSemblables aux compréhensions de liste, mais créent des dictionnaires. Elles sont entourées de {} avec une paire clé-valeur suivie d’une clause for.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\nUtilisées pour créer des ensembles de manière similaire aux compréhensions de liste, mais avec des éléments uniques.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.10-exemple-concret-utilisant-les-compréhensions",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.10-exemple-concret-utilisant-les-compréhensions",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "Les compréhensions peuvent être particulièrement utiles pour transformer et filtrer des données. Voici un exemple qui utilise des compréhensions de liste et de dictionnaire pour traiter des données.\n\n\nImaginons que nous avons une liste de mots et que nous voulons créer un dictionnaire qui associe chaque mot à sa longueur, mais seulement pour les mots de plus de trois lettres.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nDans cet exemple, la compréhension de dictionnaire parcourt la liste mots, incluant uniquement les mots dont la longueur dépasse trois lettres. Pour chaque mot éligible, le dictionnaire longueur_mots est construit avec le mot comme clé et sa longueur comme valeur.",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.11-opérateurs-ternaires-et-expressions-lambda",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.11-opérateurs-ternaires-et-expressions-lambda",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "Les opérateurs ternaires et les expressions lambda en Python offrent des moyens concis d’effectuer des opérations conditionnelles et de créer de petites fonctions anonymes.\n\n\n\nLes opérateurs ternaires permettent d’écrire des instructions conditionnelles en une seule ligne. La syntaxe est : [valeur_si_vrai] if [condition] else [valeur_si_faux].\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\nLes expressions lambda permettent de créer de petites fonctions anonymes. Elles sont utiles pour des opérations simples nécessitant une fonction.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.12-techniques-avancées-de-manipulation-de-séquences",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.12-techniques-avancées-de-manipulation-de-séquences",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "Python fournit des outils puissants pour manipuler des listes, des tuples et d’autres séquences de manière expressive.\n\n\n\nLe slicing permet de sélectionner des sous-parties d’une séquence. En plus des bases, Python permet des slicings plus complexes.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\nLes listes et dictionnaires peuvent être imbriqués pour créer des structures de données complexes.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.13-exemple-pratique-combinant-plusieurs-concepts",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.13-exemple-pratique-combinant-plusieurs-concepts",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "Pour conclure ce chapitre, combinons plusieurs des concepts abordés dans un exemple illustrant leur utilité pratique.\n\n\nSupposons que nous avons une liste de dictionnaires représentant des livres, et nous voulons extraire les titres des livres publiés après 2000.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nDans cet exemple, une compréhension de liste est utilisée pour parcourir livres, en extrayant le titre de chaque livre dont l’année est supérieure à 2000. Cela démontre comment les compréhensions de liste peuvent être utilisées pour filtrer et transformer des données de manière concise et lisible. ```\nPour vous entrainez à pratiquer ces notions:\n Telecharger le premier jeu d'exercice \n Telecharger le premier second d'exercice",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/3.1-ExerciceClass.html",
    "href": "content/Cours_2/3.1-ExerciceClass.html",
    "title": "Base de la POO: Exercice",
    "section": "",
    "text": "Vous avez un fichier CSV contenant l’historique des opérations des clients d’une société. Le fichier a les colonnes suivantes : date, client_id, op_type, op_data. - date : format texte “yyyy-mm-dd” - client_id : un entier identifiant le client - op_type : type d’opération, peut être ‘create_account’, ‘deposit’, ‘withdraw’, ‘trade’ - op_data : - null pour ‘create_account’ - un montant pour ‘deposit’ et ‘withdraw’ - un dictionnaire pour ‘trade’ contenant ‘side’, ‘ticker’, ‘price’, ‘volume’\nVotre tâche est de créer un moyen de récupérer facilement le montant en dollars d’un client et les actions qu’il détient avec leur quantité. Cela nécessitera la lecture des données depuis le fichier CSV, le traitement des différentes opérations, et la mise à jour des informations de chaque client.\n\n\n\n\nClasse Client pour représenter chaque client avec son solde et son portefeuille d’actions.\nFonctions pour lire le fichier CSV, traiter chaque opération et mettre à jour les informations des clients.\n\nInstructions: - Complétez le code de la classe Client et les fonctions nécessaires. - Utilisez l’exemple de contenu CSV fourni pour tester votre code.",
    "crumbs": [
      "Travaux Pratiques",
      "Base de la POO: Exercice"
    ]
  },
  {
    "objectID": "content/Cours_2/3.1-ExerciceClass.html#objectif",
    "href": "content/Cours_2/3.1-ExerciceClass.html#objectif",
    "title": "Base de la POO: Exercice",
    "section": "",
    "text": "Vous avez un fichier CSV contenant l’historique des opérations des clients d’une société. Le fichier a les colonnes suivantes : date, client_id, op_type, op_data. - date : format texte “yyyy-mm-dd” - client_id : un entier identifiant le client - op_type : type d’opération, peut être ‘create_account’, ‘deposit’, ‘withdraw’, ‘trade’ - op_data : - null pour ‘create_account’ - un montant pour ‘deposit’ et ‘withdraw’ - un dictionnaire pour ‘trade’ contenant ‘side’, ‘ticker’, ‘price’, ‘volume’\nVotre tâche est de créer un moyen de récupérer facilement le montant en dollars d’un client et les actions qu’il détient avec leur quantité. Cela nécessitera la lecture des données depuis le fichier CSV, le traitement des différentes opérations, et la mise à jour des informations de chaque client.",
    "crumbs": [
      "Travaux Pratiques",
      "Base de la POO: Exercice"
    ]
  },
  {
    "objectID": "content/Cours_2/3.1-ExerciceClass.html#structure-du-code",
    "href": "content/Cours_2/3.1-ExerciceClass.html#structure-du-code",
    "title": "Base de la POO: Exercice",
    "section": "",
    "text": "Classe Client pour représenter chaque client avec son solde et son portefeuille d’actions.\nFonctions pour lire le fichier CSV, traiter chaque opération et mettre à jour les informations des clients.\n\nInstructions: - Complétez le code de la classe Client et les fonctions nécessaires. - Utilisez l’exemple de contenu CSV fourni pour tester votre code.",
    "crumbs": [
      "Travaux Pratiques",
      "Base de la POO: Exercice"
    ]
  },
  {
    "objectID": "content/Cours_2/index.html",
    "href": "content/Cours_2/index.html",
    "title": "Syntaxes et Concepts de Base",
    "section": "",
    "text": "Les cours de cette partie sont:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBase de la POO: Exercice\n\n\n\n\n\n\nRemi Genet\n\n\n2025-01-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercices d’applications\n\n\n\n\n\n\nRemi Genet\n\n\n2025-01-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFonctions et Modules\n\n\nCe chapitre se concentre sur les fonctions et les modules en Python, deux composants clés pour écrire un code propre et réutilisable. Il aborde la création de fonctions, la…\n\n\n\nRemi Genet\n\n\n2025-01-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction à la POO en Python\n\n\nDans ce chapitre, nous explorons les principes fondamentaux de la Programmation Orientée Objet (POO) en Python. Les étudiants découvriront comment Python applique les…\n\n\n\nRemi Genet\n\n\n2025-01-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSyntaxe et objets de Base Python\n\n\nCe chapitre offre une plongée approfondie dans la syntaxe et les objets de base de Python. Il vise à fournir une compréhension solide des fondements du langage, couvrant…\n\n\n\nRemi Genet\n\n\n2025-01-29\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to top",
    "crumbs": [
      "Syntaxes et Concepts de Base"
    ]
  },
  {
    "objectID": "content/Cours_5/2-POO_le_retour.html",
    "href": "content/Cours_5/2-POO_le_retour.html",
    "title": "Python Orienté Objet - Les Dunders",
    "section": "",
    "text": "POO - Python Orienté Objet - Introduction aux dunder\n\n\nLes Objets en Python et les Méthodes Dunder\n\nNature des Objets en Python:\n\nDéfinition d’un Objet: Un objet en Python est une entité qui contient des données ainsi que des méthodes pour traiter ces données. Chaque élément en Python, qu’il s’agisse d’une donnée simple comme un nombre ou une chaîne de caractères, ou de structures plus complexes comme des listes ou des fonctions, est un objet.\nClasses et Instances: Chaque objet est une instance d’une classe. Une classe est un modèle qui définit les attributs (données) et les méthodes (fonctions) que ses instances possèderont.\n\nRôle des Méthodes Dunder:\n\nIdentification des Méthodes Dunder: Les méthodes Dunder (ou méthodes magiques) sont identifiables par leur double underscore de part et d’autre du nom (par exemple, __init__ ou __str__).\nFonctionnalités des Méthodes Dunder: Ces méthodes ont des responsabilités spéciales en Python. Par exemple, __init__ est utilisée pour initialiser de nouvelles instances d’une classe, __str__ est appelée lorsqu’une représentation sous forme de chaîne de l’objet est requise.\nPersonnalisation du Comportement: Les méthodes Dunder permettent de définir comment une instance d’une classe se comporte avec les opérateurs Python intégrés (comme +, -, *, etc.).\n\nUniformité et Cohérence:\n\nManipulation Homogène des Objets: Grâce aux méthodes Dunder, Python assure que les objets, qu’ils soient intégrés ou définis par l’utilisateur, se comportent de manière cohérente avec les opérateurs et fonctions intégrés.\n\n\n\n\n\nPartie 2: Avantages et Coûts en Termes de Performances et de Mémoire\n\nGestion Efficace des Types de Données Complexes\n\nPrécision des Opérations:\n\nGestion des Nombres en Python: Python traite les nombres avec une précision quasi-infinie, contrairement à des langages comme C/C++, où la précision est limitée par la taille des types de données primitifs. Cela permet à Python de gérer efficacement de grandes valeurs numériques et des calculs de haute précision.\n\nCréation de Structures Complexes:\n\nFlexibilité des Objets Python: L’utilisation des méthodes Dunder en combinaison avec la flexibilité des types en Python facilite la création de structures de données complexes comme des arbres, des graphes, ou des structures algébriques personnalisées.\n\n\n\n\nCoût en Termes de Performances et de Mémoire\n\nConsommation de Mémoire:\n\nGestion des Objets: La manipulation des objets en Python, en particulier pour les types de données complexes, peut entraîner une utilisation plus importante de la mémoire par rapport à des langages de bas niveau.\n\nImpact sur les Performances:\n\nSurcharge des Opérations: La flexibilité de Python, bien qu’avantageuse pour la facilité de programmation, peut conduire à une surcharge en termes de performances. Par exemple, les opérations arithmétiques simples comme l’addition ou la multiplication peuvent être plus coûteuses en ressources comparées à leur équivalent en langage C, en raison de la gestion des objets et de la vérification des types.\n\n\n\n\n\n\nPartie 3: Exemple Concret d’Utilisation des Méthodes Dunder\n\nCréation d’une Classe de Nombre Complexe\n\nDéfinition de la Classe:\n\nClasse ComplexNumber: La classe ComplexNumber représente un nombre complexe avec une partie réelle (real) et une partie imaginaire (imag).\n\nMéthodes Dunder Implémentées:\n\nMéthode __init__: Initialise une nouvelle instance de ComplexNumber avec les valeurs fournies pour real et imag.\nMéthode __add__: Permet l’addition de deux instances de ComplexNumber. Elle définit comment l’opérateur + fonctionne pour cette classe.\nMéthode __repr__: Fournit une représentation sous forme de chaîne de caractères de l’instance, utile pour l’affichage ou le débogage.\n\nCode d’Exemple:\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nConclusion\nLes méthodes Dunder en Python offrent une puissance et une flexibilité incroyables pour la conception d’objets et de classes. Elles permettent une manipulation intuitive et élégante de types de données complexes et la création de structures sophistiquées. Bien que cette approche puisse avoir un impact sur les performances et la consommation de mémoire, elle rend Python extrêmement puissant et adapté à une vaste gamme d’applications.\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Python Orienté Objet - Les Dunders"
    ]
  },
  {
    "objectID": "content/Cours_5/TP5.html",
    "href": "content/Cours_5/TP5.html",
    "title": "TP-5",
    "section": "",
    "text": "En reprenant le code du TP précédent pour obtenir des données:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nL’objectif de ce TP est d’appliquer les compétences en programmation Python et en analyse financière pour la récupération, l’analyse et la gestion de données de marché. Utilisant la classe développée dans la séance précédente, les étudiants effectueront des calculs statistiques et construiront un simulateur de portefeuille d’investissement.\n\n\n\nUtilisation de Pandas pour Calculer la Volatilité :\n\nAppliquer la méthode rolling de Pandas pour calculer la volatilité des actifs individuels. Les étudiants utiliseront les données récupérées via la classe BinanceSpotDataGathererSmart pour calculer la volatilité sur une fenêtre temporelle définie.\n\nCombinaison des DataFrames de Volatilité :\n\nFusionner les différentes DataFrames contenant les volatilités calculées pour chaque actif. Cette étape est cruciale pour la comparaison et l’analyse croisée des différentes volatilités d’actifs.\n\nCalcul de la Matrice de Covariance et du Rendement Moyen :\n\nUtiliser les données combinées pour calculer la matrice de covariance entre les actifs. Cette matrice est essentielle pour comprendre la relation et la corrélation entre différents investissements.\nCalculer également le rendement moyen des différents actifs pour avoir une vue d’ensemble de la performance.\n\nCréation d’une Classe Portefeuille :\n\nDévelopper une classe Portefeuille qui permet de gérer des investissements en dollars ($). Cette classe doit pouvoir contenir les proportions de plusieurs actifs, et implementer des méthodes afin de calculer la volatilité, le rendement, et le ratio de Sharpe du portefeuille à partir de la matrice de covariance.\n\nImplémentation des Méthodes de Gestion de Portefeuille :\n\nImplémenter les méthodes magiques (__add__, etc.) pour permettre la combinaison de différents portefeuilles.\nImplementer __str__ our __repr__ pour afficher les informations du portefeuille.",
    "crumbs": [
      "Travaux Pratiques",
      "TP-5"
    ]
  },
  {
    "objectID": "content/Cours_5/TP5.html#objectif-principal-du-tp",
    "href": "content/Cours_5/TP5.html#objectif-principal-du-tp",
    "title": "TP-5",
    "section": "",
    "text": "L’objectif de ce TP est d’appliquer les compétences en programmation Python et en analyse financière pour la récupération, l’analyse et la gestion de données de marché. Utilisant la classe développée dans la séance précédente, les étudiants effectueront des calculs statistiques et construiront un simulateur de portefeuille d’investissement.\n\n\n\nUtilisation de Pandas pour Calculer la Volatilité :\n\nAppliquer la méthode rolling de Pandas pour calculer la volatilité des actifs individuels. Les étudiants utiliseront les données récupérées via la classe BinanceSpotDataGathererSmart pour calculer la volatilité sur une fenêtre temporelle définie.\n\nCombinaison des DataFrames de Volatilité :\n\nFusionner les différentes DataFrames contenant les volatilités calculées pour chaque actif. Cette étape est cruciale pour la comparaison et l’analyse croisée des différentes volatilités d’actifs.\n\nCalcul de la Matrice de Covariance et du Rendement Moyen :\n\nUtiliser les données combinées pour calculer la matrice de covariance entre les actifs. Cette matrice est essentielle pour comprendre la relation et la corrélation entre différents investissements.\nCalculer également le rendement moyen des différents actifs pour avoir une vue d’ensemble de la performance.\n\nCréation d’une Classe Portefeuille :\n\nDévelopper une classe Portefeuille qui permet de gérer des investissements en dollars ($). Cette classe doit pouvoir contenir les proportions de plusieurs actifs, et implementer des méthodes afin de calculer la volatilité, le rendement, et le ratio de Sharpe du portefeuille à partir de la matrice de covariance.\n\nImplémentation des Méthodes de Gestion de Portefeuille :\n\nImplémenter les méthodes magiques (__add__, etc.) pour permettre la combinaison de différents portefeuilles.\nImplementer __str__ our __repr__ pour afficher les informations du portefeuille.",
    "crumbs": [
      "Travaux Pratiques",
      "TP-5"
    ]
  },
  {
    "objectID": "content/Cours_5/1-AST.html",
    "href": "content/Cours_5/1-AST.html",
    "title": "L’arbre Syntaxique Abstrait ou AST",
    "section": "",
    "text": "L’arbre Syntaxique Abstrait - Comment revoir ses bases en Python\n\n\nCours sur la Bibliothèque Standard Python et l’Abstract Syntax Tree (AST)\n\nPartie 1: La Valeur de la Bibliothèque Standard Python\n\nIntroduction à la Bibliothèque Standard\nLa bibliothèque standard Python est une collection riche et variée de modules et de fonctions intégrées qui sont automatiquement disponibles dans tout environnement Python. Elle couvre une large gamme de fonctionnalités, des opérations mathématiques aux interactions réseau.\n\n\nPourquoi Utiliser la Bibliothèque Standard\n\nFiabilité : Les modules de la bibliothèque standard sont bien testés et maintenus.\nPortabilité : Le code qui utilise la bibliothèque standard est généralement portable sur toutes les plateformes où Python est disponible.\nPerformance : Certains modules sont implémentés en C, offrant des performances optimales.\nProductivité : Permet de se concentrer sur les aspects uniques du projet, plutôt que de réinventer la roue.\n\n\n\nExemples de Modules Utiles\n\nos et sys pour les interactions système.\nre pour les expressions régulières.\ndatetime pour la manipulation de dates et d’heures.\njson, csv pour la manipulation de fichiers et de données.\n\nEn plus des modules de base, la bibliothèque standard Python offre des outils avancés pour des tâches spécifiques.\nasyncio :\n    Gère la programmation asynchrone, permettant d'écrire du code concurrent en utilisant la syntaxe async/await.\n    Utilisation pour des applications I/O-bound et pour améliorer les performances dans les applications réseau.\n\nthreading et multiprocessing :\n    threading est utilisé pour la programmation multithread, utile pour l'exécution concurrente de plusieurs tâches.\n    multiprocessing permet l'exécution parallèle de code en utilisant plusieurs processus, évitant ainsi le Global Interpreter Lock (GIL) de Python.\n\nfunctools :\n    Fournit des outils pour manipuler les fonctions. La fonction cache (dans Python 3.9+, lru_cache dans les versions antérieures) est particulièrement utile pour mémoriser les résultats des appels de fonctions coûteux.\nExemple d’Utilisation de functools.cache\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nLe résultat de fibonacci étant mis en cache le nombre d’appel réel à la fonction est réduit de façon drastique, et le temps d’execution est réduit de facon supra-linéaire.\n\n\nPartie 2: Abstract Syntax Tree (AST) en Python\n\nQu’est-ce que l’AST ?\nL’Abstract Syntax Tree (AST) est une représentation en arbre de la structure syntaxique du code source dans un langage de programmation. En Python, le module ast permet d’interagir et de manipuler ces arbres syntaxiques.\n\n\nUtilisations de l’AST\n\nAnalyse de Code : Permet d’examiner et de comprendre la structure du code.\nModification de Code : On peut transformer le code source avant son exécution.\nCréation d’Outils d’Analyse Statique : Construire des outils personnalisés pour analyser le style ou la qualité du code.\n\n\n\nExemple Simple avec AST\nimport ast\n\ncode = \"\"\"\ndef add(a, b):\n    return a + b\n\"\"\"\n\n# Parse le code source en AST\nparsed_code = ast.parse(code)\n\n# Parcourir et afficher les nœuds de l'AST\nfor node in ast.walk(parsed_code):\n    print(type(node))\n\n\nPourquoi Utiliser l’AST ?\n\nCompréhension Approfondie du Langage : Travailler avec l’AST nécessite une compréhension des éléments syntaxiques de Python, ce qui enrichit la connaissance du langage.\nDéveloppement de Compétences en Analyse de Code : L’AST est au cœur des outils d’analyse statique, et sa manipulation peut développer des compétences avancées en analyse de code.\n\n\n\nProjet avec AST\n\nProjet Suggéré : Créer un outil d’analyse statique simple ou un reformateur de code en utilisant l’AST.\nAvantages : Ce type de projet offre une compréhension pratique de la structure du code Python et peut être un excellent ajout à un portfolio de développeur.\n\n\n\nExemple de Manipulation de l’AST\nimport ast\nimport astor\n\nclass PrintReplacer(ast.NodeTransformer):\n    def visit_Print(self, node):\n        return ast.Expr(value=ast.Call(func=ast.Name(id='print', ctx=ast.Load()), \n                                       args=node.values, keywords=[]))\n\nsource_code = \"\"\"\nprint \"Hello, World!\"\n\"\"\"\n\ntree = ast.parse(source_code)\ntree = PrintReplacer().visit(tree)\nprint(astor.to_source(tree))  # Convertit l'AST modifié en code source\n\n\n\n\nPartie 3: AST pour la Transformation et l’Optimisation du Code\n\nModification du Code avec AST\n\nRefactoring : L’AST permet de refactoriser le code de manière programmatique, ce qui est utile pour les grandes bases de code.\nOptimisation : Peut être utilisé pour identifier et appliquer des optimisations de code.\n\n\n\nExemple d’Optimisation avec AST\nimport astor\n\nclass MyTransformer(ast.NodeTransformer):\n    def visit_BinOp(self, node):\n        if isinstance(node.op, ast.Add):\n            return ast.BinOp(left=node.left, op=ast.Sub(), right=node.right)\n        return node\n\ntree = ast.parse(\"x + y\")\ntransformed = MyTransformer().visit(tree)\nprint(astor.to_source(transformed))  # Affiche \"x - y\"\n\n\n\nConclusion\nLa bibliothèque standard Python est un trésor de fonctionnalités, offrant des outils pour presque toutes les tâches imaginables en programmation. Comprendre et utiliser efficacement ces outils est essentiel pour tout développeur Python. De plus, explorer l’AST et ses applications peut non seulement renforcer la compréhension du langage Python, mais aussi ouvrir la voie à des projets intéressants et éducatifs, tout en développant des compétences en analyse de code.\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "L'arbre Syntaxique Abstrait ou AST"
    ]
  },
  {
    "objectID": "content/Cours_1/7-Notebooks.html",
    "href": "content/Cours_1/7-Notebooks.html",
    "title": "Les Notebooks",
    "section": "",
    "text": "7. Les Notebooks Jupyter\n\nDifférence entre les Fichiers .py et .ipynb et la Notion de Notebook\nLa distinction entre les fichiers .py et .ipynb est fondamentale dans l’écosystème Python, en particulier pour les tâches de développement et d’analyse de données.\n\nFichiers .py:\n\nNature: Les fichiers .py sont des scripts Python traditionnels. Ils contiennent du code Python pur pouvant être exécuté par l’interpréteur Python.\nUtilisation: Ces fichiers sont généralement utilisés pour le développement d’applications, de scripts, ou de modules Python.\nIDEs et Éditeurs: Ils peuvent être ouverts et exécutés dans n’importe quel éditeur de texte ou IDE comme PyCharm, Visual Studio Code, ou Spyder.\n\nFichiers .ipynb et Notebooks:\n\nNature: Les fichiers avec l’extension .ipynb sont des notebooks Jupyter. Ils permettent de combiner du code exécutable, du texte enrichi (Markdown), des équations (LaTeX), des visualisations et des médias interactifs.\nUtilisation: Ces notebooks sont largement utilisés dans la data science et l’enseignement pour leur capacité à présenter le code, les résultats, et les explications de manière interactive et attrayante.\nEnvironnement: Ils nécessitent un environnement Jupyter pour être exécutés, comme Jupyter Notebook ou JupyterLab.\n\nLa Notion de Notebook:\n\nUn “notebook” est un document numérique qui permet de créer et de partager des documents contenant du code, du texte explicatif, des formules mathématiques et des visualisations.\nLes notebooks sont interactifs : vous pouvez exécuter le code dans des cellules individuelles et voir les résultats immédiatement sous ces cellules, ce qui facilite grandement l’exploration de données et les analyses ad hoc.\n\n\nEn résumé, la différence principale entre .py et .ipynb réside dans leur approche du développement et de la présentation du code. Les fichiers .py sont mieux adaptés pour le développement de logiciels structurés, tandis que les fichiers .ipynb sont idéaux pour l’exploration de données, l’analyse interactive et la documentation de processus.\n\n\nPrésentation de Jupyter\nJupyter est un projet open source qui permet de créer et de partager des documents contenant du code en direct, des équations, des visualisations et du texte narratif. Il est particulièrement populaire dans la data science, l’enseignement des sciences informatiques, et la recherche scientifique. Voici les aspects clés de Jupyter :\n\nJupyter Notebook:\n\nNature et Fonctionnalités : Jupyter Notebook est une application web qui permet de créer et de partager des documents contenant du code interactif (notamment Python), des équations, des visualisations, et du texte explicatif.\nUtilisation : Idéal pour la data science et l’analyse exploratoire, il facilite la visualisation des données et la communication des résultats.\nInteractivité : Les utilisateurs peuvent exécuter le code dans des cellules individuelles, voir les résultats immédiatement, et apporter des modifications en temps réel.\n\nJupyterLab:\n\nÉvolution de Jupyter Notebook : JupyterLab est une interface utilisateur de nouvelle génération pour le projet Jupyter. Il offre toutes les fonctionnalités de Jupyter Notebook, avec une interface plus flexible et extensible.\nInterface Améliorée : Il propose une interface utilisateur modulaire, où les notebooks, les éditeurs de texte, les terminaux, les visualisations de données et d’autres composants peuvent être disposés dans un espace de travail unique.\nExtensions et Personnalisations : JupyterLab permet d’ajouter des extensions, ce qui augmente sa fonctionnalité et sa flexibilité.\n\nSupport Multilingue:\n\nBien que Python soit le langage le plus couramment utilisé, Jupyter supporte de nombreux autres langages de programmation grâce au concept de “kernels”. Un kernel est un moteur de calcul qui exécute le code contenu dans le notebook.\n\nPartage et Collaboration:\n\nLes notebooks Jupyter peuvent être partagés via email, Dropbox, GitHub et Jupyter Notebook Viewer.\nIls facilitent la collaboration et sont souvent utilisés dans l’enseignement et la recherche scientifique pour partager des expériences, des analyses et des rapports.\n\n\nJupyter est devenu un outil incontournable dans les domaines de la data science et de l’éducation en raison de sa capacité à combiner code, données, et narration dans un format interactif et facilement partageable. Son approche modulaire et extensible avec JupyterLab le rend encore plus puissant pour des projets de développement et de recherche complexes.\n\n\nAutres Options pour le Développement Interactif: Google Colab et Alternatives\nOutre Jupyter, il existe d’autres plateformes populaires pour le développement interactif, particulièrement dans le domaine de la data science et du machine learning. Google Colab est l’une des plus remarquables.\n\nGoogle Colab:\n\nNature et Fonctionnalités: Google Colab est un service gratuit hébergé par Google qui permet aux utilisateurs de créer et de partager des documents similaires à Jupyter Notebooks. Il est basé sur Jupyter et offre un environnement Python complet.\nIntégration avec Google Drive: Colab est intégré avec Google Drive, facilitant le partage, l’accès et la collaboration sur des notebooks.\nRessources de Calcul Gratuites: Il offre l’accès à des ressources de calcul gratuites, y compris des GPU et des TPU, ce qui le rend populaire pour les projets de machine learning et de deep learning.\nEnvironnement Préconfiguré: Colab vient préchargé avec de nombreuses bibliothèques populaires, ce qui facilite la mise en place et la réalisation de projets de data science.\n\nAutres Alternatives:\n\nDatabricks Community Edition: Plateforme basée sur le cloud qui offre un environnement similaire à Jupyter pour l’exécution de notebooks Spark. Elle est utile pour les analyses de données à grande échelle.\nKaggle Kernels: Offre un environnement similaire à Jupyter Notebook avec l’accès gratuit à des GPU et TPU. Il est intégré à la plateforme Kaggle, permettant aux utilisateurs de travailler sur des datasets complexes et de participer à des compétitions de data science.\nAzure Notebooks: Service proposé par Microsoft, similaire à Jupyter Notebooks, mais intégré dans l’écosystème Azure. Il permet de créer, de partager et de gérer des notebooks dans le cloud.\n\nChoix de la Plateforme:\n\nLe choix entre ces différentes plateformes dépend de plusieurs facteurs tels que les ressources de calcul nécessaires, la facilité de partage et de collaboration, l’intégration avec d’autres services et outils, et les préférences personnelles ou organisationnelles.\n\n\nCes plateformes offrent une flexibilité et des fonctionnalités puissantes pour le développement interactif, l’exploration de données, et le machine learning, rendant l’analyse de données et la recherche scientifique plus accessibles et collaboratives.\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Les Notebooks"
    ]
  },
  {
    "objectID": "content/Cours_1/5-PathandVirtualEnv.html",
    "href": "content/Cours_1/5-PathandVirtualEnv.html",
    "title": "Path.. et environnements virtuels!",
    "section": "",
    "text": "PATH et les Environnements Virtuels avec Pyenv\nPyenv est un outil populaire pour la gestion des versions de Python. Il permet aux développeurs d’installer et de basculer facilement entre plusieurs versions de Python sur un même système. Cette flexibilité est particulièrement utile dans des environnements de développement où différents projets nécessitent différentes versions de Python.\n\n\nPartie 1 : Pyenv et la Gestion de Versions Python\n\nIntroduction à Pyenv\nPyenv est un outil populaire pour la gestion des versions de Python. Il permet aux développeurs d’installer et de basculer facilement entre plusieurs versions de Python sur un même système. Cette flexibilité est particulièrement utile dans des environnements de développement où différents projets nécessitent différentes versions de Python.\n\n\nFonctionnement de Pyenv\n\nInstallation et Configuration :\n\nL’installation de pyenv implique l’ajout d’un script d’initialisation dans le fichier de configuration du shell (comme .bashrc, .zshrc).\nCe script ajuste la variable PATH pour inclure un chemin vers les shims de pyenv.\n\nLes Shims de Pyenv :\n\nLes shims sont des scripts intermédiaires qui interceptent les appels à Python et redirigent vers la version appropriée.\nLorsqu’un utilisateur exécute python, le shim de pyenv est appelé, qui détermine ensuite quelle version de Python doit être utilisée.\n\nGestion des Versions Python :\n\nPyenv permet de définir une version globale de Python pour l’ensemble du système ou des versions locales pour des répertoires spécifiques.\nLes versions de Python sont gérées en modifiant la variable PATH via les shims, permettant un basculement facile entre différentes versions.\n\nAvantages de Pyenv :\n\nFlexibilité et facilité de basculement entre différentes versions de Python.\nGestion aisée des dépendances spécifiques aux versions pour des projets variés.\nSolution idéale pour tester et développer des applications compatibles avec différentes versions de Python.\n\n\n\n\nInteraction de Pyenv avec PATH\nPyenv modifie PATH pour prioriser ses shims, qui redirigent ensuite les appels à Python vers la version spécifique configurée. Cette manipulation de PATH est au cœur de la fonctionnalité de pyenv, permettant une gestion transparente de multiples versions de Python.\n\n\n\nPYTHONPATH et Son Rôle dans la Configuration Python\n\nIntroduction à PYTHONPATH\nPYTHONPATH est une variable d’environnement utilisée par Python pour déterminer quels répertoires le système doit inclure dans le front-end de son chemin de recherche de modules. C’est une extension de la variable sys.path, qui est une liste de chaînes de caractères définissant les chemins d’accès pour les modules Python.\n\n\nFonctionnement de PYTHONPATH\n\nPrincipes de Base :\n\nQuand Python démarre, il initialise sys.path avec les emplacements par défaut pour les modules standard et les répertoires de site-packages.\nPYTHONPATH permet d’ajouter des répertoires supplémentaires où Python recherchera des modules à importer.\n\nUtilisation de PYTHONPATH :\n\nLes développeurs peuvent ajouter des chemins de répertoires personnalisés à PYTHONPATH pour rendre leurs modules ou packages personnalisés accessibles à travers tout le système.\nCela est utile quand les modules ne sont pas installés dans les répertoires standards.\n\nModification de PYTHONPATH :\n\nSous Windows, PYTHONPATH peut être modifié via les variables d’environnement dans les propriétés système.\nSous Linux et MacOS, on peut modifier PYTHONPATH en ajoutant export PYTHONPATH=/chemin/de/votre/module:$PYTHONPATH dans les fichiers de configuration du shell comme .bashrc ou .bash_profile.\n\nImplications de PYTHONPATH :\n\nUne bonne gestion de PYTHONPATH est essentielle pour s’assurer que les scripts Python accèdent aux bons modules et packages.\nUn PYTHONPATH mal configuré peut entraîner des conflits de modules ou des erreurs d’importation.\n\n\n\n\nDistinction entre PYTHONPATH et PATH\nBien que PATH et PYTHONPATH soient des variables d’environnement, elles servent des buts différents : - PATH est utilisé par le système d’exploitation pour localiser les fichiers exécutables. - PYTHONPATH est spécifique à Python et indique à l’interpréteur où chercher les modules pour les importations.\n\n\nGestionnaires de Bibliothèques et Environnements Virtuels: Pipenv et Poetry\nAu-delà de la gestion des versions de Python, la gestion des bibliothèques et des dépendances est un autre aspect crucial du développement Python. Deux outils populaires dans ce domaine sont Pipenv et Poetry. Voici comment ils fonctionnent et interagissent avec la notion de PATH : ### Partie 3 : Pipenv - Gestion des Bibliothèques et Environnements Virtuels\n\n\nIntroduction à Pipenv\nPipenv est un outil de gestion pour les projets Python qui combine la gestion des packages avec la gestion des environnements virtuels. Il est conçu pour offrir un workflow simplifié pour le développement de projets Python.\n\n\nFonctionnement de Pipenv\n\nGestion des Dépendances :\n\nPipenv utilise le fichier Pipfile pour déclarer les dépendances de projet, remplaçant les traditionnels requirements.txt.\nPipfile.lock est généré pour verrouiller les versions exactes des dépendances, assurant ainsi la reproductibilité des environnements.\n\nCréation d’Environnements Virtuels :\n\nLorsqu’un projet est initié avec Pipenv (par pipenv install), il crée automatiquement un environnement virtuel dédié à ce projet.\nCela isole les dépendances du projet des autres projets et du système global.\n\nActivation des Environnements Virtuels :\n\nPour activer l’environnement virtuel de Pipenv, utilisez la commande pipenv shell.\nCette action ajuste temporairement la variable PATH pour que les commandes python et pip fassent référence à l’environnement virtuel spécifique du projet.\n\nAvantages de Pipenv :\n\nSimplification de la gestion des dépendances et des environnements virtuels.\nAmélioration de la reproductibilité et de la cohérence entre les environnements de développement et de production.\nFacilité d’utilisation et intégration avec des outils de développement modernes.\n\n\n\n\nInteraction de Pipenv avec PATH\nLorsqu’un environnement virtuel est activé avec Pipenv, PATH est modifié pour que toutes les commandes Python soient redirigées vers l’interpréteur et les bibliothèques de l’environnement virtuel spécifique du projet. Cela garantit que les bonnes versions des packages sont utilisées et que les dépendances de projet sont isolées des autres projets ou de l’environnement global.\n\n\n\nPartie 4 : Poetry - Gestion Avancée des Dépendances et Packaging en Python\n\nIntroduction à Poetry\nPoetry est un outil de gestion des dépendances et de packaging pour les projets Python. Il fournit un système de gestion tout-en-un pour les bibliothèques et les applications, en mettant l’accent sur la facilité d’utilisation, la reproductibilité et la gestion cohérente des dépendances.\n\n\nFonctionnalités Clés de Poetry\n\nGestion des Dépendances :\n\nPoetry utilise le fichier pyproject.toml pour déclarer les dépendances et les métadonnées de projet, adhérant ainsi au standard PEP 518.\nIl gère les dépendances de manière plus intuitive et reproductible, en résolvant automatiquement les conflits de dépendances et en verrouillant les versions avec un fichier poetry.lock.\n\nPackaging et Publication :\n\nPoetry facilite le packaging et la publication de bibliothèques sur des dépôts comme PyPI, en intégrant les outils nécessaires dans un seul workflow.\nIl permet de construire, empaqueter et publier des projets avec des commandes simples et cohérentes.\n\nCréation et Gestion des Environnements Virtuels :\n\nÀ l’instar de Pipenv, Poetry crée automatiquement des environnements virtuels pour isoler les dépendances de chaque projet.\nLorsqu’un projet est activé, Poetry ajuste le PATH pour utiliser l’interpréteur et les outils de cet environnement.\n\n\n\n\nInteraction de Poetry avec PATH\nLorsqu’un environnement virtuel est activé avec Poetry, la variable PATH est modifiée pour diriger les commandes Python vers l’interpréteur spécifique de l’environnement virtuel du projet. Cela permet d’assurer que les dépendances et versions correctes sont utilisées pour chaque projet.\n\n\nAvantages de Poetry\n\nSimplicité et Cohérence : Poetry fournit un workflow clair et cohérent pour la gestion des dépendances et du packaging, simplifiant le processus de développement.\nReproductibilité : Les fichiers pyproject.toml et poetry.lock garantissent que les mêmes versions des dépendances sont installées dans tous les environnements.\nIntégration Facile : Poetry s’intègre facilement dans les systèmes de CI/CD et les flux de travail de développement existants.\n\n\n\n\nPartie 5 : Environnements Virtuels en Python et Exemple avec Docker\n\nA. Qu’est-ce qu’un Environnement Virtuel en Python ?\n\nDéfinition :\n\nUn environnement virtuel en Python est un espace isolé au sein du système qui permet d’exécuter des applications Python dans un contexte séparé, avec ses propres dépendances et interpréteur.\n\nObjectif :\n\nL’objectif principal est de séparer les dépendances requises pour différents projets, évitant ainsi les conflits entre différentes versions des bibliothèques.\n\nComment ils Fonctionnent :\n\nLes environnements virtuels modifient la variable PATH (et d’autres variables d’environnement) pour s’assurer que les commandes Python et pip pointent vers les versions spécifiques à cet environnement.\n\nOutils pour la Création d’Environnements Virtuels :\n\nvenv (intégré dans Python 3.3 et versions ultérieures) et virtualenv sont des outils populaires pour créer des environnements virtuels.\n\n\n\n\nB. Exemple avec Docker\nPour comprendre les environnements virtuels dans un cadre plus large, considérons Docker, une plateforme de conteneurisation qui permet de créer des environnements isolés, appelés conteneurs.\n\nDocker et Isolation :\n\nDocker crée des conteneurs qui sont isolés du système hôte et entre eux. Chaque conteneur peut avoir sa propre configuration, ses propres dépendances et son propre système d’exploitation léger.\n\nComparaison avec les Environnements Virtuels Python :\n\nTandis que les environnements virtuels Python isolent uniquement les dépendances Python, Docker isole l’ensemble du système, y compris le système d’exploitation, les bibliothèques système, etc.\nDocker offre un degré plus élevé d’isolation et de reproductibilité, ce qui est crucial dans les déploiements de production et les systèmes de CI/CD.\n\nUtilisation de Docker avec Python :\n\nVous pouvez créer un conteneur Docker pour un projet Python, où vous installez toutes les dépendances requises, y compris l’interpréteur Python.\nCela garantit que le projet s’exécute dans un environnement contrôlé et cohérent, indépendamment des configurations système de l’hôte.\n\n\n\n\nConclusion sur les Environnements Virtuels\nLes environnements virtuels, qu’ils soient spécifiques à Python ou sous forme de conteneurs Docker, sont essentiels pour maintenir la cohérence des projets, éviter les conflits de dépendances et assurer la reproductibilité des environnements de développement et de production. Ils représentent une pratique standard dans le développement moderne, garantissant que les applications s’exécutent de manière fiable et prévisible dans différents environnements.\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Path.. et environnements virtuels!"
    ]
  },
  {
    "objectID": "content/Cours_1/IDEs/Pycharm.html",
    "href": "content/Cours_1/IDEs/Pycharm.html",
    "title": "PyCharm - L’IDE orienté Python",
    "section": "",
    "text": "Présentation Générale de PyCharm\nPyCharm, développé par JetBrains, est un Environnement de Développement Intégré (IDE) conçu spécifiquement pour Python. Il est reconnu pour son ensemble complet de fonctionnalités qui soutiennent et facilitent le développement en Python. Voyons de plus près ce qui rend PyCharm si apprécié dans la communauté Python.\n\n\n\n1. Fonctionnalités de PyCharm\n\nSupport Intelligent du Code :\n\nPyCharm propose une complétion de code sophistiquée, une vérification d’erreurs en temps réel, et des outils de refactorisation. Ces fonctionnalités aident à augmenter la productivité et à réduire les erreurs potentielles.\n\nIntégration de Frameworks et Bibliothèques :\n\nL’IDE prend en charge de nombreux frameworks Python populaires, comme Django et Flask, ainsi que des bibliothèques scientifiques telles que NumPy et Pandas. Cette intégration facilite le travail sur des projets complexes et spécialisés.\n\nOutils de Débogage et de Test :\n\nPyCharm intègre un débogueur puissant et des outils pour les tests unitaires. Ces outils sont cruciaux pour la maintenance et l’assurance de la qualité du code.\n\nGestion des Systèmes de Version :\n\nCompatible avec divers systèmes de gestion de version tels que Git, SVN, et Mercurial, PyCharm simplifie le suivi des modifications et la collaboration au sein d’équipes de développement.\n\n\n\n\n2. Environnements Virtuels et Gestion des Dépendances\n\nPyCharm simplifie la création et la gestion des environnements virtuels Python, permettant une séparation efficace des dépendances entre les projets.\nL’IDE offre une interface utilisateur intuitive pour la gestion des packages Python, facilitant l’installation et la mise à jour des bibliothèques.\n\n\n\n\n3. Interface Utilisateur et Personnalisation\n\nL’interface de PyCharm est conçue pour être à la fois confortable et productive, avec des options de personnalisation pour l’adapter aux préférences de chaque utilisateur.\nLa prise en charge des plugins permet une extension des fonctionnalités, rendant l’IDE adaptable à divers besoins de développement.\n\n\n\n4. Support pour le Développement Web et la Data Science\n\nPyCharm excelle également dans les domaines du développement web et de la data science. Pour le web, il offre des outils pour HTML, CSS, JavaScript, et des frameworks front-end.\nEn data science, des fonctionnalités comme le support de Jupyter Notebook, la console IPython, et les outils de visualisation de données sont intégrées.\n\n\n\n5. Versions de PyCharm\n\nPyCharm est disponible en deux éditions :\n\nProfessional : une version payante qui offre des fonctionnalités avancées, notamment pour le développement web et la data science.\nCommunity : une version gratuite qui couvre les fonctionnalités de base du développement Python.\n\n\n\n\nConclusion\nPyCharm se distingue comme un choix privilégié pour les développeurs Python grâce à sa gamme étendue de fonctionnalités. Qu’il s’agisse de coder, de tester, de déboguer ou de gérer des projets complexes, PyCharm offre des outils puissants et une expérience de développement intégrée et fluide.\nPour plus d’informations sur PyCharm, consultez la documentation officielle et le getting started guide\n\n\n\n\n Back to top",
    "crumbs": [
      "Quelques IDEs en Python",
      "PyCharm - L'IDE orienté Python"
    ]
  },
  {
    "objectID": "content/Cours_1/IDEs/Spyder.html",
    "href": "content/Cours_1/IDEs/Spyder.html",
    "title": "Spyder - Un IDE Orienté Science des Données",
    "section": "",
    "text": "Présentation de Spyder\nSpyder est un Environnement de Développement Intégré (IDE) créé spécifiquement pour répondre aux besoins des scientifiques, des ingénieurs et des analystes de données qui utilisent Python. Il se distingue par son orientation vers la science des données, offrant des outils et fonctionnalités adaptés à ce domaine.\n\n\n\n1. Fonctionnalités Clés de Spyder\n\nInterface Utilisateur Intuitive :\n\nSpyder propose une interface épurée, divisée en plusieurs panneaux pour l’édition de code, la console Python, la gestion des variables, et la consultation de la documentation.\nCette organisation facilite la navigation et la gestion simultanée de multiples aspects d’un projet.\n\nIntégration de l’IPython :\n\nLa console IPython intégrée à Spyder permet un développement interactif, idéal pour tester des fragments de code, visualiser des données, et effectuer des analyses exploratoires.\nElle supporte également le tracé en ligne et des fonctionnalités de débogage avancées.\n\nOutils de Débogage et d’Exploration des Données :\n\nSpyder inclut un débogueur puissant et des outils d’exploration de données, tels qu’un explorateur de variables et un visualisateur de matrices.\nCes outils sont particulièrement utiles pour comprendre et analyser des ensembles de données complexes.\n\n\n\n\n2. Support pour la Data Science\n\nSpyder est optimisé pour la data science, offrant une intégration native avec des bibliothèques telles que NumPy, Pandas, Matplotlib et SciPy.\nIl fournit des fonctionnalités spécifiques pour la visualisation de données et l’analyse interactive, facilitant la manipulation et l’interprétation des données.\n\n\n\n3. Gestion des Environnements Virtuels\n\nSpyder permet de gérer facilement les environnements virtuels Python, ce qui est crucial pour maintenir les dépendances spécifiques à chaque projet isolées et gérables.\n\n\n\n\n4. Personnalisation et Extensions\n\nBien que Spyder offre moins d’options d’extensions que des IDE comme VS Code, il permet une personnalisation significative de l’interface utilisateur et de l’expérience de développement.\nSa configuration par défaut est déjà bien adaptée aux besoins de la science des données, réduisant le besoin de personnalisation extensive.\n\n\n\n5. Communauté et Ressources\n\nSpyder bénéficie d’une communauté active de développeurs et d’utilisateurs qui fournissent un soutien solide et une variété de ressources d’apprentissage, ce qui le rend accessible aux nouveaux utilisateurs.\n\n\n\nConclusion\nSpyder est un choix idéal pour les professionnels et les étudiants dans les domaines de la science des données, de l’ingénierie ou de la recherche scientifique. Son orientation vers l’analyse et l’exploration de données, combinée à une interface intuitive, le rend particulièrement adapté pour les tâches d’analyse de données complexes et le développement scientifique.\n\n\n\n\n Back to top",
    "crumbs": [
      "Quelques IDEs en Python",
      "Spyder - Un IDE Orienté Science des Données"
    ]
  },
  {
    "objectID": "content/Cours_1/index.html",
    "href": "content/Cours_1/index.html",
    "title": "Comprendre Et Installer Python",
    "section": "",
    "text": "Les cours de cette partie sont:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExécution d’un Programme Python\n\n\nExplorer les mécanismes sous-jacents à l’exécution d’un programme Python pour une compréhension approfondie des processus de compilation et d’interprétation.\n\n\n\nRemi Genet\n\n\n2025-01-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHistoire du Langage\n\n\nExplorer l’histoire de Python, c’est comprendre ses choix de conception, son évolution et sa place actuelle dans le monde de la programmation. Ce chapitre se concentre sur…\n\n\n\nRemi Genet\n\n\n2025-01-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLe PATH\n\n\nExplorer la notion de PATH, un élément essentiel dans la configuration des environnements de développement.\n\n\n\nRemi Genet\n\n\n2025-01-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLes IDEs\n\n\nChoisir son IDE, une question de goûts mais un impact important sur la productivité.\n\n\n\nRemi Genet\n\n\n2025-01-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLes Notebooks\n\n\nLeS Notebooks représentent l’un des support de choix pour la recherche et la datascience, et sont un outil formidable pour une utilisation interractive de Python\n\n\n\nRemi Genet\n\n\n2025-01-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPath.. et environnements virtuels!\n\n\nLes outils pour gerer plusieurs versions de python facilement, et le concept d’environnements virtuels -\n\n\n\nRemi Genet\n\n\n2025-01-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTP - Construire son python depuis la source\n\n\n\n\n\n\nRemi Genet\n\n\n2025-01-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTP Guidé - Installer plusieurs versions de python avec pyenv\n\n\nDébuter de façon guider sur pyenv\n\n\n\nRemi Genet\n\n\n2025-01-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVersions et Compilation de Python\n\n\nExplorer les diverses implémentations de Python et le processus de compilation pour comprendre la diversité et la flexibilité du langage.\n\n\n\nRemi Genet\n\n\n2025-01-29\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to top",
    "crumbs": [
      "Comprendre Et Installer Python"
    ]
  },
  {
    "objectID": "content/Cours_1/1-Histoire.html",
    "href": "content/Cours_1/1-Histoire.html",
    "title": "Histoire du Langage",
    "section": "",
    "text": "Python, un langage de programmation de haut niveau, a été inventé par Guido van Rossum, dont la première version a été publiée en 1991. Ce langage, nommé d’après la série télévisée britannique “Monty Python’s Flying Circus”, a été conçu pour allier clarté syntaxique et puissance fonctionnelle.\nPython a évolué au fil des années, en gardant son principe directeur : une syntaxe qui favorise la lisibilité et la simplicité. Cette approche a conduit à un langage qui est à la fois facile à apprendre pour les débutants et puissant pour les développeurs expérimentés. Python est interprété, ce qui signifie que les scripts sont exécutés ligne par ligne, permettant une débogage et une interaction faciles.\nSa philosophie, encapsulée dans le “Zen de Python” (PEP 20)\n, guide la rédaction de programmes efficaces et lisibles. Il s’agit un ensemble de 19 aphorismes pour écrire de bons programmes en Python. Parmi les plus célèbres, on trouve “Beautiful is better than ugly”, “Explicit is better than implicit” et “Simple is better than complex”. Cette philosophie a été un facteur clé dans le succès de Python, en particulier pour les débutants qui peuvent facilement apprendre le langage et écrire des programmes simples et lisibles et est à garder en tête lors de l’écriture de code Python.\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren't special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first unless you're Dutch.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea -- let's do more of those!\nPour autant, bien que simple à prendre en main, Python est un langage puissant qui pour être réellement maîtrisé et compris dans sa globalité nécessite de la pratique et de l’expérience. De par son fonctionnement interne, le language permet ainsi à des développeurs expérimentés de trouver des solutions élégantes et efficaces à des problèmes complexes, qui serviront ensuite de base à des bibliothèques et frameworks utilisés par des développeurs bien moins expérimentés qui ne se douteront pas une seconde de ce qui se cache en dessous.\nEn résumé, le succès de Python repose sur plusieurs facteurs : sa simplicité, sa polyvalence (il est utilisé dans le développement web, l’analyse de données, l’intelligence artificielle, la science des données, et bien d’autres domaines), et une communauté active qui contribue à un écosystème riche en bibliothèques et frameworks.\n\n\n\nMais le language existe depuis 1991, et a donc évolué au fil des années. En effet, les besoins comme les machines ont changé, et comme la langue humaine, le language de programmation a évolué pour s’adapter à ces changements.\nCe qui est connu de presque tous, c’est que Python a deux grandes versions : Python 2 et Python 3. Python 2 a été largement utilisé et apprécié, mais en 2020, il a été officiellement abandonné au profit de Python 3, qui a été publié en 2008. Et oui, il a fallu 12 ans pour que Python 3 devienne la version officielle de Python, car les différences entre les versions 2 et 3 étaient importantes, et il a fallu du temps pour que les développeurs s’adaptent.\nCela va de la syntaxe à la gestion de la mémoire, en passant par la gestion des chaînes de caractères et des bibliothèques, et l’un des exemples les plus connus est le passage de print à une fonction, qui a été introduit dans Python 3: - Python 2 : print \"Hello World\" - Python 3 : print(\"Hello World\")\nD’exterieur, cela peut sembler être un changement mineur, mais au niveau de ce que cela signifie en terme de fonctionnement interne, c’est un changement majeur. En effet, dans Python 2, print est un mot clé, alors que dans Python 3, c’est une fonction. Cela signifie que dans Python 2, print est un mot clé qui est interprété par l’interpréteur Python, alors que dans Python 3, print est une fonction qui est appelée par l’interpréteur Python.\nCela cache en fait une forme d’uniformisation du code, car Python a la particularité d’être un language objet, et donc tout est un objet, y compris les fonctions. Cela signifie que les fonctions peuvent être passées en paramètre, et donc que les fonctions peuvent être appelées par d’autres fonctions. Cela permet de créer des fonctions qui peuvent être utilisées dans des contextes différents, et donc de réduire la duplication de code.\nEt bien qu’il ai fallu 12 ans pour que Python 3 devienne la version officielle de Python, il a continué d’évoluer, et continue encore aujourd’hui. En effet, Python en est à sa version 3.12, et bien que les changements ne soient pas aussi fondamentaux, les nouvelles capacités dont se dotent le language reste puissantes. On peut ainsi citer l’évolution continue de L’Asynchronisme en Python : - Emergence de l’Asynchronisme: Python a intégré des concepts d’asynchronisme pour répondre aux besoins modernes en programmation, notamment pour la gestion efficace des opérations I/O et pour le développement d’applications web. - asyncio en Python 3.5: Le module asyncio a été introduit dans Python 3.5, marquant un changement significatif dans la gestion de la concurrence et des opérations asynchrones. Il permet d’écrire du code asynchrone en utilisant la syntaxe async/await, facilitant la création de programmes non bloquants. - Améliorations continues: Depuis Python 3.5, il y a eu des améliorations continues dans les fonctionnalités asynchrones, rendant Python plus adapté pour des applications nécessitant de hautes performances en matière de concurrence et d’asynchronisme.\n\n\n\nPourquoi Python est largement adopté : 1. Facilité d’apprentissage et de lecture: La syntaxe de Python est conçue pour être intuitive et lisible, ce qui rend l’apprentissage du langage plus accessible aux débutants. 2. Polyvalence: Python est utilisé dans divers domaines, tels que le développement web, l’analyse de données, l’intelligence artificielle, et la science des données. 3. Bibliothèques et Frameworks: Python bénéficie d’un écosystème riche, avec des bibliothèques comme NumPy, Pandas, TensorFlow, et Flask, qui étendent ses capacités. 4. Communauté active: Une vaste communauté de développeurs contribue à l’amélioration continue de Python et offre un soutien important via des forums et des ressources en ligne. 5. Interopérabilité: Python peut être intégré avec d’autres langages de programmation, ce qui lui permet de s’adapter à divers environnements et exigences de projet.\nCritiques courantes de Python : 1. Vitesse d’exécution: Étant un langage interprété, Python peut être plus lent que les langages compilés comme C ou Java, particulièrement dans les applications nécessitant de lourds calculs. 2. Gestion de la mémoire: Python utilise une gestion de mémoire automatique qui peut entraîner une consommation de mémoire plus élevée. 3. Dépendance aux bibliothèques: La richesse des bibliothèques Python est à double tranchant. Certains développeurs critiquent la dépendance excessive à des bibliothèques externes pour des fonctionnalités de base. 4. Limitations en matière de programmation mobile et de jeux: Python n’est pas le choix principal pour le développement d’applications mobiles et de jeux en raison de sa vitesse et de sa consommation de ressources. 5. Versionnage: La transition de Python 2 à Python 3 a créé des problèmes de compatibilité, bien que cela se soit amélioré avec le temps.\n\n\n\nCes limites viennent de l’histoire du language, et de ses choix de conception. D’une part, Python est un language interprété, et donc il est plus lent que les languages compilés. Cela vient du fait que l’interpréteur Python doit lire le code, le comprendre, et l’exécuter, alors qu’un compilateur va transformer le code en langage machine, et donc le code est directement exécutable.\nCela vient du typage dynamique de Python, qui permet de ne pas avoir à déclarer le type des variables, et donc de ne pas avoir à réserver de la mémoire pour ces variables. Cela permet de ne pas avoir à se soucier de la mémoire, mais cela a un coût, car l’interpréteur Python doit déterminer le type des variables à l’exécution, et donc cela prend du temps.\nEt cela vient du fait que la language a été développé à une époque où les ordinateurs n’avaient qu’un seul CPU, et donc ne pouvaient exécuter qu’une seule instruction à la fois. Cela a conduit à un language qui n’est pas adapté à la programmation parallèle, et donc qui ne peut pas tirer parti des architectures modernes qui ont plusieurs CPU, et donc peuvent exécuter plusieurs instructions en même temps, du moins pas de la même façon que le peut un language comme C. Ce problème est très connu et se nomme le GIL (Global Interpreter Lock), il est un problème qui est connu depuis longtemps, mais qui n’a pas encore été résolu. Un peu de lecture, pour les plus curieux : Python GIL, Python GIL, Python GIL\n\n\n\nLes PEPs (Python Enhancement Proposals) sont des propositions d’amélioration du langage Python. Ils sont utilisés pour discuter des nouvelles fonctionnalités et des changements de comportement du langage. Ils sont également utilisés pour décrire les normes de codage, les processus de développement et les décisions de conception. Les PEPs sont des documents vivants et peuvent être modifiés à mesure que de nouvelles informations sont disponibles.\nLes PEPs sont numérotés et organisés dans une hiérarchie. Les PEPs sont numérotés de 0 à 9999, et sont organisés en trois catégories : - Informational PEPs (PEP 0-99): Les PEPs informatifs fournissent des informations sur le langage Python ou sur les processus de développement. Ils ne décrivent pas de nouvelles fonctionnalités ou de changements de comportement. - Process PEPs (PEP 100-199): Les PEPs de processus décrivent les processus de développement, les normes de codage et les décisions de conception. - Standards Track PEPs (PEP 200-9999): Les PEPs de la norme de suivi décrivent les nouvelles fonctionnalités et les changements de comportement du langage Python.\nLes PEPs sont écrits en utilisant le format reStructuredText, et sont publiés sur le site web officiel de Python. Les PEPs sont discutés et révisés par la communauté Python, et sont acceptés ou rejetés par le BDFL (Benevolent Dictator For Life), Guido van Rossum.\nDans les derniers PEPs, l’un pourrait changer radicalement Python, le PEP 703 – Making the Global Interpreter Lock Optional in CPython] qui propose de supprimer le GIL, et donc de permettre à Python d’être utilisé pour de la programmation parallèle. Cela permettrait à Python de tirer parti des architectures modernes.\nCela en tête nous pouvons donc commencer à apprendre Python, et à comprendre comment il fonctionne.",
    "crumbs": [
      "Histoire du Langage"
    ]
  },
  {
    "objectID": "content/Cours_1/1-Histoire.html#section-1.1---origines",
    "href": "content/Cours_1/1-Histoire.html#section-1.1---origines",
    "title": "Histoire du Langage",
    "section": "",
    "text": "Python, un langage de programmation de haut niveau, a été inventé par Guido van Rossum, dont la première version a été publiée en 1991. Ce langage, nommé d’après la série télévisée britannique “Monty Python’s Flying Circus”, a été conçu pour allier clarté syntaxique et puissance fonctionnelle.\nPython a évolué au fil des années, en gardant son principe directeur : une syntaxe qui favorise la lisibilité et la simplicité. Cette approche a conduit à un langage qui est à la fois facile à apprendre pour les débutants et puissant pour les développeurs expérimentés. Python est interprété, ce qui signifie que les scripts sont exécutés ligne par ligne, permettant une débogage et une interaction faciles.\nSa philosophie, encapsulée dans le “Zen de Python” (PEP 20)\n, guide la rédaction de programmes efficaces et lisibles. Il s’agit un ensemble de 19 aphorismes pour écrire de bons programmes en Python. Parmi les plus célèbres, on trouve “Beautiful is better than ugly”, “Explicit is better than implicit” et “Simple is better than complex”. Cette philosophie a été un facteur clé dans le succès de Python, en particulier pour les débutants qui peuvent facilement apprendre le langage et écrire des programmes simples et lisibles et est à garder en tête lors de l’écriture de code Python.\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren't special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first unless you're Dutch.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea -- let's do more of those!\nPour autant, bien que simple à prendre en main, Python est un langage puissant qui pour être réellement maîtrisé et compris dans sa globalité nécessite de la pratique et de l’expérience. De par son fonctionnement interne, le language permet ainsi à des développeurs expérimentés de trouver des solutions élégantes et efficaces à des problèmes complexes, qui serviront ensuite de base à des bibliothèques et frameworks utilisés par des développeurs bien moins expérimentés qui ne se douteront pas une seconde de ce qui se cache en dessous.\nEn résumé, le succès de Python repose sur plusieurs facteurs : sa simplicité, sa polyvalence (il est utilisé dans le développement web, l’analyse de données, l’intelligence artificielle, la science des données, et bien d’autres domaines), et une communauté active qui contribue à un écosystème riche en bibliothèques et frameworks.",
    "crumbs": [
      "Histoire du Langage"
    ]
  },
  {
    "objectID": "content/Cours_1/1-Histoire.html#section-1.2---et-évolution",
    "href": "content/Cours_1/1-Histoire.html#section-1.2---et-évolution",
    "title": "Histoire du Langage",
    "section": "",
    "text": "Mais le language existe depuis 1991, et a donc évolué au fil des années. En effet, les besoins comme les machines ont changé, et comme la langue humaine, le language de programmation a évolué pour s’adapter à ces changements.\nCe qui est connu de presque tous, c’est que Python a deux grandes versions : Python 2 et Python 3. Python 2 a été largement utilisé et apprécié, mais en 2020, il a été officiellement abandonné au profit de Python 3, qui a été publié en 2008. Et oui, il a fallu 12 ans pour que Python 3 devienne la version officielle de Python, car les différences entre les versions 2 et 3 étaient importantes, et il a fallu du temps pour que les développeurs s’adaptent.\nCela va de la syntaxe à la gestion de la mémoire, en passant par la gestion des chaînes de caractères et des bibliothèques, et l’un des exemples les plus connus est le passage de print à une fonction, qui a été introduit dans Python 3: - Python 2 : print \"Hello World\" - Python 3 : print(\"Hello World\")\nD’exterieur, cela peut sembler être un changement mineur, mais au niveau de ce que cela signifie en terme de fonctionnement interne, c’est un changement majeur. En effet, dans Python 2, print est un mot clé, alors que dans Python 3, c’est une fonction. Cela signifie que dans Python 2, print est un mot clé qui est interprété par l’interpréteur Python, alors que dans Python 3, print est une fonction qui est appelée par l’interpréteur Python.\nCela cache en fait une forme d’uniformisation du code, car Python a la particularité d’être un language objet, et donc tout est un objet, y compris les fonctions. Cela signifie que les fonctions peuvent être passées en paramètre, et donc que les fonctions peuvent être appelées par d’autres fonctions. Cela permet de créer des fonctions qui peuvent être utilisées dans des contextes différents, et donc de réduire la duplication de code.\nEt bien qu’il ai fallu 12 ans pour que Python 3 devienne la version officielle de Python, il a continué d’évoluer, et continue encore aujourd’hui. En effet, Python en est à sa version 3.12, et bien que les changements ne soient pas aussi fondamentaux, les nouvelles capacités dont se dotent le language reste puissantes. On peut ainsi citer l’évolution continue de L’Asynchronisme en Python : - Emergence de l’Asynchronisme: Python a intégré des concepts d’asynchronisme pour répondre aux besoins modernes en programmation, notamment pour la gestion efficace des opérations I/O et pour le développement d’applications web. - asyncio en Python 3.5: Le module asyncio a été introduit dans Python 3.5, marquant un changement significatif dans la gestion de la concurrence et des opérations asynchrones. Il permet d’écrire du code asynchrone en utilisant la syntaxe async/await, facilitant la création de programmes non bloquants. - Améliorations continues: Depuis Python 3.5, il y a eu des améliorations continues dans les fonctionnalités asynchrones, rendant Python plus adapté pour des applications nécessitant de hautes performances en matière de concurrence et d’asynchronisme.",
    "crumbs": [
      "Histoire du Langage"
    ]
  },
  {
    "objectID": "content/Cours_1/1-Histoire.html#section-1.3-----popularité-et-critiques",
    "href": "content/Cours_1/1-Histoire.html#section-1.3-----popularité-et-critiques",
    "title": "Histoire du Langage",
    "section": "",
    "text": "Pourquoi Python est largement adopté : 1. Facilité d’apprentissage et de lecture: La syntaxe de Python est conçue pour être intuitive et lisible, ce qui rend l’apprentissage du langage plus accessible aux débutants. 2. Polyvalence: Python est utilisé dans divers domaines, tels que le développement web, l’analyse de données, l’intelligence artificielle, et la science des données. 3. Bibliothèques et Frameworks: Python bénéficie d’un écosystème riche, avec des bibliothèques comme NumPy, Pandas, TensorFlow, et Flask, qui étendent ses capacités. 4. Communauté active: Une vaste communauté de développeurs contribue à l’amélioration continue de Python et offre un soutien important via des forums et des ressources en ligne. 5. Interopérabilité: Python peut être intégré avec d’autres langages de programmation, ce qui lui permet de s’adapter à divers environnements et exigences de projet.\nCritiques courantes de Python : 1. Vitesse d’exécution: Étant un langage interprété, Python peut être plus lent que les langages compilés comme C ou Java, particulièrement dans les applications nécessitant de lourds calculs. 2. Gestion de la mémoire: Python utilise une gestion de mémoire automatique qui peut entraîner une consommation de mémoire plus élevée. 3. Dépendance aux bibliothèques: La richesse des bibliothèques Python est à double tranchant. Certains développeurs critiquent la dépendance excessive à des bibliothèques externes pour des fonctionnalités de base. 4. Limitations en matière de programmation mobile et de jeux: Python n’est pas le choix principal pour le développement d’applications mobiles et de jeux en raison de sa vitesse et de sa consommation de ressources. 5. Versionnage: La transition de Python 2 à Python 3 a créé des problèmes de compatibilité, bien que cela se soit amélioré avec le temps.",
    "crumbs": [
      "Histoire du Langage"
    ]
  },
  {
    "objectID": "content/Cours_1/1-Histoire.html#section-1.4---comprendre-ces-limites",
    "href": "content/Cours_1/1-Histoire.html#section-1.4---comprendre-ces-limites",
    "title": "Histoire du Langage",
    "section": "",
    "text": "Ces limites viennent de l’histoire du language, et de ses choix de conception. D’une part, Python est un language interprété, et donc il est plus lent que les languages compilés. Cela vient du fait que l’interpréteur Python doit lire le code, le comprendre, et l’exécuter, alors qu’un compilateur va transformer le code en langage machine, et donc le code est directement exécutable.\nCela vient du typage dynamique de Python, qui permet de ne pas avoir à déclarer le type des variables, et donc de ne pas avoir à réserver de la mémoire pour ces variables. Cela permet de ne pas avoir à se soucier de la mémoire, mais cela a un coût, car l’interpréteur Python doit déterminer le type des variables à l’exécution, et donc cela prend du temps.\nEt cela vient du fait que la language a été développé à une époque où les ordinateurs n’avaient qu’un seul CPU, et donc ne pouvaient exécuter qu’une seule instruction à la fois. Cela a conduit à un language qui n’est pas adapté à la programmation parallèle, et donc qui ne peut pas tirer parti des architectures modernes qui ont plusieurs CPU, et donc peuvent exécuter plusieurs instructions en même temps, du moins pas de la même façon que le peut un language comme C. Ce problème est très connu et se nomme le GIL (Global Interpreter Lock), il est un problème qui est connu depuis longtemps, mais qui n’a pas encore été résolu. Un peu de lecture, pour les plus curieux : Python GIL, Python GIL, Python GIL",
    "crumbs": [
      "Histoire du Langage"
    ]
  },
  {
    "objectID": "content/Cours_1/1-Histoire.html#section-1.5---les-peps",
    "href": "content/Cours_1/1-Histoire.html#section-1.5---les-peps",
    "title": "Histoire du Langage",
    "section": "",
    "text": "Les PEPs (Python Enhancement Proposals) sont des propositions d’amélioration du langage Python. Ils sont utilisés pour discuter des nouvelles fonctionnalités et des changements de comportement du langage. Ils sont également utilisés pour décrire les normes de codage, les processus de développement et les décisions de conception. Les PEPs sont des documents vivants et peuvent être modifiés à mesure que de nouvelles informations sont disponibles.\nLes PEPs sont numérotés et organisés dans une hiérarchie. Les PEPs sont numérotés de 0 à 9999, et sont organisés en trois catégories : - Informational PEPs (PEP 0-99): Les PEPs informatifs fournissent des informations sur le langage Python ou sur les processus de développement. Ils ne décrivent pas de nouvelles fonctionnalités ou de changements de comportement. - Process PEPs (PEP 100-199): Les PEPs de processus décrivent les processus de développement, les normes de codage et les décisions de conception. - Standards Track PEPs (PEP 200-9999): Les PEPs de la norme de suivi décrivent les nouvelles fonctionnalités et les changements de comportement du langage Python.\nLes PEPs sont écrits en utilisant le format reStructuredText, et sont publiés sur le site web officiel de Python. Les PEPs sont discutés et révisés par la communauté Python, et sont acceptés ou rejetés par le BDFL (Benevolent Dictator For Life), Guido van Rossum.\nDans les derniers PEPs, l’un pourrait changer radicalement Python, le PEP 703 – Making the Global Interpreter Lock Optional in CPython] qui propose de supprimer le GIL, et donc de permettre à Python d’être utilisé pour de la programmation parallèle. Cela permettrait à Python de tirer parti des architectures modernes.\nCela en tête nous pouvons donc commencer à apprendre Python, et à comprendre comment il fonctionne.",
    "crumbs": [
      "Histoire du Langage"
    ]
  }
]